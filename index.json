[{"categories":["逆向"],"content":"0x0 前言 纸上得来终觉浅，DLL注入光听书中说总是不过瘾，于是自己动手写一写代码。这也是我第一次写Windows编程，虽然都是C语言，但变量类型，API却一点也不了解。可是做Windows逆向不会Windows编程怎么行呢？于是这个小项目也用来入门Windows编程，熟悉一些常用写法和API。后面在实现API Hook时，我也是通过这个DLL 注入工具进行HOOK测试。 这个小项目是参考了injectAllTheThings项目，以及《核心原理》DLL注入部分内容编写完成的，其中的反射式DLL注入是参考了作者stephenfewer开源代码完成。参考项目链接都放在后面了。 我实现了五种注入方法，如下图所示 同时还实现了向全进程注入以及卸载DLL的功能。 为了再次强化学习DLL注入的知识，再加上网上对这个技术分析的文章质量实在不敢恭维，因此自己就想把自己的学习过程以及对这个技术的理解尽可能高质量的清晰地写出来。 该博客里的代码并不完整，可以将项目的代码对着博客理解。 项目地址： DllInJectionTool 参考项目： injectAllTheThings ReflectiveDLLInjection 0x1 何为DLL注入 先简单介绍一下什么是DLL, DLL(Dynamic Linked Library，动态链接库)的存在是为了解决因库函数多次被程序加载至内存导致内存浪费的情况。当一个DLL首次被进程加载后，该DLL的代码以及资源就可以实现共享，允许其他的进程使用。 DLL还有一个特性，当DLL被加载到进程内存空间后会自动执行DllMain()函数，只要将想要程序执行的代码写入DllMain函数中，当该DLL被加载后这些代码就会自动执行，这也就是DLL注入的原理。 因此DLL注入聚焦于如何让已经运行的程序加载外部DLL。同时，会在最后更改PE文件数据，通过静态方法让PE文件在启动时自动加载目标DLL。 0x2 CreateRemoteThread, RtlCreateUserThread and NtCreateThreadEx 0x2.1CreateRemoteThread 通过CreateRemoteThread函数来实现DLL注入是非常经典的方法。该方法的实现思路如下，首先为DLL路径字符串申请内存空间，将DLL路径写入目标进程的内存中，并通过Get","date":"2022-03-24","objectID":"/dllinjection/:0:0","tags":["逆向"],"title":"常用DLL注入技术解析","uri":"/dllinjection/"},{"categories":["逆向"],"content":"网上和论坛全是32位 老版本的010 editor破解的教程，没有64位版本，自己也需要用，可是软件太贵了，于是自己尝试了一下暴力和算法逆向写注册机两种方法进行破解。使用的版本是v12.0.1 64bit，在该博客发表时还是官网最新版。 该博客仅用作个人技术学习交流，勿用于其余用途，请在自己经济条件允许的情况下支持正版。 0x00 爆破法 把010 editor放入x64dbg运行起来，然后在tool-\u003eregister处随意输入序列号，此时会弹出对话框，再到x64dbg中搜索该字符串，于是可以跳转到认证序列号的代码处。 如下图所示，当我们在使用该字符串的地址处打上断点，再次check license后就会在断点处停止 在图中指令 mov edx,90 的上一条指令为jmp指令，如果程序从该指令以上执行下来的话便不会再执行图中的指令，那么我们可以推测程序存在某处跳转，让程序从mov edx,90指令 开始执行，如是查看 mov edx,90的交叉引用，如下图所示 在地址7FF7F967574F处存在jne 7FF7F9675819，即跳转到mov edx,90处的指令 那么继续往上看，地址7FF7F967574F处的jne是判断那两个数据不相同时才跳转 如上图所示，若ebx不等于93那么就会跳转至弹出序列号不正确的代码处，如果相等则会判断edi是否等于73，如果等于则会弹出提示“密码正确，试用期延长”的窗口。我们在地址7FF7F967574F处打上断点，查看各使用的寄存器的值，以此判断是在哪些地方发生了跳转 可以发现，edi = 117 != ED != 20C因此会直接运行到cmp ebx,93处，而此时ebx=E7 !=93，因此发生了跳转，而且edi = 117 !=71，但cmp edi,71处的跳转到的代码并不是我们所期望的，因此我们进追踪ebx有关的代码 同时在地址7FF7F9675731处的上一条指令为jmp ，且跳转到我们并不需要的代码段处，因此可以判断该jmp在此次运行中并不会执行，那么就存在某处的jxx指令跳转到了地址7FF7F9675731，同样的查找交叉引用，发现地址7FF7F967559B处存在指令jne 7FF7F9675731，如下图所示 可见在地址7FF7F967559B处 会判断edi是否等于EB,等于则会表明序列号正确，否则就会跳","date":"2022-03-01","objectID":"/010editorcracker/:0:0","tags":["逆向","破解"],"title":"010editor 最新V12版本逆向算法以及暴力破解","uri":"/010editorcracker/"},{"categories":["逆向"],"content":"PE文件基本概述 PE文件可分为PE头与PE体。DOS头到节区头都是PE头部份，其下节区合称为PE体，并且PE节区紧跟在NT头后。 对于PE文件结构的分析，我们需要明确如下几个概念 虚拟地址：内存中使用Virtual Address来表示位置，VA指的是进程虚拟内存的绝对地址。 相对虚拟地址：要与虚拟地址区别开来，相对虚拟地址(Relative Virtual Address)指的是从某个基准位置(ImageBase)开始的相对地址。VA与RVA存在一个换算关系 ​ RVA + ImageBase = VA 为什么要这样做？这样做有个好处，当PE文件的内部数据都以相对虚拟地址存在的时候，当文件从硬盘加载到内存，若加载出存在了文件，那么该文件就应该进行重定位，如果使用RVA，文件进行重定位后并不影响该文件数据的定位，因为此时只需要根据重定位的定制变更ImageBase就可以正常定位到所有原来的地址。如果是使用VA，当重定位后，每个地址都需要一起改变，否则就会定位失败，读取不到正确的信息。 映像(Image)：PE文件加载到内存时，文件不会全部加载，而是根据节区头起始地址、节区大小等属性值来加载。因此内存和磁盘中的PE具有不同的形态。把加载到内存的形态称为映像加以区别。 节：节是PE文件中代码或数据的基本单位。可分为三个大类，代码(.text)、数据(.data)、资源(.src)节。 最小基本单位：我们知道内存中的数据存放时是按照最小基本单位的倍数进行放入，也就是段、页的概念，如果数据被按照这样存入内存，当数据的大小不能刚好填充满最小基本单位的倍数时，就会用NULL填充，因此在PE头与各节区的尾部都存在一个区域，称为NULL填充。最小基本单位是为了提高处理文件、内存、网络包的效率。具体可以自行去了解。 各节区头定义了各节区在文件或内存中的大小、位置、属性等。 需特别说明，在Intel的CPU以小端序保存数据，即高位字节保存在高位地址 DOS头 DOS头存在的目的是为了让PE文件兼容DOS文件。 DOS头为一个名为IMAGE_DOS_HEADER的结构体，用来扩展已有的DOS EXE头 该结构体总共64字节，成员有19个， （最左边是文件头的偏移量。） IMAGE_DOS_HEADER STRUCT { +0h WORD e_magic // MZ(4Dh 5Ah) D","date":"2022-01-10","objectID":"/pe_structure_analysis/:0:0","tags":["逆向"],"title":"PE文件结构解析","uri":"/pe_structure_analysis/"},{"categories":["逆向"],"content":"第五题： **任务：**找到FLAG，也就是APP正确的账号密码 步骤： 先打开APP看看运行出现的东西， 将apk用jadx打开，并查看com.example.test.MainActivity的代码 其中可以发现关键的函数，即Encrypt.b ，Encrypt.a，getBytes 后面的if中调用equals函数可知，该代码的作用就是对输入的账号密码通过Encrypt类的a和b函数进行加密，然后与正确的加密后的账号密码比对是否相等。 那么只需要将bArr以及第一个equals中new byte[]的字节数组进行解码即可。 首先查看Encrypt类 加密的方法很简单，先将输入的账号密码和 i 进行异或，在调用Base64的库函数进行Base64编码。 那么获得正确的账号密码的方法就很明显了，直接将程序中列出来的两个字节数组先进行Base64的解码，在和 相同的 i 进行异或即可。 这里通过java来进行解密，还需了解一下 Base64库的decode函数的使用，就是喂一个字节数字数组，通过Base64加密返回一个 字节字符数组。 JAVA解密代码如下： package com.example.helloworld; import java.util.Base64; public class HelloWorld { public static void main(String[] args) { Base64.Decoder decoder = Base64.getDecoder(); byte[] data = {78, 106, 73, 49, 79, 122, 65, 51, 89, 71, 65, 117, 78, 106, 78, 109, 78, 122, 99, 55, 89, 109, 85, 61}; byte[] data1 = {89, 87, 66, 108, 79, 109, 90, 110, 78, 106, 65, 117, 79, 109, 74, 109, 78, 122, 65, 120, 79, 50, 89, 61}; byte[]bArr = decoder.decode(data); byte[]bArr1 = decoder.decode(data1); System.out.println(); int leng","date":"2021-10-30","objectID":"/bili1024_21/:0:0","tags":["逆向"],"title":"B站1024逆向题","uri":"/bili1024_21/"},{"categories":["Fuzz"],"content":"任务：给AFL添加socket发包功能，使其支持测试DNS协议 参考代码： 因为不太方便直接贴出源码，所以就说明一下思路，记录一些实现 时遇到的错误。 主要的问题有： 写了发包的函数，需要在哪里调用？ 如何解决超时的问题？如何及时杀死子进程？ 如何配置dnsmasq？？？？？？？？？（弄这玩意给我重装系统了） 需要了解的知识点： AFL大概的执行流程 AFL的从哪里获得输入文件 AFLmain函数的死循环在执行什么 target如何获取输入文件 fuzz dns的结果afl是通过什么 途径获取的 管道的概念 afl的main函数大概执行流程： 通过read_testcases从输入文件夹读取所有文件，然后进行排队进行测试，然后调用add_to_queue函数创建queue_entry结构体作为输入文件队列，通过perform_dry_run函数第一次运行测试样例。进入死循环就循环将输入队列当前的输入文件丢入fuzz_one函数处理，该处理就是将种子变异并添加到输入队列里去。 run_target函数就是fork出一个子进程(fuzz的目标程序)进行fuzz。那么socket发包函数的调用就需要在这个位置。run_target函数被调用的地方存在于main函数死循环中的多个函数中，有calibrate_case函数等。 socket发包函数就在定时器设定好后面加即可。原因会在后面信号处理相关解释。 既然要通过socket发送输入文件，那么从哪里获取输入文件呢？ write_to_testcases函数就是用来写入到输入文件中的，该函数的参数为void *mem 和 u32 len，那么就定义两个个全局变量用来获取mem和len来给socket发送即可。 socket发包函数就是普通的socket client的代码，要注意的就是发送了输入文件后，就应该终止该子进程了，那么如何关闭呢？ 下面是对信号及信号量处理的解释（这是避免超时的解决办法） SIGTERM： 程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和处理，通常用来要求程序自己正常退出。 下面这段程序是在socket发包程序当中的。是在关闭了socket后，才运行来结束子进程的。 第一个if用来判断子进程是否还存在，存在则通过kill函数传递SIGTERM信号告诉进程运行完了就快结束。 while（1）","date":"2021-10-22","objectID":"/afl_add_socket/:0:0","tags":["Fuzz"],"title":"AFL添加socket发包功能","uri":"/afl_add_socket/"},{"categories":["操作系统"],"content":"lab3 ","date":"2021-05-26","objectID":"/oslab3/:0:0","tags":["操作系统"],"title":"进程运行轨迹的跟踪与统计","uri":"/oslab3/"},{"categories":["操作系统"],"content":"一、任务内容 基于模板process.c编写多进程的样本程序，实现以下功能： 所有子进程都并行运行，每个子进程实际的运行时间不超过30秒 父进程向标准输出打印所有子进程的id，并且在所有子进程退出后才退出 实现进程运行轨迹的跟踪。在内核中维护一个日志文件process.log，把从操作系统启动到系统关机过程中所有进程的运行轨迹都记录在这一log文件中 统计log文件记录该程序建立的所有进程的等待时间，完成时间(轮转时间)和运行时间，计算平均等待时间，平均完成时间，和吞吐量。 修改进程调度的时间片，运行同样的样本程序统计同样的时间数据，和原有的情况对比，体会时间片带来的差异 ","date":"2021-05-26","objectID":"/oslab3/:0:1","tags":["操作系统"],"title":"进程运行轨迹的跟踪与统计","uri":"/oslab3/"},{"categories":["操作系统"],"content":"二、明确进程的概念以及其生命周期内运行过程 那么何为进程呢？ 操作系统为正在运行的程序提供的抽象，就是进程，是操作系统提供的基本抽象 非正式定义可以定义为，正在运行的程序。但程序本身是没有生命周期的，他只是存在磁盘上的一些指令或者静态数据，是操作系统让这些字节运行起来，让程序发挥作用。 我们通过清点一个运行的程序在执行过程中访问或影响的系统的不同部分，从而概括一个进程。 这里引入一个新的概念，进程的机器状态(machine state)：程序运行时可以读取或更新的内容。 因此我们要关注，任何时刻下，机器哪些部分对执行该程序很重要。 我们知道存放在内存的程序才能被运行，因此组成机器状态的重要的部分就是内存。指令存放在内存中，正在运行的程序读取和写入的数据也存在内存中，因此进程能访问的内存就是该进程的一部分。 进程的机器状态另一部分就是寄存器。因为很多指令都是明确的读取或更新寄存器，所以寄存器对程序的执行很重要。 进程创建的一些细节： 操作系统运行程序第一件事就是讲代码和所有静态数据加载到内存中，加载到进程的地址空间中。 早期操作系统中，加载这个过程需要尽早完成，即在运行程序之前全部完成。 但随着现在程序越来越大，内存根本不可能一次性存放如此大的程序。你看现在的游戏都是10G以上，而我们的内存可能是8G,16G等，所以大多时候内存的大小无法载入整个程序。 因此，现代操作系统惰性地(lazily)执行该过程，也就是仅在程序执行期间需要加载的代码或数据片段，才会加载到内存当中。换句话说我用谁我让谁进入内存，当内存满了之后我根据我的调度策略，将该换出去片段换出去，再把要用的片段加载进来。(这部分需要了解分页和交换的机制) 当我们把程序载入到内存后，操作系统还会自动为程序分配运行时栈(run-time stack or stack) 操作系统也可能会为程序的堆分配内存，这需要用户主动的显式的申请，例如malloc()这样的调用来申请空间，再通过free()释放内存。 在UNIX系统中，每个程序都会有三个文件描述符，分别是标准输入stdin，标准输出stdout，标准错误stderr。所以操作系统还会初始化一些其他的任务，例如I/O相关的任务。 完成上述任务后，PC指针就指向程序main函数入口地址，开始执行程序。 总结就是：操作系统要执行一个程序，首先将代码和静态数据载入内存，","date":"2021-05-26","objectID":"/oslab3/:0:2","tags":["操作系统"],"title":"进程运行轨迹的跟踪与统计","uri":"/oslab3/"},{"categories":["操作系统"],"content":"三、实践部分 (代码是自己再打一遍的，可能会有一些人为错误，有的话还希望指出) 首先先编写能生成多进程的程序process.c 该程序包含两个部分，第一个部分是多进程创建的代码，第二部分是获取该进程使用CPU的时间以及模拟I/O操作的代码 下面这段是第二部分代码： 先放出第二部分代码是因为，第一部分的代码需要用到第二部分的 /* * 此函数按照参数占用CPU和I/O时间 * last: 函数实际占用CPU和I/O的总时间，不含在就绪队列中的时间，\u003e=0是必须的 * cpu_time: 一次连续占用CPU的时间，\u003e=0是必须的 * io_time: 一次I/O消耗的时间，\u003e=0是必须的 * 如果last \u003e cpu_time + io_time，则往复多次占用CPU和I/O * 所有时间的单位为秒 */ void cpuio_bound(int last, int cpu_time, int io_time) { struct tms start_time, current_time; clock_t utime, stime; int sleep_time; while (last \u003e 0) { /* CPU Burst ，指CPU执行指令的那一段时间区间*/ times(\u0026start_time); /* 其实只有t.tms_utime才是真正的CPU时间。但我们是在模拟一个 * 只在用户状态运行的CPU大户，就像“for(;;);”。所以把t.tms_stime * 加上很合理。*/ /*用来模拟cpu_time时间内使用CPU */ do { times(\u0026current_time); utime = current_time.tms_utime - start_time.tms_utime; stime = current_time.tms_stime - start_time.tms_stime; } while ( ( (utime + stime) / HZ ) \u003c cpu_time ); last -= cpu_time; if (last \u003c= 0 ) break; /* IO Burst ，指I/O设备被请求执行开始到执行结束的时间区间*/ /* 用sleep(1)模拟1秒钟的I/O操作 */ sleep_time=0; while (sleep_","date":"2021-05-26","objectID":"/oslab3/:0:3","tags":["操作系统"],"title":"进程运行轨迹的跟踪与统计","uri":"/oslab3/"},{"categories":["操作系统"],"content":"四、进程运行轨迹的跟踪与统计结果 我们尽量在Linux0.11外写好process.c文件(因为Linux0.11装载的vi书写效率很低)，然后在bochs虚拟机装载的Linux根目录文件系统的镜像文件所在目录，通过这个方式我们能进行文件交通信，通过 sudo ./mount-hdc 打开访问权限，然后将process.c文件放入hdc/usr/root/ 文件夹里。 然后输入(目录不要变，不是在hdc里面，而是hdc外一层目录，就是输入第一个指令的目录) sudo umount hdc 卸载该文件系统。 在然后在上述目录下运行Linux0.11，并编译运行process.c ./run //运行Linux0.11 ls //可以查看/usr/root有没有加入process.c文件 gcc process -o process.c //编译 ./process //运行 我们会看到如下运行结果 此时process.log文件已经记录好了各进程的运行轨迹，因此我们退出Linux0.11 process.log文件如下： 我们通过上面说过的 打开我们bochs虚拟机装载的Linux的文件系统，从/hdc/var中找到process.log文件，拿到我们系统的文件夹中。 因为我们重点不在书写统计结果的代码，所以我们现在利用现有的统计结果的代码直接统计，改代码的逻辑思路就是通过 ID号进行结果分类，再通过jiffies 和状态的关系进行简单的加减运算即可。 统计代码是python写的，名称为stat_log.py，将该文件和process.log日志文件放在一起，从命令行进入该文件夹输入指令 chmod +x stat_log.py 给该文件加上执行权限，在输入如下指令直接执行数据统计 ./stat_log.py process.log 得到如下结果Turnaround 为进程的轮转时间，即进程执行的总时(任务完成时间减去任务开始时间) waiting 就是进程睡眠时间 CPU Burst为该进程执行指令的用时，I/O Burst为该进程使用I/O设备的用时。 如果遇到 Error at line xxx:It is a clone of previous line. 大概率是某个记录进程状态的添加的语句出现了错误或者少了if判断语句导致重复记录一个进程的状态或状态冲突了","date":"2021-05-26","objectID":"/oslab3/:0:4","tags":["操作系统"],"title":"进程运行轨迹的跟踪与统计","uri":"/oslab3/"},{"categories":["操作系统"],"content":"LAB2 一、 任务内容： 在原有的linux0.11上添加两个系统调用，及其相应的响应函数，并通过API调用系统调用。 两个系统调用的原型和应该完成的功能如下 （1）iam() int iam(const char *name); 功能：将name的内容拷贝到内核中保存下来 要求：name长不能超过24个字符，包括最后的'\\0' 返回值：拷贝的字符串name的长度。若name长超过24，则返回 -1，并置errno为EINVAL（errno是个头文件，即return -EINVAL,EINVAL是errno.h里的一个宏定义） （2）whoami() int whoami(char *name,unsigned int size); 功能：将iam()保存到内核空间的字符串拷贝到name字符串指向的用户地址空间中，为了确保name不会越界访问，用size说明其大小 返回值：拷贝字符串name的长度。若size小于name所占空间，返回 -1，并置errno为EINVAL 二、明确何为系统调用。做什么的？如何做？ 要谈系统调用，那我们还是先了解一下何为内核。(只是让我自己再复习一下概念，能否说清楚) 操作系统其实就是一个监控程序，对的，也是一个程序。它相当于单片机我们写的while(1)，而内核就是操作系统最核心的部分，也即这个程序里面最核心的代码。我们可以从linux源码看出其内核负责处理各种核心任务，比如I/O,进程管理，内存管理等。 所以内核即操作系统这个程序里面最关键的代码。也就是他是计算机资源的管理者，包括硬件，软件资源。软件资源就是各种形式的数据，比如各种文件，软件程序。硬件资源就是总线、CPU、内存、磁盘、网卡、显卡及各种IO。 那么系统调用是如何出现的呢？ 我们假设如果没有操作系统来管理各种进程，举个栗子，每个进程需要放进内存才能执行，那么就会在占用内存空间，如果两个任务同时申请同一个内存空间会造成冲突。更为严重，如果一个任务占用了必须一直运行的程序或者非常重要的程序的内存空间，那么计算机就崩溃了。 同时，如果有操作系统，并且不对进程加以限制及控制，会发生什么情况？ 在举几个栗子，对于单任务，他可能把他的空间占用到了原本分配给操作系统的空间，那么两者就混合了，没办法区分，并且用户程序可以访问大部分硬件设备，甚至改变操作系统，如果一个病毒(恶意进程)也","date":"2021-05-18","objectID":"/oslab2/:0:0","tags":["操作系统"],"title":"操作系统的系统调用","uri":"/oslab2/"},{"categories":["操作系统"],"content":"lab 1 环境：通过bochs虚拟机运行的linux0.11 0x7C00是BIOS将主引导扇区（第一个扇区）内容载入进内存的一个地址。操作系统或者引导程序必须假设他们的汇编代码从内存的0x7C00地址开始 ","date":"2021-05-11","objectID":"/oslab1/:0:0","tags":["操作系统"],"title":"操作系统的引导","uri":"/oslab1/"},{"categories":["操作系统"],"content":"task 1 更改系统启动的提示文字。 文件在boot/bootsect.s中。 直接用源码的这个文件在里面改也是可以的，也可以自己写一个如下内容的bootsect.s来进行实验，也是能正常运行。（记得备份） entry _start _start: ！获得光标位置 mov ah,#0x03 xor bh,bh int 0x10 ！0x10中断的0x03功能是读取光标位置（百度该中断的功能） ！对输出信息的操作 mov cx,#33 !要显示字符串的长度 mov bx,#0x000c !显示字符串的颜色（这为红色 mov bp,#msg1 !向该寄存器读入msg1，向屏幕写入该字符串 ！这里需要额外处理es寄存器，源码在这段代码前就处理过了，所以源码看不到这段。 mov ax,#0x07c0 mov es,ax ！es:bp是显示字符串的地址 mov ax,#0x1301 !向屏幕写字符串并移动光标到末尾。如果写0x1300，你会发现光标返回到了起始位置 int 0x10 ！和上一条指令相关，!0x1301是调用0x10中断的13号功能中的1号子功能 inf_loop: jmp inf_loop ！死循环让界面保持 msg1: .byte 13,10 ！回车换行 .ascii \"Hey Doors system loading...\" .byte 13,10,13,10 ！回车换行回车换行 .org 510 ！之后的语句从510地址开始 boot_flag: .word 0xAA55 ！磁盘引导标志0xAA55。引导扇区的最后两个字节，用来识别引导扇区 编译bootsect.s 1. cd 进入 bootsect.s文件所在文件夹 2. 通过如下命令分别编译和链接bootsect.s $ as86 -0 -a -o bootsect.o bootsect.s $ ld86 -0 -s -o bootsect bootsect.o 3. 通过 ls -s 命令查看 文件信息，会发现bootsect 为544字节，但一个扇区的大小为512字节 因为ld86产生的是Minix可执行文件，该类型额外包括MInix可执行文件头部，结构如下 struct exec { unsigned char a_magic[2]; //执行文件魔数 unsigned char a_flag","date":"2021-05-11","objectID":"/oslab1/:1:0","tags":["操作系统"],"title":"操作系统的引导","uri":"/oslab1/"},{"categories":["操作系统"],"content":"task 2 首先输出字符串 我们直接将bootsect.s的代码复制过来，因为现在两者功能都是输出字符串。 但我们需要进行一些更改 entry _start _start: ！获得光标位置 mov ah,#0x03 xor bh,bh int 0x10 ！0x10中断的0x03功能是读取光标位置（百度该中断的功能） ！对输出信息的操作 mov cx,#28 #要显示字符串的长度 mov bx,#0x000c #显示字符串的颜色（这为红色 mov bp,#msg2 !(更改为msg2) #向该寄存器读入msg2，向屏幕写入该字符串 ！这个时候要修改es的值，用了cs的值。 mov ax,cs mov es,ax ！es：bp是显示字符串的地址 mov ax,#0x1301 ！向屏幕写字符串并移动光标到末尾。如果写0x1300，你会发现光标返回到了起始位置 int 0x10 ！和上一条指令相关，#0x1301是调用0x10中断的13号功能中的1号子功能 inf_loop: jmp inf_loop ！死循环让界面保持 msg1: .byte 13,10 ！回车换行 .ascii \"OK we are in SETUP now\" .byte 13,10,13,10 ！回车换行回车换行 .org 510 ！之后的语句从510地址开始 boot_flag: .word 0xAA55 ！磁盘引导标志0xAA55。引导扇区的最后两个字节，用来识别引导扇区 上面是setup.s文件的内容， 此时我们还需要更改bootsect.s的内容让其能载入setup.s文件 我们需要确定setup所占用的扇区，bootsect.s只占用一个扇区，setup.s从下一个扇区开始，我们定义其占用两个（Linux0.11占用4个）。源码会将bootsect移动到0x9000处，此处我们不移动，所以bootsect.s在内存的0x7c00的位置，占512个字节，那么setup就载入0x7e00处，因为是实模式，所以逻辑地址应该为0x07e0. bootsect.s代码如下 SETUPLEN=2 SETUPSEG=0x07e0 ！setup载入地址 entry _start _start: mov ah,#0x03 xor bh,bh int 0x10 mov cx,#33 mov bx,#0x000","date":"2021-05-11","objectID":"/oslab1/:2:0","tags":["操作系统"],"title":"操作系统的引导","uri":"/oslab1/"},{"categories":["操作系统"],"content":"task 3 接着在完善setup.s文件让其还能再输出光标位置，内存大小和磁盘参数的信息 我们将这些信息载入内存0x9000的位置 INITSEG = 0x9000 entry _start _start: ! print string mov ah,#0x03 ! cursor pos get xor bh,bh int 0x10 mov cx,#28 mov bx,#0x000c ！字符颜色 mov bp,#msg2 mov ax,cs mov es,ax ！修改es的值为cs mov ax,#0x1301 int 0x10 mov ax,cs mov es,ax !init ss:sp 初始化栈 mov ax,#INITSEG mov ss,ax ！栈指向0x9000 mov sp,#0xFF00 ！设置512B偏移地址，arbitrary value\u003e\u003e512，因为刚开始后面的内存空间都没被使用（这啥解释嘛） !cursor info mov ax,#INITSEG mov ds,ax ！ds寄存器指向0x9000，下面开始让各数据载入0x9000位置 mov ah,#0x03 xor bh,bh int 0x10 ！获取光标位置信息 mov [0],dx ！[0]从0x9000开始，将获取的数据放入这个内存地址 !memory info mov ah,#0x88 int 0x15 ！通过0x15中断得到memory大小信息 mov [2],ax ！存入0x9002位置 ! disk parameter 磁盘参数表 mov ax,#0x0000 mov ds,ax ！将数据段移动到0x0000，也是ram开始的位置，这个地方（0-1024）的位置存放中断向量表。在41号中断处读取第一个磁盘的参数。（不懂，不知道对不对。0x0000之前不是磁盘的地址吗）！！该问题已解决，在后面会独立说明。 ！乘4是因为中断向量表每个表项占4B，那么41号中断的入口地址自然为4*0x41 ！乘4就是将0x41左移两位，lds有两步操作：si\u003c-4*0x41,ds\u003c-[4*0x41+2]，中断向量表存储的只是相应中断号中断服务程序的入口地址。 ！其构造是4个字节单元，第2字节位偏移量ip，高两字节为服务程序段地址，所以ds是中断服务程序段地址，si为中断服务程序偏移。因此可以执","date":"2021-05-11","objectID":"/oslab1/:3:0","tags":["操作系统"],"title":"操作系统的引导","uri":"/oslab1/"},{"categories":null,"content":"INT80, 电子科技大学信通学院本科生 ​ 正努力自学成为一位白帽子 ","date":"0001-01-01","objectID":"/aboutme/:0:0","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":["逆向"],"content":"0x0 前言 既然前面我们都写了DLL注入工具，那当然得接着学习Hook技术了啊。使用我们写的DLL注入工具，在目标DLL里写上Hook代码，如此就能将DLL注入技术与Hook技术结合进行联合使用。 因为HOOK技术是有针对性的，因此该项目以MessageBox函数为例进行编写，项目中需要更改的地方都放在一起并且已经进行标注，当使用的时候可以按照标注更改为目标HOOK函数的信息即可。 代码中的标注如图1所示: 图1.代码标注示例 此项目一共实现了七种HOOK技术，如图2所示： 图2.Hook技术实现列表 该博客也就围绕这7种HOOK技术进行解析，其中HookTest 与 VirtualTableHookTest分别为测试用的Hook的目标程序以及测试用的虚表Hook的目标程序。 该项目参考《加密与解密》Hook技术章节代码而完成 项目地址: HookTechniques 0x1 一些需要的概念 首先是通用的Hook流程，示意图如图3: 图3.通用Hook流程 从示意图我们可以很明确的得到一个信息，HOOK就是插入特定代码以干预程序的执行流程。在程序执行真正的目标函数前，先执行我们的代码，这样就获得了程序执行过程的决定权，这也就是HOOK的目的所在。 图中的Detour(翻译为绕道)函数，就是我们插入用来干预原执行流程的代码。Trampoline(翻译为跳板)函数，作用是还原并执行因跳转去执行Detour函数导致目标函数中没有被执行的指令，这样可以最大程度避免程序执行出错。 HOOK技术共可分为3类，第一类为 Address Hook，该类方法是通过修改数据进行Hook，但修改的数据多为函数的地址或其偏移量。当函数被调用时，函数的地址就会被保存在RIP寄存器中，因此我们将这些地址替换成Detour函数地址即可获得程序控制权。 第二类为InlineHook，该类方法是直接修改指令进行Hook，核心为通过jmp，call，ret之类的指令转移程序的执行流程，从而实现执行Detour函数获得程序控制权。 第三类为基于异常处理机制的Hook，该类方法是将Detour函数向目标进程注册为异常处理程序，然后手动触发异常或中断，让程序跳转至异常处理程序，这样也能让程序执行到Detour函数并获得程序控制权。 0x2 Address Hook 0x2.1 IAT Hook 在PE文件","date":"0001-01-01","objectID":"/apihook/:0:0","tags":["逆向"],"title":"常用Hook技术解析","uri":"/apihook/"}]