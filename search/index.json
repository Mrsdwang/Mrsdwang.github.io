[{"categories":["博客"],"contents":"现在博客根目录打开git bash\ngit add . # 添加目录下全部内容\ngit commit -m \u0026ldquo;new blog\u0026rdquo; # 提交说明，出问题了可以回退到之前的\ncommit git push -u origin main # 将本地内容推送到远程\n","permalink":"http://Mrsdwang.github.io/test/","tags":["博客"],"title":"博客更新步骤"},{"categories":["逆向"],"contents":"第五题：\n**任务：**找到FLAG，也就是APP正确的账号密码\n步骤：\n先打开APP看看运行出现的东西，\n将apk用jadx打开，并查看com.example.test.MainActivity的代码\n其中可以发现关键的函数，即Encrypt.b ，Encrypt.a，getBytes\n后面的if中调用equals函数可知，该代码的作用就是对输入的账号密码通过Encrypt类的a和b函数进行加密，然后与正确的加密后的账号密码比对是否相等。\n那么只需要将bArr以及第一个equals中new byte[]的字节数组进行解码即可。\n首先查看Encrypt类\n加密的方法很简单，先将输入的账号密码和 i 进行异或，在调用Base64的库函数进行Base64编码。\n那么获得正确的账号密码的方法就很明显了，直接将程序中列出来的两个字节数组先进行Base64的解码，在和 相同的 i 进行异或即可。\n这里通过java来进行解密，还需了解一下 Base64库的decode函数的使用，就是喂一个字节数字数组，通过Base64加密返回一个 字节字符数组。\nJAVA解密代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package com.example.helloworld; import java.util.Base64; public class HelloWorld { public static void main(String[] args) { Base64.Decoder decoder = Base64.getDecoder(); byte[] data = {78, 106, 73, 49, 79, 122, 65, 51, 89, 71, 65, 117, 78, 106, 78, 109, 78, 122, 99, 55, 89, 109, 85, 61}; byte[] data1 = {89, 87, 66, 108, 79, 109, 90, 110, 78, 106, 65, 117, 79, 109, 74, 109, 78, 122, 65, 120, 79, 50, 89, 61}; byte[]bArr = decoder.decode(data); byte[]bArr1 = decoder.decode(data1); System.out.println(); int length = bArr.length; for (int i2 = 0; i2 \u0026lt; length; i2++) { bArr[i2] = (byte) (bArr[i2] ^ 3); bArr1[i2] = (byte) (bArr1[i2] ^ 3); } String res = new String(bArr); String res1 = new String(bArr1); System.out.println(res); System.out.println(res1); } }   程序输出得到：\n1 2  516834cc-50e448af bcf9ed53-9ae4328e   提交FLAG时需合并成：\n1  516834cc-50e448af-bcf9ed53-9ae4328e   第六题：\n一开始看到第六题的网址和第五题一样，还以为是网址放错了，但是几天后还没有更新，于是就考虑到是不是第六题的flag也在第五题给的APP中，于是反编译该app，得到的lib文件中存在libMylib.so文件，于是推测第六题flag在so文件里。\n我一开始打算用IDA动态调试so文件，但是一attach进程，APP就会直接关闭，我怀疑APP用了什么反调试方法，于是直接IDA打开so文件，查看是否有相关的反调试代码，结果并没有发现，反而发现了关键的产生flag的代码。\n用IDA打开libMylib.so文件，并查看EXPORTS窗口，导出的函数如下：\n双击JNI_Onload，并且翻到最顶，查看如下注释：\n查看标黑的，可以看到该so文件依赖了以上几个so库，并且这个so文件的名字为libMylib.so。我们需要注意libc.so这个依赖库，因为关键的函数从这个库里调用的。\n再次回到JNI_OnLoad函数处，将汇编转为C语言，如下：\n可以看到，该函数注册了MainActivity，并且在下面调用了一个all的函数，双击进去，会发现还有一个all函数被调用，再次进入，我们就能得到如下代码(只截图关键部分)\n第一个if，判断条件虽是数字，但其实是ASCII码，其意思就是判断abi是否是’x86‘，release-version是否为’9‘，接着打开了/data/2233文件，并且后面需要a+的权限，结合后面的fput，应该是要把一些数据写入该文件，那么还需要再/data处创建2233文件，此处需要root才能访问，也需要APP获得root权限才能写入。\n那么关键的就是如何绕过第一个if了，v16，v17的值为__system_property_get函数的返回值，因此我们需要对该函数进行hook，更改其返回值即可。\n因为hook需要知道该函数所在so文件，我们查看IMPORT窗口\n可以看到__system_property_get是从libc.so导入的。\n那么接下来用frida进行hook注入，注入代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  function main() { Java.perform(function(){ var str; var arg; //findExportByName是获得__system_property_get函数再libc.so中的地址  Interceptor.attach(Module.findExportByName(\u0026#34;libc.so\u0026#34;, \u0026#34;__system_property_get\u0026#34;), { onEnter: function (args) { //此处的args为函数调用时传入的参数  str = Memory.readCString(args[0]); //获得abi或version  arg = args[1]; //保存返回值的变量  if(str.indexOf(\u0026#39;ro.product.cpu.abi\u0026#39;)!=-1||str.indexOf(\u0026#39;ro.build.version.release\u0026#39;)!=-1){ //如果有这两个字符串  console.log(\u0026#34;now hook \u0026#34;+str) } }, onLeave: function (retval) { if(str.indexOf(\u0026#39;ro.product.cpu.abi\u0026#39;)!=-1){ var old_abi = Memory.readCString(arg); Memory.writeUtf8String(arg, \u0026#34;x86\u0026#34;); //直接向内存地址写入x86  var new_abi = Memory.readCString(arg); console.log(\u0026#39;old_abi is:\u0026#39;,old_abi,\u0026#39;new_abi is:\u0026#39;,new_abi); }else if(str.indexOf(\u0026#39;ro.build.version.release\u0026#39;)!=-1){ var old_ver = Memory.readCString(arg); Memory.writeUtf8String(arg, \u0026#34;9\u0026#34;); //直接向内存地址写入9  var new_ver = Memory.readCString(arg); console.log(\u0026#39;old_ver is:\u0026#39;,old_ver,\u0026#39;new_ver is:\u0026#39;,new_ver); } } }); }); } setImmediate(main);   打开APP，然后在命令行执行\n1  frida -U --no-pause -f com.example.test -l hook.js   frida运行后得到如下结果：\n检验是否hook成功，打开2233文件查看，结果如下：\n总共16行，那么根据第五题的结果，可以推测出flag为4行一组，’-‘隔开，结果为：\n1  b13981f4-5ae996d4-bc04be5b-34662a78   ","permalink":"http://Mrsdwang.github.io/bili1024_21/","tags":["逆向"],"title":"B站1024逆向题"},{"categories":["Fuzz"],"contents":"任务：给AFL添加socket发包功能，使其支持测试DNS协议\n参考代码：\n因为不太方便直接贴出源码，所以就说明一下思路，记录一些实现 时遇到的错误。\n主要的问题有：\n 写了发包的函数，需要在哪里调用？ 如何解决超时的问题？如何及时杀死子进程？ 如何配置dnsmasq？？？？？？？？？（弄这玩意给我重装系统了）  需要了解的知识点：\n AFL大概的执行流程 AFL的从哪里获得输入文件 AFLmain函数的死循环在执行什么 target如何获取输入文件 fuzz dns的结果afl是通过什么 途径获取的 管道的概念  afl的main函数大概执行流程：\n通过read_testcases从输入文件夹读取所有文件，然后进行排队进行测试，然后调用add_to_queue函数创建queue_entry结构体作为输入文件队列，通过perform_dry_run函数第一次运行测试样例。进入死循环就循环将输入队列当前的输入文件丢入fuzz_one函数处理，该处理就是将种子变异并添加到输入队列里去。\nrun_target函数就是fork出一个子进程(fuzz的目标程序)进行fuzz。那么socket发包函数的调用就需要在这个位置。run_target函数被调用的地方存在于main函数死循环中的多个函数中，有calibrate_case函数等。\nsocket发包函数就在定时器设定好后面加即可。原因会在后面信号处理相关解释。\n既然要通过socket发送输入文件，那么从哪里获取输入文件呢？\nwrite_to_testcases函数就是用来写入到输入文件中的，该函数的参数为void *mem 和 u32 len，那么就定义两个个全局变量用来获取mem和len来给socket发送即可。\nsocket发包函数就是普通的socket client的代码，要注意的就是发送了输入文件后，就应该终止该子进程了，那么如何关闭呢？\n下面是对信号及信号量处理的解释（这是避免超时的解决办法）\nSIGTERM：\n程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和处理，通常用来要求程序自己正常退出。\n下面这段程序是在socket发包程序当中的。是在关闭了socket后，才运行来结束子进程的。\n第一个if用来判断子进程是否还存在，存在则通过kill函数传递SIGTERM信号告诉进程运行完了就快结束。\nwhile（1）作用是用来检验子进程是否还在运行，kill函数的第二个参数为0时，说明没有任何信号发送出去，但是系统会执行错误检查，通常利用第二个参数为0来检验某个进程是否在执行.当kill错误执行就会返回-1，并且errno会被赋值为ESRCH，即目标进程或进程组不存在。\n所以当发包，关闭socket后，执行该终止子进程的语句才能避免超时，才能在第一次perform_dry_run顺利通过。\n问题：但是如果没能杀死子程序不久进入死循环了吗？\n答：这就是后面设置定时器的原因，SIGTERM不一定能杀死程序，所以设置定时器来SIGKILL 子进程\n为什么send_over_network 要放在runtarget 设置好定时器后。\n因为AFL中定义了进程接收到信号SIGALRM后会执行的函数为\n即超时后会给子进程发送SIGKILL信号进行终止运行。而send_over_network 发包目标是子进程(target)，因此需要先设置好定时器，在子进程创建和运行超时时能及时kill掉避免过长时间的运行影响整体FUZZ的速度\n在run_target中还添加了第二个if，获取子进程终止的信号，因为我们在send_over_network中添加了kill 子进程的信号为SIGTERM 所以加入了这一句 FAULT_NONE，否则他将会直接返回FAULT_CRASH会产生错误的结果\n该次任务 只是实现了TCP的socket发包，那如果添加TCP和UDP的两种选项呢。\n有一种思路就是通过getopt添加命令行选项，并在case中添加相应的执行语句即可。例如输入参数为TCP:127.0.0.1，那么添加命令行选项-N ，那么命令行输入-N TCP:127.0.0.1 在case执行自己的拆解字符串的函数即可。socket发包的代码段添加if进行分支执行即可。\n最后结果：\n","permalink":"http://Mrsdwang.github.io/afl%E6%B7%BB%E5%8A%A0socket%E5%8F%91%E5%8C%85%E5%8A%9F%E8%83%BD/","tags":["Fuzz"],"title":"AFL添加socket发包功能"},{"categories":["操作系统"],"contents":"lab3 一、任务内容  基于模板process.c编写多进程的样本程序，实现以下功能：  所有子进程都并行运行，每个子进程实际的运行时间不超过30秒 父进程向标准输出打印所有子进程的id，并且在所有子进程退出后才退出   实现进程运行轨迹的跟踪。在内核中维护一个日志文件process.log，把从操作系统启动到系统关机过程中所有进程的运行轨迹都记录在这一log文件中 统计log文件记录该程序建立的所有进程的等待时间，完成时间(轮转时间)和运行时间，计算平均等待时间，平均完成时间，和吞吐量。 修改进程调度的时间片，运行同样的样本程序统计同样的时间数据，和原有的情况对比，体会时间片带来的差异  二、明确进程的概念以及其生命周期内运行过程 那么何为进程呢？\n操作系统为正在运行的程序提供的抽象，就是进程，是操作系统提供的基本抽象\n非正式定义可以定义为，正在运行的程序。但程序本身是没有生命周期的，他只是存在磁盘上的一些指令或者静态数据，是操作系统让这些字节运行起来，让程序发挥作用。\n我们通过清点一个运行的程序在执行过程中访问或影响的系统的不同部分，从而概括一个进程。\n这里引入一个新的概念，进程的机器状态(machine state)：程序运行时可以读取或更新的内容。\n因此我们要关注，任何时刻下，机器哪些部分对执行该程序很重要。\n我们知道存放在内存的程序才能被运行，因此组成机器状态的重要的部分就是内存。指令存放在内存中，正在运行的程序读取和写入的数据也存在内存中，因此进程能访问的内存就是该进程的一部分。\n进程的机器状态另一部分就是寄存器。因为很多指令都是明确的读取或更新寄存器，所以寄存器对程序的执行很重要。\n进程创建的一些细节：\n操作系统运行程序第一件事就是讲代码和所有静态数据加载到内存中，加载到进程的地址空间中。\n早期操作系统中，加载这个过程需要尽早完成，即在运行程序之前全部完成。\n但随着现在程序越来越大，内存根本不可能一次性存放如此大的程序。你看现在的游戏都是10G以上，而我们的内存可能是8G,16G等，所以大多时候内存的大小无法载入整个程序。\n因此，现代操作系统惰性地(lazily)执行该过程，也就是仅在程序执行期间需要加载的代码或数据片段，才会加载到内存当中。换句话说我用谁我让谁进入内存，当内存满了之后我根据我的调度策略，将该换出去片段换出去，再把要用的片段加载进来。(这部分需要了解分页和交换的机制)\n当我们把程序载入到内存后，操作系统还会自动为程序分配运行时栈(run-time stack or stack)\n操作系统也可能会为程序的堆分配内存，这需要用户主动的显式的申请，例如malloc()这样的调用来申请空间，再通过free()释放内存。\n在UNIX系统中，每个程序都会有三个文件描述符，分别是标准输入stdin，标准输出stdout，标准错误stderr。所以操作系统还会初始化一些其他的任务，例如I/O相关的任务。\n完成上述任务后，PC指针就指向程序main函数入口地址，开始执行程序。\n总结就是：操作系统要执行一个程序，首先将代码和静态数据载入内存，通过创建和初始化栈及执行与I/O设置相关的其他工作，最后OS开始执行程序入口函数。\n我们这里简单提一下 堆和栈的区别：\n我接触到栈和堆的时候，是学习数据结构的时候，当时对堆的说明只是能够自动排序的一种数据结构。与数据结构不同，这里的堆分配方式类似于链表，因此获得的地址空间可以不连续\n在内存当中，\n栈是由系统自动分配自动释放(出栈时)，且地址空间连续。用于存放函数的参数值，局部变量的值。因为是机器自动执行，且是系统提供的数据结构，机器语言层有专门的执行指令，所以栈的执行效率更高于栈。其地址增长方向是，高地址向低地址增长\n堆一般由程序员分配释放，因此我们能申请任意多少的内存(受限于计算机系统中的虚拟内存)，动态内存的生存期也是由程序员自己决定的。如果在堆上分配的了内存地址就必须释放它，否则会导致运行的程序出现内存泄漏的情况。其地址增长的方向从下往上，即低地址向高地址增长。\n我们知道进程是不断切换着运行的，但是我们的内存和寄存器只能留给需要执行的程序，当我们切换进程的时候自然就会需要保存\u0026quot;现场\u0026quot;，那么当我们再次切换回来的时候才能让程序继续以切换之前的状态运行。所以操作系统充满了各种数据结构用来处理各种情况，在我们讨论的这个情况，操作系统就有一个称为进程控制块PCB(Process Control Block)的数据结构，用来存储关于进程的信息的个体结构。\n对于停止的进程，寄存器上下文(寄存器取值所基于的语境)将保存其寄存器的内容。所以当进程停止时，寄存器将被保存到这个内存位置。这句话可能说的不是特别清楚。\n当程序挂起的时候，我们观察的寄存器都是存放在内存中的寄存器的值，而不是物理寄存器当前的值，当我们修改寄存器的时候也是修改内存中的寄存器值。\n当线程切换时，系统会将要挂起线程的寄存器值保存到内存中，这个记录就被称为线程上下文，寄存器上下文即线程上下文的一部分。将现成的寄存器存放在内存中，称为上下文记录\n根据PCB记录\u0026quot;现场\u0026quot;，我们就能还原\u0026quot;现场\u0026quot;，实现进程的切换。\n至此，进程的一些基本内容就概述完成，那么我们该来想想如何才能创建多进程呢？\n我们需要调用fork()系统调用来创建子进程。这里对fork()进行一些概述\nfork()创建一个进程，该进程称为子进程，原进程称为父进程。当我们执行该调用，系统会分配出新的内存空间，并将父进程的所有值都复制给子进程，只有少量的值于原来的进程的值不同，以区分两个为不同的进程。我们可以理解是一个克隆。（这里提一点，如果我们不更改子进程的优先级，那他将和父进程的相同，我们也是通过父进程的优先级的值来赋值给子进程的时间片。）\n我们写的process.c代码，计划在里面创建4个进程，那你可能会想，哎？我创建了4个子进程，他们会执行什么程序？和父进程相同，所以他们也在执行父进程的程序吗？\n对的，子进程会从调用fork()的位置开始继续往下执行。也就相当于fork()只会拷贝下一段要执行的代码到子进程中。\n这里需要说一下fork()的特别的机制。\nfork()调用一次，并成功创建新进程，它能返回两个值，失败则返回一个负值(-1吧，不过这个暂时不重要)\n那么这两个值分别是什么呢？在父进程中，fork返回新创建子进程的进程ID，在子进程中，fork返回0.你可以这么理解，父子进程是一棵多叉树(只有一个子进程可理解成一串链表），父进程指向子进程的id，而子进程指没有指向则为0.\n所以我们会看到这样的判断\n1 2 3 4 5 6 7 8  pid_t pid; pid = fork(); if(pid!=0){ printf(\u0026#34;I am parent %d\u0026#34;,getppid()); } else if(pid==0){ printf(\u0026#34;I am child %d of parent %d\u0026#34;,getpid(),getppid()); }   然后屏幕两个输出都出现了，这里不用疑惑，我们还在执行另一个进程来跑相同的程序呢，父进程得到的是0，所以进入了第二个if，子进程得到的是他的进程id进入了第一个if，所以我们能看到两个输出都出现了。\n那么多进程创建就解决了，我们再来想想如何让父进程等待子进程全部结束后再结束呢？\n在这之前，我们需要知道为什么父进程会需要等待子进程结束再结束(当然，在这我们是想要他这么做，但也有值得这么做的理由)\n我们使用wait()系统调用，让父进程立即进入阻塞状态，然后wait()自动分析当前进程的某个子进程是否已经运行完成，当wait找到这样的僵尸子进程后，wait就会收集子进程的信息(例如退出原因)和回收子进程残留资源，并将该子进程彻底销毁后返回该进程的进程id。当wait一旦被调用，就会一直阻塞，直到有一个子进程退出为止\n何为僵尸子进程？\n当一个进程运行结束后，会关闭所有文件描述符，释放在用户空间分配的内存，但进程留在PCB的信息没有被同步删除。而执行完却没从PCB中删去进程信息的子进程称为僵尸子进程.\n那么为什么要删除僵尸进程呢？僵尸进程明明不做任何事，不会使用任何资源也不会影响其他进程了啊，为什么还要去管他呢。但PCB内的信息也都是存放在内存中的，如果存在太多僵尸进程也会导致一些问题。你可以想象一个工厂里面，有一些人啥也不做，你也不用支付工资，但人数多了后，仍让会导致你的工厂变得拥挤从而导致其他的人难以正常工作。\n所以回到原来的问题，我们通过wait()让父进程阻塞，等待全部子程序结束后再结束父进程。\n以上，我们创建多进程的程序就已经有了整体的框架和思路了。\n我们现在要考虑，如何创建一个日志呢？如何让他从操作系统启动后就跟着启动并开始记录进程的活动轨迹呢？\n容易想到，那我们在操作系统开机的时候就打开日志文件不就行了吗？对，确实是这样做，但问题在于要如何处理？\nLinux中，一切都能抽象为文件，那么对于一个打开的文件，我程序应该如何找到呢？完成这功能的便是通过文件描述符，所以我们要打开日志文件就需要关联文件描述符。我们知道，在Linux中文件描述符0、1、2分别关联了标准输入stdin、标准输出stdout和标准错误stderr，因此我们将文件描述符3关联到process.log日志文件即可。有一点需要注意，因为我们要今早打开日志文件记录所有进程的运行轨迹，我们需要将关联的代码提前到进程0运行还没创建进程1的时候就完成，这部分会在实践部分详细展开说。\n那么接下来就是我们要在什么地方加入写入日志文件的代码了。\n我们要清楚，进程，它能处于几种状态？可以认为其有三种状态\n运行：进程正在处理器上运行，进程在执行指令\n就绪：进程已经准备好运行，但操作系统因为一些原因并不打算在此时运行\n阻塞：一个进程执行了某种操作，知道发生其他事件时才会准备运行。例如一个进程需要操作IO设备时候，该进程就会进入阻塞状态，因为I/O设备反应时间远慢于CPU运行的速度，所以此时进程阻塞放出CPU的操作权，从而提高CPU的利用率\n但我们在这里再加上两个状态：创建和退出\n我们用如下字母进行替代：新建(N),就绪(J),运行(R),阻塞(W),退出(E)\n最后我们就要考虑，再哪些位置进行进程的监测，并把检测信息输入到日志文件中。\n因为fork()系统调用后，进入内核，所以进程的轨迹的监测，我们需要在内核中完成，那么write()这个系统调用我们就没办法使用了，所以写数据进文件的函数，我们需要解决。因为这部分编程较为困难，就直接使用现成的代码。\n我们将重点放在在哪里进行进程轨迹监测。\n对于创建(N)，我们需要找到创建进程的函数copy_process()，其位于fork.c内核文件中，并在创建的时候将信息写入日志文件\n对于运行(R)，就绪(J)，阻塞(W)，我们需要考虑在涉及到调度策略的代码中进行，即内核文件中的sched.c\n退出(E)就考虑再内核文件中的exit.c文件中这种状态才会出现。\n三、实践部分 (代码是自己再打一遍的，可能会有一些人为错误，有的话还希望指出)\n首先先编写能生成多进程的程序process.c\n该程序包含两个部分，第一个部分是多进程创建的代码，第二部分是获取该进程使用CPU的时间以及模拟I/O操作的代码\n下面这段是第二部分代码：\n先放出第二部分代码是因为，第一部分的代码需要用到第二部分的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  /* * 此函数按照参数占用CPU和I/O时间 * last: 函数实际占用CPU和I/O的总时间，不含在就绪队列中的时间，\u0026gt;=0是必须的 * cpu_time: 一次连续占用CPU的时间，\u0026gt;=0是必须的 * io_time: 一次I/O消耗的时间，\u0026gt;=0是必须的 * 如果last \u0026gt; cpu_time + io_time，则往复多次占用CPU和I/O * 所有时间的单位为秒 */ void cpuio_bound(int last, int cpu_time, int io_time) { struct tms start_time, current_time; clock_t utime, stime; int sleep_time; while (last \u0026gt; 0) { /* CPU Burst ，指CPU执行指令的那一段时间区间*/ times(\u0026amp;start_time); /* 其实只有t.tms_utime才是真正的CPU时间。但我们是在模拟一个 * 只在用户状态运行的CPU大户，就像“for(;;);”。所以把t.tms_stime * 加上很合理。*/ /*用来模拟cpu_time时间内使用CPU */ do { times(\u0026amp;current_time); utime = current_time.tms_utime - start_time.tms_utime; stime = current_time.tms_stime - start_time.tms_stime; } while ( ( (utime + stime) / HZ ) \u0026lt; cpu_time ); last -= cpu_time; if (last \u0026lt;= 0 ) break; /* IO Burst ，指I/O设备被请求执行开始到执行结束的时间区间*/ /* 用sleep(1)模拟1秒钟的I/O操作 */ sleep_time=0; while (sleep_time \u0026lt; io_time) { sleep(1); sleep_time++; } last -= sleep_time; } }   cpuio_bound(10,1,1)意思为该进程，轮转一次使用CPU时间为1s，I/O设备占用时间1s，占用CPU和I/O时间总共为10秒\n下面是第一部分代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;time.h\u0026gt;#include \u0026lt;sys/times.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt; #define HZ\t100 #define CHILD_PROCESS_NUM 4 #define CHILD_RUN_TIME 30  void cpuio_bound(int last, int cpu_time, int io_time); /* 1. 所有子进程都并行运行,每个子进程的实际运行时间一般不超过30秒; 2. 父进程向标准输出打印所有子进程的id,并在所有子进程都退出后才退出; */ int main(int argc, char * argv[]) { pid_t pid; /*子进程 PID*/ int i=0; while(i\u0026lt;CHILD_PROCESS_NUM) { /*子进程*/ if((pid=fork())\u0026lt;0) /*fork 失败*/ { fprintf(stderr,\u0026#34;error in fork()\\n\u0026#34;); return -1; } /*成功创建子程序，子程序将执行下面的代码*/ else if(pid==0) { fprintf(stdout,\u0026#34;create new process [%lu]\\n\u0026#34;,(long)(pid)); cpuio_bound(CHILD_RUN_TIME,1,i);/*用i是为了不断改变I/O使用时间*/ exit(0); /*退出子程序*/ } /*父进程执行下面代码*/ else { fprintf(stdout,\u0026#34;child pid is [%d] and parent pid is [%d]\\n\u0026#34;,getpid(),getppid()); i++; } /*父进程继续循环fork*/ } /*等待所有子进程完成*/ /*因为当一个子进程结束后就会返回他的id，如果没有子进程就会返回-1，所以当要等待多个进程结束，就需要while((pid=wait(NULL))！=-1)，这样当所有子进程结束后，父进程才会结束运行 */ while((pid=wait(NULL)) != -1) { fprintf(stdout,\u0026#34;process [%lu] terminated\\n\u0026#34;,(long)(pid)); } return 0; }   那么我们创建多进程的程序完成，现在要考虑创建日志文件process.log。\n首先我们日志放在/var/process.log，作用使在每个进程发生状态切换的时候向log文件内写入一条记录，但因为在内核态写入，这个过程和用户态应用程序在一些细节上差别就很大。\n首先是打开log文件，我们是要让操作系统第一次调用fork()建立进程1的时候就开始记录了，那么我们log要在这之前打开才能记录进程1的信息。\n我们先查看操作系统第一次fork()的代码，内核入口为init/main.c 中的main()，里面有一段代码\n1 2 3 4 5 6  //... move_to_user_mode(); /*切换到用户模式*/ if(!fork()){ /* we count on this going ok */ init(); } //...   这段代码是在进程0运行的，首先要切换到用户模式，才全系统第一次调用fork()建立进程1，进程1调用init()函数，我们进入init()中查看\n1 2 3 4 5 6 7 8 9  //... /*加载文件系统 */ setup((void *) \u0026amp;drive_info); /*打开/dev/tty0，建立文件描述符0并和/dev/tty0相关联 */ (void) open(\u0026#34;/dev/tty0\u0026#34;,O_RDWR,0); /*让文件描述符1也和/dev/tty0关联*/ (void) dup(0); /*让文件描述符2也和/dev/tty0关联*/ (void) dup(0);   dup(oldfd)用来复制参数oldfd所指的文件描述符。当复制成功时，返回最小的尚未使用的文件描述符，若有错误就返回-1，错误代码存入errno中。返回的新文件描述符和参数oldfd指向同一个文件，这两个描述符共享同一个数据结构，共享所有的锁定，读写指针和各标志位。\n我们前面说过文件描述符分别代表了什么，这就不赘述。那么就应该紧接着建立文件描述符3和process.log日志文件相关联\n建立方式同tty0文件\n1 2  /*O_CREAT如果文件不存在就创建，并使用参数3设置权限；O_TRUNC若文件存在则清除文件内容并设置文件大小为0;O_WRONLY以只写方式打开文件；0666就是文件操作的权限值，和第二个参数有关*/ (void) open(\u0026#34;/var/process.log\u0026#34;,O_CREAT|O_TRUNC|O_WRONLY,0666);   我们知道init()函数是在fork()后才进行，为了能记录进程1，我们需要将文件描述符关联文件的这步放到fork()前面，但必须在move_to_user_mode();后，因为必须先移动到用户模式，才能加载文件系统，因此需要在这之后添加代码，不能再在前面添加了。因此更改后如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //... move_to_user_mode(); /*切换到用户模式*/ //... /*加载文件系统 */ setup((void *) \u0026amp;drive_info); /*打开/dev/tty0，建立文件描述符0并和/dev/tty0相关联 */ (void) open(\u0026#34;/dev/tty0\u0026#34;,O_RDWR,0); /*让文件描述符1也和/dev/tty0关联*/ (void) dup(0); /*让文件描述符2也和/dev/tty0关联*/ (void) dup(0); (void) open(\u0026#34;/var/process.log\u0026#34;,O_CREAT|O_TRUNC|O_WRONLY,0666) if(!fork()){ /* we count on this going ok */ init(); } //...   还要记得把init的这部分给注释掉，因为进程1继承了进程0这个父进程的绝大部分东西，所以进程1也会继承这些文件描述符.\n那么日志文件就能在全系统第一次调用fork()之前创建了，因此能监测各进程的各种状态变化了\n日志文件建立了，那是不是该考虑如何写入log文件了呢？之前说过我们在内核中切换进程，导致进程状态改变，也就是说所有的状态转移是在内核进行的，那么我们也得在内核向日志文件写入这些改变信息，但是我们在内核没有办法使用write()这个系统调用，所以我们要考虑自己写一个写入函数，就像printf()在内核中有个printk()来替代它的功能，我们就要写一个在内核使用的write()。\n因为内核函数的编写涉及到C内嵌汇编，编写难度较大，因此我们直接套用现成的代码，主要是参考printk()和sys_write()写出来的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  #include \u0026#34;linux/sched.h\u0026#34;#include \u0026#34;sys/stat.h\u0026#34; static char logbuf[1024]; int fprintk(int fd, const char *fmt, ...) { va_list args; int count; struct file * file; struct m_inode * inode; va_start(args, fmt); count=vsprintf(logbuf, fmt, args); va_end(args); /* 如果输出到stdout或stderr，直接调用sys_write即可 */ if (fd \u0026lt; 3) { __asm__(\u0026#34;push %%fs\\n\\t\u0026#34; \u0026#34;push %%ds\\n\\t\u0026#34; \u0026#34;pop %%fs\\n\\t\u0026#34; \u0026#34;pushl %0\\n\\t\u0026#34; /* 注意对于Windows环境来说，是_logbuf,下同 */ \u0026#34;pushl $logbuf\\n\\t\u0026#34; \u0026#34;pushl %1\\n\\t\u0026#34; /* 注意对于Windows环境来说，是_sys_write,下同 */ \u0026#34;call sys_write\\n\\t\u0026#34; \u0026#34;addl $8,%%esp\\n\\t\u0026#34; \u0026#34;popl %0\\n\\t\u0026#34; \u0026#34;pop %%fs\u0026#34; ::\u0026#34;r\u0026#34; (count),\u0026#34;r\u0026#34; (fd):\u0026#34;ax\u0026#34;,\u0026#34;cx\u0026#34;,\u0026#34;dx\u0026#34;); } else /* 假定\u0026gt;=3的描述符都与文件关联。事实上，还存在很多其它情况，这里并没有考虑。*/ { /* 从进程0的文件描述符表中得到文件句柄 */ if (!(file=task[0]-\u0026gt;filp[fd])) return 0; inode=file-\u0026gt;f_inode; __asm__(\u0026#34;push %%fs\\n\\t\u0026#34; \u0026#34;push %%ds\\n\\t\u0026#34; \u0026#34;pop %%fs\\n\\t\u0026#34; \u0026#34;pushl %0\\n\\t\u0026#34; \u0026#34;pushl $logbuf\\n\\t\u0026#34; \u0026#34;pushl %1\\n\\t\u0026#34; \u0026#34;pushl %2\\n\\t\u0026#34; \u0026#34;call file_write\\n\\t\u0026#34; \u0026#34;addl $12,%%esp\\n\\t\u0026#34; \u0026#34;popl %0\\n\\t\u0026#34; \u0026#34;pop %%fs\u0026#34; ::\u0026#34;r\u0026#34; (count),\u0026#34;r\u0026#34; (file),\u0026#34;r\u0026#34; (inode):\u0026#34;ax\u0026#34;,\u0026#34;cx\u0026#34;,\u0026#34;dx\u0026#34;); } return count; }   我们将改代码放入kernel/printk.c文件中即可。\nfprintk使用的格式有如下\n1 2 3 4 5  // 向stdout打印正在运行的进程的ID fprintk(1, \u0026#34;The ID of running process is %ld\u0026#34;, current-\u0026gt;pid); // 向log文件输出跟踪进程运行轨迹 fprintk(3, \u0026#34;%ld\\t%c\\t%ld\\n\u0026#34;, current-\u0026gt;pid, \u0026#39;R\u0026#39;, jiffies);   第一个参数为文件描述符，第二个参数作为字符串输出，就和printf使用是一样的，但是前面第一个参数用来指定文件描述符。\n我们还记录了进程切换，状态保持的一些时间，但是时间并不是我们常识的时间，而是以CPU时钟中断发生的次数，称为“滴答数”——jiffies\njiffies是定义在kernel/sched.c文件中定义为一个全局变量,记录了开机到当前时间的时钟中断次数\n1  long volatile jiffies=0;   在sched.c中sched_init()函数中，时钟中断函数被设置为\n1 2 3 4 5 6 7  set_intr_gate(0x20,\u0026amp;timer_interrupt); /*在kernel.system_call.s中timer_interrupt定义有如下和jiffies相关的指令 */ timer_interrupt: ! …… ! 增加jiffies计数值 incl jiffies ! ……   这也是jiffies能表示开机到现在发生的时钟中断次数的原因\n在kernel/sched.c中定义一个宏 LATCH时用来设置每次时钟中断间隔的\n1 2 3 4 5  // 在 kernel/sched.c 中 #define LATCH (1193180/HZ)  // 在 include/linux/sched.h 中 #define HZ 100   这个和计算机的定时芯片时钟频率有关。\n最重要的部分来了，我们如何寻找状态切换点呢？\n我们从每个状态转化的过程入手：\n首先先列出我们需要改动的文件：\nkernel/rork.c中的copy_process函数\nkernel/sched.c的schedule()，wake_up()，sleep_on()，interrupt_sleep_on()，sys_pause()，sys_waitpid()函数\nkernel/exit.c 的 do_exit()函数\n 无-\u0026gt;创建：  既然涉及到创建，那么我们就进入fork()去看，之前做的第二个实验我们知道系统调用里面才调用真正的内核函数，所以fork()里面会有一个sys_fork()来执行真正的系统调用，所以我们在sys_fork()寻找创建进程的函数\n1 2 3 4 5 6 7 8 9 10 11 12  sys_fork: call find_empty_process ! …… ! 传递一些参数 push %gs pushl %esi pushl %edi pushl %ebp pushl %eax ! 调用 copy_process 实现进程创建 call copy_process addl $20,%esp   那么copy_process便是真正创建子进程的函数了\n我们可以找到在这个函数中，创建了一个task_struct结构空间，然后将父进程各种信息赋值给新的结构空间，我们注意几个点就可以\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  int copy_process(int nr,……) { struct task_struct *p; // …… // 获得一个 task_struct 结构体空间  p = (struct task_struct *) get_free_page(); // ……  p-\u0026gt;pid = last_pid; // …… // 设置 start_time 为 jiffies  p-\u0026gt;start_time = jiffies; // …… /* 设置进程状态为就绪。所有就绪进程的状态都是 TASK_RUNNING(0），被全局变量 current 指向的 是正在运行的进程。*/ p-\u0026gt;state = TASK_RUNNING; return last_pid; }   我们添加在如下地方\n那么我们就能记录新子进程建立的id，状态为’N'，和CPU中断次数的信息了\n 新建-\u0026gt;就绪：  当子进程建立完成后，他就进入就绪状态，同一个文件下，那么我们在return last_pid；前一句加入写入log文件的语句即可。按道理来说新建子进程不会直接运行啊，应该还要等待schedule函数的调度才能到运行状态，我就不太明白为什么这段代码会把新建子进程的状态p-\u0026gt;state = TASK_RUNNING;（答案：Linux中统一ready(就绪态）和running(运行态）为TASK_RUNNING状态）\n 就绪-\u0026gt;运行 | 运行-\u0026gt;就绪：  就绪到运行，那么就需要执行schedule()函数，那么我们进入kernel/sched.c里面找到schedule()函数。但这个时候我们需要判断current这个当前这个进程是属于什么状态，如果是TASK_RUNNING状态就需要现将转为就绪态，然后通过switch_to(next)将任务队列的第一个进程变为TASK_RUNNING。因此我们再次这样添加语句\n 阻塞-\u0026gt;就绪：  同样是在schedule()函数里，在第三点代码段前面。有将阻塞态进程转为就绪态的函数(可能此时有操作I/O设备的进程完成了任务)，那么我们直接在他改为就绪态后添加语句即可\n同样我们还有一个wake_up()函数也能将阻塞态转为就绪态，因此我们还需要在该函数中添加，该函数用到了 p-\u0026gt;state！=0，0代表的是TASK_RUNNNING。\n 运行-\u0026gt;阻塞：  阻塞有两种情况，第一种为可被中断打断阻塞，第二种为不可被中断打断阻塞\n不可被中断打断阻塞。只能由wake_up显示唤醒，再由schedule()语句后的if(tmp) tmp-\u0026gt;state=0依次唤醒。不可中断的睡眠进程一定是严格从\u0026quot;队列\u0026quot;(一个依靠放在进程内核栈中的指针变量tmp维护的队列)的头部唤醒。\n可被中断打断阻塞，他除了被wake_up唤醒，也可以被发一个信号唤醒，实际上就是进程PCB中维护的一个向量的某一位置的位，当进程需要再合适的时候处理这一位来唤醒，在schedule()中\n1 2 3 4  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p) if (((*p)-\u0026gt;signal \u0026amp; ~(_BLOCKABLE \u0026amp; (*p)-\u0026gt;blocked)) \u0026amp;\u0026amp; (*p)-\u0026gt;state==TASK_INTERRUPTIBLE) (*p)-\u0026gt;state=TASK_RUNNING;//唤醒   就是当进程是可中断睡眠时，遇到一些信号就会被唤醒，这样会导致，唤醒等待队列中间的某个进程，那这个队列就会需要进行适当的调整，会继续让该进程睡眠，并唤醒排在前面的进程然后再将该进程唤醒。\n这就是两者的区别\n不可被中断打断阻塞的状态转换位于sleep_on()函数，也在sched.c文件中\ntmp指向当前进程的上一个被睡眠的进程，* p指向当前的进程，如果* p没有指向当前进程a，也就是说当前进程a前面又加入了一些进程bcd等，此时d的tmp-\u0026gt;c，c的tmp-\u0026gt;b，b的tmp-\u0026gt;a，tmp是每个进程私有的，而* p是全局变量，此时*p指向 d.\n所以schedule()要回到进程a的程序，需要等d的if(tmp执行)，c的if(tmp)，b的if(tmp)执行并被唤醒后，a的schedule()才会回来并执行a的if(tmp)并唤醒a进程。\n该函数本意是失眠用的，那么我们就在current转换成阻塞态前加上该语句，此时睡眠队列头指针指向当前任务，当我们调用schedule后回到该程序继续执行if(tmp)的代码，将该进程变为就绪态。\n我们添加if就是为了避免一些情况导致某些进程重复被记录防止出错\n在interruptible_sleep_on()函数中\n我们是在其状态更改前写入日志文件，代码如下\n将当前任务放入等待队列中，同样该任务被唤醒后才能继续执行，如果* p指向的不是当前任务，说明其他任务加入进了等待队列，我们需要先唤醒前面的，等待后续进入队列的任务都被唤醒执行后再来唤醒本任务，因为该任务是可被中断唤醒的，所以先唤醒后面新加的等待任务，所以才会判断 if(* p\u0026amp;\u0026amp;* p！=current)如果p存在但不等于当前进程a，他就会让* p指向的进程d唤醒，然后然被某个信号唤醒的进程a继续睡眠（就是repeat回去的那条代码做的事）此时* p=NULL，所以后面都不会在进入 if(* p\u0026amp;\u0026amp;* p！=current)里面，而是通过tmp不断唤醒他连接的在他之前睡眠的进程，一直这样唤醒到tmp指向的是被某个信号唤醒的进程的程序a，然后执行schedule()后面的代码，此时if(tmp)的代码就是将本进程从阻塞态转换成就绪态。\n所以我们调用该睡眠函数 就在一开始添加写入阻塞的信息，在后面添加写入就绪的信息\nsys_pause()，sys_waitpid()函数也是可用于阻塞的，所以我们也需要再次加入写入阻塞信息的语句\n改动分别如下图\n 运行-\u0026gt;退出  在kernel/exit.c文件中的do_exit()函数中，改动如下：\n至此记录进程运行轨迹的任务完成。\n四、进程运行轨迹的跟踪与统计结果 我们尽量在Linux0.11外写好process.c文件(因为Linux0.11装载的vi书写效率很低)，然后在bochs虚拟机装载的Linux根目录文件系统的镜像文件所在目录，通过这个方式我们能进行文件交通信，通过\n1  sudo ./mount-hdc   打开访问权限，然后将process.c文件放入hdc/usr/root/ 文件夹里。\n然后输入(目录不要变，不是在hdc里面，而是hdc外一层目录，就是输入第一个指令的目录)\n1  sudo umount hdc   卸载该文件系统。\n在然后在上述目录下运行Linux0.11，并编译运行process.c\n1 2 3 4  ./run //运行Linux0.11 ls //可以查看/usr/root有没有加入process.c文件 gcc process -o process.c //编译 ./process //运行   我们会看到如下运行结果\n此时process.log文件已经记录好了各进程的运行轨迹，因此我们退出Linux0.11\nprocess.log文件如下：\n我们通过上面说过的 打开我们bochs虚拟机装载的Linux的文件系统，从/hdc/var中找到process.log文件，拿到我们系统的文件夹中。\n因为我们重点不在书写统计结果的代码，所以我们现在利用现有的统计结果的代码直接统计，改代码的逻辑思路就是通过 ID号进行结果分类，再通过jiffies 和状态的关系进行简单的加减运算即可。\n统计代码是python写的，名称为stat_log.py，将该文件和process.log日志文件放在一起，从命令行进入该文件夹输入指令\n1  chmod +x stat_log.py   给该文件加上执行权限，在输入如下指令直接执行数据统计\n1  ./stat_log.py process.log   得到如下结果Turnaround 为进程的轮转时间，即进程执行的总时(任务完成时间减去任务开始时间)\nwaiting 就是进程睡眠时间\nCPU Burst为该进程执行指令的用时，I/O Burst为该进程使用I/O设备的用时。\n如果遇到\n1  Error at line xxx:It is a clone of previous line.   大概率是某个记录进程状态的添加的语句出现了错误或者少了if判断语句导致重复记录一个进程的状态或状态冲突了。\n上述的结果是在时间片设置为15的结果，接下来我们要更改为30，然后再来观察进程运行的时间有何变化。\n进程的调度算法是采用的“时间片轮转调度”，每个进程都有一个时间片的时间来执行，也就是时分复用。\n在sched.c文件中，调度函数schdule()定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  while (1) { c = -1; next = 0; i = NR_TASKS; p = \u0026amp;task[NR_TASKS]; // 找到 counter 值最大的就绪态进程  while (--i) { if (!*--p) continue; if ((*p)-\u0026gt;state == TASK_RUNNING \u0026amp;\u0026amp; (*p)-\u0026gt;counter \u0026gt; c) c = (*p)-\u0026gt;counter, next = i; } // 如果有 counter 值大于 0 的就绪态进程，则退出  if (c) break; // 如果没有： // 所有进程的 counter 值除以 2 衰减后再和 priority 值相加， // 产生新的时间片  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p) if (*p) (*p)-\u0026gt;counter = ((*p)-\u0026gt;counter \u0026gt;\u0026gt; 1) + (*p)-\u0026gt;priority; } // 切换到 next 进程 switch_to(next);   我们寻找counter最大的就绪进程进行调度，每个进程的counter会在时钟中断时减1，因此如果我没找不到大于0的就绪态进程，就会执行下列指令\n1 2 3 4 5 6  // 如果没有： // 所有进程的 counter 值除以 2 衰减后再和 priority 值相加， // 产生新的时间片  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p) if (*p) (*p)-\u0026gt;counter = ((*p)-\u0026gt;counter \u0026gt;\u0026gt; 1) + (*p)-\u0026gt;priority; }   通过将counter从负值缩小两倍，然后加上其优先级，直到获得一个大于0的counter的进程。不过要注意，这里是对所有的进程都执行这样的操作，包括阻塞态，因此阻塞的越久的进程，counter越大，且优先级越高，counter越大。\n你可能会想，既然是通过counter来判断调度哪一个处于就绪态的进程，那新建的子进程的counter如何设置呢？\n我们查看fork.c文件中的copy_process()函数\n1 2 3 4 5 6 7  // 用来复制父进程的PCB数据信息，包括 priority 和 counter *p = *current; // 初始化 counter p-\u0026gt;counter = p-\u0026gt;priority; // 因为父进程的counter数值已发生变化，而 priority 不会，所以上面的第二句代码将p-\u0026gt;counter 设置成 p-\u0026gt;priority。 // 每个进程的 priority 都是继承自父亲进程的，除非它自己改变优先级。   该实验并不涉及更改子进程的priority，因此创建的进程的初始counter都被设置为进程0的priority.\n那么我们找到进程0的priority设置的文件，其在include/linux/sched.h中INIT_TASK宏中定义为：\n1 2 3  #define INIT_TASK \\ { 0,15,15, // 上述三个值分别对应 state、counter 和 priority;   我们更改如下：将15-\u0026gt;30\n最后再次执行process.c，再次通过stat_log.py文件统计process.log文件，得到如下结果\n平均的轮转时间和等待时间比15时间片和优先级更短了一些。\n先把结论说了：\n时间片变小，导致产生进程调度次数变多，从而导致进程等待时间越长\n时间片变大，导致进程因中断或睡眠进入的进程调度次数也增加，等待时间也越长\n那为什么上面时间片变大了，执行和等待时间变小了呢？\n因为在最大和最小之间有个平衡，会是最优的选择，30可能碰巧在这了。说白了就是我的测试用例少了(主要是懒了)。\n所以要合理设置时间片的大小，太小太大都会影响CPU效率。\n那么单进程和多进程编程最大区别是什么呢？\n单进程程序我们写的多了，顺序执行，逻辑单线，在没有其他程序干扰下，数据是同步的。\n而多进程程序却在宏观时间看是同时执行的，正因为共享文件，而进程之间的执行顺序没法控制，因此要考虑进程之间的关系和互相影响的情况，要做好数据的异步处理，避免数据污染，进程之间同步，通信，互斥等关系也要在编程时有个清晰的框架。\n结束~~！\n","permalink":"http://Mrsdwang.github.io/oslab3/","tags":["操作系统"],"title":"进程运行轨迹的跟踪与统计"},{"categories":["操作系统"],"contents":"LAB2 一、 任务内容：\n在原有的linux0.11上添加两个系统调用，及其相应的响应函数，并通过API调用系统调用。\n两个系统调用的原型和应该完成的功能如下\n（1）iam()\n1  int iam(const char *name);   功能：将name的内容拷贝到内核中保存下来\n要求：name长不能超过24个字符，包括最后的'\\0'\n返回值：拷贝的字符串name的长度。若name长超过24，则返回 -1，并置errno为EINVAL（errno是个头文件，即return -EINVAL,EINVAL是errno.h里的一个宏定义）\n（2）whoami()\n1  int whoami(char *name,unsigned int size);   功能：将iam()保存到内核空间的字符串拷贝到name字符串指向的用户地址空间中，为了确保name不会越界访问，用size说明其大小\n返回值：拷贝字符串name的长度。若size小于name所占空间，返回 -1，并置errno为EINVAL\n二、明确何为系统调用。做什么的？如何做？\n要谈系统调用，那我们还是先了解一下何为内核。(只是让我自己再复习一下概念，能否说清楚)\n操作系统其实就是一个监控程序，对的，也是一个程序。它相当于单片机我们写的while(1)，而内核就是操作系统最核心的部分，也即这个程序里面最核心的代码。我们可以从linux源码看出其内核负责处理各种核心任务，比如I/O,进程管理，内存管理等。\n所以内核即操作系统这个程序里面最关键的代码。也就是他是计算机资源的管理者，包括硬件，软件资源。软件资源就是各种形式的数据，比如各种文件，软件程序。硬件资源就是总线、CPU、内存、磁盘、网卡、显卡及各种IO。\n那么系统调用是如何出现的呢？\n我们假设如果没有操作系统来管理各种进程，举个栗子，每个进程需要放进内存才能执行，那么就会在占用内存空间，如果两个任务同时申请同一个内存空间会造成冲突。更为严重，如果一个任务占用了必须一直运行的程序或者非常重要的程序的内存空间，那么计算机就崩溃了。\n同时，如果有操作系统，并且不对进程加以限制及控制，会发生什么情况？\n在举几个栗子，对于单任务，他可能把他的空间占用到了原本分配给操作系统的空间，那么两者就混合了，没办法区分，并且用户程序可以访问大部分硬件设备，甚至改变操作系统，如果一个病毒(恶意进程)也连接到了操作系统的程序里面，那它就成了操作系统的一部分了，因为没办法区分嘛。\n多任务呢？如果多个进程同时操控同一个硬件设备，数据传输就会错误，数据被污染，可以理解为一个程序的数据发送到了另一个程序。同时操作系统必须自己响应硬件中断，通过硬件中断来切换任务上下文，让合适的任务在合适时机运行。如果中断响应程序被更改了呢？操作系统又会如何运行呢？\n综上，操作系统必须要清楚哪些程序占用那些资源，合理控制分配，才能有序运行下去。为了避免一个普普通通的进程将自己干掉取代，操作系统必然需要采取强硬措施保证自己的地位。核心问题在于保护关键寄存器和重要的物理内存。\n既然操作系统是个监控程序，它要控制其下的进程，那么各种进程就必须要有分级制度，并且操作系统拥有最高控制权才能让其余的进程服从它的安排。这就引出了用户态和内核态。因此，只有有操作系统的前提，用户态和内核态这种概念才会存在。因为对于CPU来说不过是状态标志位的改变，即寄存器几个有特殊意义的位改变后，CPU有不同的工作方式。为了用户使用的方便，操作系统才衍生这用户态和内核态的概念\n这个控制权由硬件来控制，当CPU引导进入保护模式后，会有一张全局描述符表，记录了各代码段的特权级别，在linux中特权级别为0-3，0级等级最高。CS寄存器中有两位(CPL，当前特权级)用来指明CPU当前的特权级，0最高，3最低，分别称为内核态和用户态。同时还存在请求特权级RPL，其存在请求者的程序代码里，代码里要提供一个选择子selector，RPL保存选择子的最低两位。访问时的特权检查根据：有效特权级EPL=max(RPL,CPL)\u0026lt;=CPL是否成立，所以用户程序最多访问CPL级别的代码段。\n当用户态进入内核态，特权级升高，内核态回到用户态，特权级降低。这个进程切换的同时还会切换相应的栈，ESP从用户栈切换到内核栈，再从内核栈切换到用户栈。以上措施皆为限制程序的访问能力来保证操作系统的安全。\n由上面我们也可以知道，用户态不能随随便便切换到内核态，要是随意切换，那操作系统不就也还是危险的了嘛。但是用户态必须要使用硬件设备，让操作系统来和硬件交互执行程序的各种功能，所以我们需要进入内核态啊，那么我们要如何做呢？这时候需要一个机制：用户态程序切换到内核态，但不能控制内核态中执行的指令。\n这个机制就是系统调用(嘿嘿，说了那么多终于讲到它了)，而执行机制的方法就是中断（异常的一种，且不仅这一个方法，所以称为”异常“会更为准确，例如缺页也会进入内核态进行取页换页的操作），可以理解为中断是能够陷入内核态的有效手段。用户程序通过系统调用的这个方法，告诉内核他要去操控哪些计算机资源。所以系统调用是内核态与用户态的分界\n例如我们使用printf函数，他就告诉了内核要控制显示器输出这样的字符串，所以我们可以在屏幕上看到字符串的输出，说明我们的程序已经进入过内核态并将数据传递给了显示器这个硬件。\n系统调用即调用系统函数，通过系统函数来实现控制硬件。系统函数是调用系统库中为该系统调用编写的一个接口函数(API)，但API并不会自己完成系统调用，而是真正的系统调用被封装在API中，换句话说，API调用真正的系统调用。例如write()这个系统函数就是一个API，这个函数中还有指令真正用来实现在显示器上显示字符。\n那么系统函数也是函数和我们用户态写的用户程序的函数有什么区别呢？调用用户程序的自定义函数，在汇编层面是通过call指令跳转到该函数地址，然后执行。\n而调用API到API调用真正的系统调用的过程如下：\n 将系统调用函数的编号存入EAX; 把函数参数存入其他通用寄存器; 触发int 0x80，请求处理系统调用的system_call来处理;  该次任务，我们在用户程序直接执行我们所写的系统调用函数。\n这个过程如下：\n 应用程序调用库函数(API) API将系统调用号存入EAX，通过中断调用使系统进入内核态 内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用） 系统调用完成相应功能，将返回值存入EAX，返回到中断处理函数 中断处理函数返回到API API将EAX的值返回给应用程序  三、分析及实现\n我们会从一些系统函数进行分析来充分理解用户程序是如何进行系统调用的。\n我们查看Linux0.11源码里的lib/close.c中close()的API\n1 2 3 4  #define __LIBRARY__ #include \u0026lt;unistd.h\u0026gt; _syscall1(int, close, int, fd)   _syscall 是一个宏，其在include/unistd.h中定义\n1 2 3 4 5 6 7 8 9 10 11 12  #define _syscall1(type,name,atype,a) \\ type name(atype a) \\ { \\ long __res; \\ __asm__ volatile (\u0026#34;int $0x80\u0026#34; \\ : \u0026#34;=a\u0026#34; (__res) \\ : \u0026#34;0\u0026#34; (__NR_##name),\u0026#34;b\u0026#34; ((long)(a))); \\ if (__res \u0026gt;= 0) \\ return (type) __res; \\ errno = -__res; \\ return -1; \\ }   将_syscall1(int，close，int，fd)进行宏展开有\n1 2 3 4 5 6 7 8 9 10 11  int close(int fd) { long __res; __asm__ volatile (\u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (__res) : \u0026#34;0\u0026#34; (__NR_close),\u0026#34;b\u0026#34; ((long)(fd))); if (__res \u0026gt;= 0) return (int) __res; errno = -__res; return -1; }   这个就是API的定义，里面包含了调用真正的系统调用。将宏__ NR_close存入EAX ( 你是不是会疑惑__ NR_close怎么出来的？咱先按下不表)，然后将fd存入EBS，然后进行0x80中断调用。从EAX取出返回值存入__res中，判断后再决定传什么值给API调用者。对比API进行真正系统调用的过程，那么可知这个就是进行了API到真正系统调用的实例。\n那么__NR_close是什么呢？它其实就是系统调用的编号，我们有一步要将系统调用号写入EAX让内核知道要调用哪一个内核函数嘛。所有系统调用的编号都在include/unistd.h里面定义。我们要自己写系统调用函数，也需要给我们的函数一个编号。\n1 2 3 4 5  #define __NR_close 6 /* 所以添加系统调用时需要修改include/unistd.h文件， 使其包含__NR_whoami和__NR_iam。 */   因此对于我们写的用户程序调用系统调用需要有如下内容\n1 2 3 4 5 6 7 8 9 10 11  /* 有它，_syscall1 等才有效。详见unistd.h */ #define __LIBRARY__  /* 有它，编译器才能获知自定义的系统调用的编号 */ #include \u0026#34;unistd.h\u0026#34; /* iam()在用户空间的接口函数，调用系统调用，是系统调用iam()的API，在这个宏里面完成真正系统调用 */ _syscall1(int, iam, const char*, name); /* whoami()在用户空间的接口函数 */ _syscall2(int, whoami,char*,name,unsigned int,size);   所以我们在unistd.h文件中添加如下的内容\n如此我们就将我们自己写的系统调用函数设置好了\n我们调用close()API时调用了int 0x80，所以我们要从此进入内核。\n首先来了解0x80中断执行的过程\n首先我们看内核初始化的时候，主函数main()中调用了sched_init()初始化函数（现在是系统调用初始化的分析）\n1 2 3 4 5 6 7 8  void main(void) { // ……  time_init(); sched_init(); buffer_init(buffer_memory_end); // …… }   sched_init() 在kernel/sched.c中定义\n1 2 3 4 5  void sched_init(void) { // ……  set_system_gate(0x80,\u0026amp;system_call); }   set_system_gate()是个宏，在include/asm/system.h中定义。我们可以看到他传入0x80这个参数和system_call这个中断程序的地址。\n1 2  #define set_system_gate(n,addr) \\ _set_gate(\u0026amp;idt[n],15,3,addr)   而_set_gate定义为\n1 2 3 4 5 6 7 8 9 10  #define _set_gate(gate_addr,type,dpl,addr) \\ __asm__ (\u0026#34;movw %%dx,%%ax\\n\\t\u0026#34; \\ \u0026#34;movw %0,%%dx\\n\\t\u0026#34; \\ \u0026#34;movl %%eax,%1\\n\\t\u0026#34; \\ \u0026#34;movl %%edx,%2\u0026#34; \\ : \\ : \u0026#34;i\u0026#34; ((short) (0x8000+(dpl\u0026lt;\u0026lt;13)+(type\u0026lt;\u0026lt;8))), \\ \u0026#34;o\u0026#34; (*((char *) (gate_addr))), \\ \u0026#34;o\u0026#34; (*(4+(char *) (gate_addr))), \\ \u0026#34;d\u0026#34; ((char *) (addr)),\u0026#34;a\u0026#34; (0x00080000))   这里展示的是将system_call函数地址写到0x80对应的中断描述符中，相当于执行int 0x80指令，会产生一个异常陷入内核空间并执行系统调用处理函数system_call，那么明白了0x80号中断如何和system_call产生联系后，我们简单看下system_call的代码，是纯汇编语言编写的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  !…… ! # 这是系统调用总数。如果增删了系统调用，必须做相应修改，所以我们增加两个系统调用函数，这里数值+2 nr_system_calls = 72 !…… .globl system_call .align 2 system_call: ! # 检查系统调用编号是否在合法范围内 cmpl \\$nr_system_calls-1,%eax ja bad_sys_call push %ds push %es push %fs pushl %edx pushl %ecx ! # push %ebx,%ecx,%edx，是传递给系统调用的参数 pushl %ebx # to the system call ! # 让ds, es指向GDT，内核地址空间（修改段选择子为内核段） movl $0x10,%edx mov %dx,%ds mov %dx,%es movl $0x17,%edx ! # 让fs指向LDT，用户地址空间 mov %dx,%fs call sys_call_table(,%eax,4) pushl %eax movl current,%eax cmpl $0,state(%eax) jne reschedule cmpl $0,counter(%eax) je reschedule   并不需要完全理解每一句话，知道他整个程序是干什么的即可。当我们调用system_call这个函数后，可以看到他保存了“现场”，各种push将用户态的各种参数入栈，并让fs指向用户空间，都是为了从内核态回到用户态后，还能还原进入内核态前的状态。(这是操作系统完成的部分保存，硬件完成的还有一部分，比如ss、esp、cs等寄存器)\n并且该函数让我们从用户态陷入到了内核态。其余的简单了解一下即可。\n我们关注\n1  call sys_call_table(,%eax,4)   我们知道EAX存放的是系统调用号，即__NR_xxxx。根据汇编寻址方法为\n1  call sys_call_table + 4 * %eax   那么sys_call_table又是什么呢？我们可以在include/linux/sys.h中找到\n那么可知它是一个函数指针数组的起始地址。\n因此我们根据系统调用号算出系统调用相应的响应函数在表里的位置，并调用该函数。\n所以我们要在sys.h中加上 sys_iam() ,sys_whoami()两个响应函数引用\n更改如下图所示\n这里函数表添加的位置要和__NR_xxxx的值对应上，因为我们是根据这个值来计算函数在表里的位置的。\n那么因此可以知道我们执行 int 0x80 中断指令后就能保存现场-\u0026gt;陷入内核-\u0026gt;调用系统响应相应的响应函数。\n所以，那么我们就该写系统函数sys_iam()和sys_whoami(),我们将这两个函数写成一个who.c文件，这样就只需要一次编译。在完成这两个函数完整功能前，我们先写个测试代码。\n1 2 3 4 5 6  int sys_iam(const char* name){ printk(\u0026#34;Hello from sys_iam\u0026#34;); } int sys_whoami(char* name,unsigned int size){ printk(\u0026#34;Hello from sys_whoami\u0026#34;); }   可能会有小伙伴疑问了？欸，为什么是printk而不是printf呢？ 首先明确我们现在是系统函数，调用这个函数的时候我们处于内核态，而内核态是不能使用用户态的函数printf的，所以有printk函数给内核函数使用。这两个函数本质调用的都是tty_write这个函数，但printk是在内核态，对fs寄存器操作不同于printf，因为fs寄存器指向用户态，所以他要将fs寄存器的内容入栈，保存现场，然后指向内核段，出内核态后再pop出\u0026amp;fs恢复现场\n然后我们运行 Linux0.11，并在上面编写test.c文件来调用系统函数。\n1 2 3 4 5 6 7 8 9 10 11 12  #define __LIBRARY__ #include \u0026lt;unistd.h\u0026gt;//iam()和whoami()两个系统调用的入口参数 _syscall1(int, iam, const char *, name); _syscall2(int, whoami, char*, name,unsigned int,size); int main(void){ char buf[24]; iam(\u0026#34;test\u0026#34;); //这句和下句都只是满足需要传入参数，才能运行。  whoami(buf,24); return 0; }   那么这样我们就能调用iam()和whoami()两个系统调用的响应函数sys_iam和sys_whoami了。我们得到输出\n因此我们可以确定我们增加系统调用和响应函数成功了，那么我们现在将响应函数更改为我们想要的功能。\n我们知道指针传递的参数是程序所在地址空间的逻辑地址，如果在内核就直接访问这个地址，得到的是内核空间的数据，而不会是用户态的数据，所以要把name这个字符串被内核读取存入，还需要其他的方法。\n我们从open(char *filename，…..)来分析open（）这个系统调用是如何处理内核态从用户态读取数据的。\n1 2 3 4 5 6 7 8 9  int open(const char * filename, int flag, ...) { // ……  __asm__(\u0026#34;int $0x80\u0026#34; :\u0026#34;=a\u0026#34; (res) :\u0026#34;0\u0026#34; (__NR_open),\u0026#34;b\u0026#34; (filename),\u0026#34;c\u0026#34; (flag), \u0026#34;d\u0026#34; (va_arg(arg,int))); // …… }   这段我们分析过了，就是把各种参数存在寄存器中。但这里open的文件名是通过EBX传递，就是进入内核后，通过EBX取出文件名字符串。但EBX指向的数据在用户空间，执行的却是内核代码。\n1 2 3 4 5 6 7 8 9 10 11  system_call: //所有的系统调用都从system_call开始 ! …… pushl %edx pushl %ecx pushl %ebx # push %ebx,%ecx,%edx，这是传递给系统调用的参数 movl $0x10,%edx # 让ds,es指向GDT，指向核心地址空间 mov %dx,%ds mov %dx,%es movl $0x17,%edx # 让fs指向的是LDT，指向用户地址空间 mov %dx,%fs call sys_call_table(,%eax,4) # 即call sys_open   这段代码也分析过了，就是各种参数入栈来保存，然后通过fs获得用户数据段的数据。然后call sys_call_table，我们会得到sys_open响应函数\n1 2 3 4 5 6 7 8  int sys_open(const char * filename,int flag,int mode) //filename这些参数从哪里来？ { …… if ((i=open_namei(filename,flag,mode,\u0026amp;inode))\u0026lt;0) { …… } …… }   你可能会问我们不是查表找到的响应函数吗？那这些参数哪里获得呢？看看上面的汇编代码，我们pushl 了各种寄存器的值入栈，这些就是函数的参数。我们C语言函数调用另一个函数，就是要将传递的参数压栈，从右到左顺序压，然后call调用。如果要用汇编程序调用C函数就需要自己手动编写这些压栈代码。\n最后我们看到这些参数传给了open_namei（），我们继续深究会发现他里面还传给了dir_namei(),get_dir()，我们从get_dir函数看到\n1 2 3 4 5 6 7 8  static struct m_inode * get_dir(const char * pathname) { …… if ((c=get_fs_byte(pathname))==\u0026#39;/\u0026#39;) { …… } …… }   那么我们就可以知道可以通过 get_fs_byte()这个函数获得用户空间的一个字节的数据。\n那么如何从内核态拷贝数据到用户态呢？\n我们在include/asm/segment.h中查看：\n1 2 3 4 5 6 7 8 9 10 11  extern inline unsigned char get_fs_byte(const char * addr) { unsigned register char _v; __asm__ (\u0026#34;movb %%fs:%1,%0\u0026#34;:\u0026#34;=r\u0026#34; (_v):\u0026#34;m\u0026#34; (*addr)); return _v; } extern inline void put_fs_byte(char val,char *addr) { __asm__ (\u0026#34;movb %0,%%fs:%1\u0026#34;::\u0026#34;r\u0026#34; (val),\u0026#34;m\u0026#34; (*addr)); }   即put_fs_byte和其配套，可将内核态数据写入用户态。\n我们是否可以获得一个规律put_fs_xxx() and put_fs_xxx()是用来连接内核态和用户态的呢？\n那我们开始写sys_iam 和 sys_whoami函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #include \u0026lt;string.h\u0026gt;#include \u0026lt;errno.h\u0026gt;#include \u0026lt;asm/segment.h\u0026gt; #define maxsize 24 char msg[maxsize]; int msglen; int sys_iam(const char* name){ int len=0; while(get_fs_byte(\u0026amp;name[len])!=\u0026#39;0\u0026#39;) len++; if(len\u0026gt;23) return -EINVAL; int i=0; for(;i\u0026lt;len;++i) msg[i] = get_fs_byte(\u0026amp;name[i]); msg[i] = \u0026#39;\\0\u0026#39;; msglen = len; return msglen; } int sys_whoami(char *name, unsigned size){ if(size \u0026lt; msglen) return -EINVAL; int i=0; for(;i\u0026lt;msglen;++i) name[i] = put_fs_byte(msg[i]); return msglen; }   当我们who.c完成后要在makefile里面增加对who.o的依赖\n如下图：\n然后在添加对who.c and who.o 的依赖的产生条件,如下图：\n完成上述步骤后，执行下面指令\n1  make all   进行整体编译\n然后我们运行 Linux0.11，我们还需要在这里面添加iam和whoami两个系统调用号的宏定义。\n1 2  cd /usr/include/ vi unistd.h   然后加上系统调用号\n然后\n1 2 3  cd /usr/root/ vi iam.c vi whoami.c   进行我们用户程序iam.c代码的编写（将传入字符串写入内核空间）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #define __LIBRARY__ // #include \u0026lt;unistd.h\u0026gt;\t// 要想调用系统调用需要这些两个#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; _syscall1(int,iam,const cahr*,name);//iam()系统调用的用户接口  int main(int argc, char **argv){ int i; if(argc!=2){ printf(\u0026#34;Usage: %s \u0026lt;message\u0026gt;\\n\u0026#34;,argv[0],argv[1]); return 0; } i = iam(argv[1]); //这句系统调用就将我们传入的name写入了内核空间  if(i != strlen(argv[1])){ printf(\u0026#34;set message error\\n\u0026#34;); return 0 } return 0; }   在进行whoami.c的编写\n1 2 3 4 5 6 7 8 9 10 11 12  #define __LIBRARY__ #include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt; _syscall2(int,whoami,char *,name, unsigned int,size); int mai(){ char message[24]; whoami(message,24); printf(\u0026#34;%s\\n\u0026#34;,message); return 0; }   我们采用如下命令编译iam.c和whoami.c两个文件\n1 2  gcc -o iam iam.c gcc -o whoami whoami.c   只要没有其他语句出现那么就算程序写对了\n然后我们运行代码得到如下结果\n至此我们的任务完成！！！\n我们总结一下，\n系统调用的步骤-\u0026gt;明白系统调用需要添加哪些信息代码-\u0026gt;编写系统调用的响应函数（就是系统调用iam()后他会执行的功能的函数）-\u0026gt;用户程序调用执行。\n了解系统调用过程要明白0x80号中断是如何陷入内核态的\n这里我们__NR_xxxx是系统调用号，一个宏定义。在响应函数表里添加响应函数sys_xxx。编写响应函数（也称内核函数）。\n用户程序需要#define __ LIBRARY __ ; #include \u0026lt;unistd.h\u0026gt; ; _ syscall1(type,name,type,parameter….)。分别是 使能 _syscallx函数，引入系统调用号的宏，创建系统调用的用户程序接口（系统调用的API）。\n我们这里是直接调用系统调用，所以直接使用_syscallx，平时例如我们使用的printf作为系统调用的API\n附：\nerrno是传统的错误代码返回机制。通常我们会返回0或1代表正确或错误，但不能说明哪错了，错了什么。所以全局变量errno就能保存错误值，调用者可以通过判断errno来决定如何应对错误。错误值的含义都有标准定义。\n","permalink":"http://Mrsdwang.github.io/oslab2/","tags":["操作系统"],"title":"操作系统的系统调用"},{"categories":["操作系统"],"contents":"lab 1 环境：通过bochs虚拟机运行的linux0.11\n0x7C00是BIOS将主引导扇区（第一个扇区）内容载入进内存的一个地址。操作系统或者引导程序必须假设他们的汇编代码从内存的0x7C00地址开始\ntask 1 更改系统启动的提示文字。\n文件在boot/bootsect.s中。\n直接用源码的这个文件在里面改也是可以的，也可以自己写一个如下内容的bootsect.s来进行实验，也是能正常运行。（记得备份）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  entry _start _start: ！获得光标位置 mov ah,#0x03 xor bh,bh int 0x10 ！0x10中断的0x03功能是读取光标位置（百度该中断的功能） ！对输出信息的操作 mov cx,#33 !要显示字符串的长度 mov bx,#0x000c !显示字符串的颜色（这为红色 mov bp,#msg1\t!向该寄存器读入msg1，向屏幕写入该字符串 ！这里需要额外处理es寄存器，源码在这段代码前就处理过了，所以源码看不到这段。 mov ax,#0x07c0 mov es,ax ！es:bp是显示字符串的地址 mov ax,#0x1301 !向屏幕写字符串并移动光标到末尾。如果写0x1300，你会发现光标返回到了起始位置 int 0x10 ！和上一条指令相关，!0x1301是调用0x10中断的13号功能中的1号子功能 inf_loop: jmp inf_loop ！死循环让界面保持 msg1: .byte 13,10 ！回车换行 .ascii \u0026#34;Hey Doors system loading...\u0026#34; .byte 13,10,13,10 ！回车换行回车换行 .org 510 ！之后的语句从510地址开始 boot_flag: .word 0xAA55 ！磁盘引导标志0xAA55。引导扇区的最后两个字节，用来识别引导扇区   1 2 3 4 5 6  编译bootsect.s 1. cd 进入 bootsect.s文件所在文件夹 2. 通过如下命令分别编译和链接bootsect.s $ as86 -0 -a -o bootsect.o bootsect.s $ ld86 -0 -s -o bootsect bootsect.o 3. 通过 ls -s 命令查看 文件信息，会发现bootsect 为544字节，但一个扇区的大小为512字节   因为ld86产生的是Minix可执行文件，该类型额外包括MInix可执行文件头部，结构如下\n1 2 3 4 5 6 7 8 9 10 11 12  struct exec { unsigned char a_magic[2]; //执行文件魔数  unsigned char a_flags; unsigned char a_cpu; //CPU标识号  unsigned char a_hdrlen; //头部长度，32字节或48字节  unsigned char a_unused; unsigned short a_version; long a_text; long a_data; long a_bss; //代码段长度、数据段长度、堆长度  long a_entry; //执行入口地址  long a_total; //分配的内存总量  long a_syms; //符号表大小 };   通过计算 char6(6 byte)+short1(2 byte)+long*6(24 byte)=32 byte，512+32=544.所以我们应该跳过bootsect的前32字节，再把他放入引导扇区中。\n根据如下命令\n1  $ dd bs=1 if=bootsect of=Image skip=32   将编译产生的Image文件复制到Linux-0.11目录下\n1 2 3 4 5  当前工作路径仍然为Linux-0.11/boot/ $ cp ./Image ../Image # 执行 oslab 目录中的 run 脚本（bochs的运行脚本） $ ../../run   综上，得到如下界面\nbootsect.s是操作系统最开始的部分，共512个字节，再0磁道0扇区位置，读入内存0x7c00。\n现在系统还在实模式下运行，物理地址=代码段cs*16+偏移，所以代码里写BOOTSEG=0x07c0才能得到0x7c00（这里的代码没用到）\nbootsect.s和setup.s是为了完成将内核加载到内存，并跳转到内核执行而写的。bootsect.s是由BIOS加载到内存中，无法完成跳转到内核执行的任务。而setup.s就能完成进入32位模式并跳转到内核执行的任务，还可通过BIOS中断获取硬件信息的任务。\n所以接着我们应该编写setup.s文件，让其输出提示该文件开始运行的字符串，再让其输出光标位置，内存大小和磁参数等硬件信息\ntask 2 首先输出字符串\n我们直接将bootsect.s的代码复制过来，因为现在两者功能都是输出字符串。\n但我们需要进行一些更改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  entry _start _start: ！获得光标位置 mov ah,#0x03 xor bh,bh int 0x10 ！0x10中断的0x03功能是读取光标位置（百度该中断的功能） ！对输出信息的操作 mov cx,#28 #要显示字符串的长度 mov bx,#0x000c #显示字符串的颜色（这为红色 mov bp,#msg2 !(更改为msg2)\t#向该寄存器读入msg2，向屏幕写入该字符串 ！这个时候要修改es的值，用了cs的值。 mov ax,cs mov es,ax ！es：bp是显示字符串的地址 mov ax,#0x1301 ！向屏幕写字符串并移动光标到末尾。如果写0x1300，你会发现光标返回到了起始位置 int 0x10 ！和上一条指令相关，#0x1301是调用0x10中断的13号功能中的1号子功能 inf_loop: jmp inf_loop ！死循环让界面保持 msg1: .byte 13,10 ！回车换行 .ascii \u0026#34;OK we are in SETUP now\u0026#34; .byte 13,10,13,10 ！回车换行回车换行 .org 510 ！之后的语句从510地址开始 boot_flag: .word 0xAA55 ！磁盘引导标志0xAA55。引导扇区的最后两个字节，用来识别引导扇区   上面是setup.s文件的内容，\n此时我们还需要更改bootsect.s的内容让其能载入setup.s文件\n我们需要确定setup所占用的扇区，bootsect.s只占用一个扇区，setup.s从下一个扇区开始，我们定义其占用两个（Linux0.11占用4个）。源码会将bootsect移动到0x9000处，此处我们不移动，所以bootsect.s在内存的0x7c00的位置，占512个字节，那么setup就载入0x7e00处，因为是实模式，所以逻辑地址应该为0x07e0.\nbootsect.s代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  SETUPLEN=2 SETUPSEG=0x07e0 ！setup载入地址 entry _start _start: mov ah,#0x03 xor bh,bh int 0x10 mov cx,#33 mov bx,#0x0007 mov bp,#msg1 mov ax,#0x07c0 mov es,ax ！把es指向0x07c0有什么用？ mov ax,#0x1301 int 0x10 ！以上和之前的bootsect一样 load_setup: mov dx,#0x0000 ！设置驱动器和磁头：软盘0，磁头0，是因为调用了13号中断才能控制磁盘，不是0x0000地址的意思 mov cx,#0x0002\t！设置扇区号和磁道：磁头0 磁道0 扇区2 mov bx,#0x0200\t！设置读入的内存地址：es:bx bx是偏移地址，BOOTSEG=0X0000+adress=512=0x0200，偏移512字节 mov ax,#0x0200+SETUPLEN ！设置读入的扇区数 int 0x13 ！调用0x13中断，功能是读入2个setup.s扇区 jnc ok_load_setup ！读入成功就跳转到该函数 mov dx,#0x0000 ！否则进入下段 mov ax,#0x0000 ！复位软盘 int 0x13 jmp load_setup！重新循环再次尝试读取 ok_load_setup: jmpi 0,SETUPSEG ！跳到setup载入的地址执行该文件 msg1: .byte 13,10 .ascii \u0026#34;Hey Doors System loading...\u0026#34; .byte 13,10,13,10 .org 510 boot_flag: .word 0xAA55   以上 bootsect.s和setup.s就完成，接着是通过makefile共同编译\n指令如下\n1  $ make BootImage   然后会得到报错\n1 2  Unable to open \u0026#39;system\u0026#39; make: *** [BootImage] Error 1   因为makefile会执行build.c，他要求命令行参数得到bootsect、setup和system内核的文件名。但我们只做了前两者，所以会报错，那我们直接将build.c第三个参数的部分代码注释掉即可。\n如图所示。\n接着再使用如下指令\n1 2 3  $ cd ~/oslab/linux-0.11 $ make BootImage $ ../run   将得到如下结果\ntask 3 接着在完善setup.s文件让其还能再输出光标位置，内存大小和磁盘参数的信息\n我们将这些信息载入内存0x9000的位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172  INITSEG = 0x9000 entry _start _start: ! print string mov ah,#0x03 ! cursor pos get xor bh,bh int 0x10 mov cx,#28 mov bx,#0x000c ！字符颜色 mov bp,#msg2\tmov ax,cs mov es,ax ！修改es的值为cs mov ax,#0x1301 int 0x10 mov ax,cs mov es,ax !init ss:sp 初始化栈 mov ax,#INITSEG mov ss,ax ！栈指向0x9000 mov sp,#0xFF00 ！设置512B偏移地址，arbitrary value\u0026gt;\u0026gt;512，因为刚开始后面的内存空间都没被使用（这啥解释嘛） !cursor info mov ax,#INITSEG mov ds,ax ！ds寄存器指向0x9000，下面开始让各数据载入0x9000位置 mov ah,#0x03 xor bh,bh int 0x10 ！获取光标位置信息 mov [0],dx ！[0]从0x9000开始，将获取的数据放入这个内存地址 !memory info mov ah,#0x88 int 0x15 ！通过0x15中断得到memory大小信息 mov [2],ax ！存入0x9002位置 ! disk parameter 磁盘参数表 mov ax,#0x0000 mov ds,ax ！将数据段移动到0x0000，也是ram开始的位置，这个地方（0-1024）的位置存放中断向量表。在41号中断处读取第一个磁盘的参数。（不懂，不知道对不对。0x0000之前不是磁盘的地址吗）！！该问题已解决，在后面会独立说明。 ！乘4是因为中断向量表每个表项占4B，那么41号中断的入口地址自然为4*0x41 ！乘4就是将0x41左移两位，lds有两步操作：si\u0026lt;-4*0x41,ds\u0026lt;-[4*0x41+2]，中断向量表存储的只是相应中断号中断服务程序的入口地址。 ！其构造是4个字节单元，第2字节位偏移量ip，高两字节为服务程序段地址，所以ds是中断服务程序段地址，si为中断服务程序偏移。因此可以执行0x41中断的服务程序，把第一个磁盘的参数表取出来。 ！相当于运行 mov si,[4*0x41] mov ds,[4*0x41+2] lds si,[4*0x41] mov ax,#INITSEG mov es,ax mov di,#0x0004 mov cx,#0x10 #拷贝16字节的数据。一个磁盘参数表大小为16字节，第一个磁盘的参数表地址为0x9080，第二个为0x9090 rep movsb !ready to print mov ax,cs mov es,ax ！es:bp是输出字符串存放的地址 mov ax,#INITSEG\t！让ds寄存器指向0x9000 mov ds,ax !cursor position mov ah,#0x03 xor bh,bh int 0x10 mov cx,#11 mov bx,#0x0007 mov bp,#msg_cursor mov ax,#0x1301 int 0x10 mov ax,[0] ！将0x9000地址内容放入ax寄存器，print_hex函数用 call print_hex ！输出msg_cursor内容 call print_nl ！输出个回车 ！下面的都是相同的，不再注释 !memory size mov ah,#0x03 xor bh,bh int 0x10 mov cx,#12 mov bx,#0x0007 mov bp,#msg_memory mov ax,#0x1301 int 0x10 mov ax,[2] call print_hex call print_nl !cyles mov ah,#0x03 xor bh,bh int 0x10 mov cx,#25 mov bx,#0x0007 mov bp,#msg_cyles mov ax,#0x1301 int 0x10 mov ax,[4] call print_hex !heads mov ah,#0x03 xor bh,bh int 0x10 mov cx,#8 mov bx,#0x0007 mov bp,#msg_heads mov ax,#0x1301 int 0x10 mov ax,[6] call print_hex call print_nl !sectors mov ah,#0x03 xor bh,bh int 0x10 mov cx,#8 mov bx,#0x0007 mov bp,#msg_sectors mov ax,#0x1301 int 0x10 mov ax,[12] ！18？不太明白这个怎么每个数据长度怎么算的，可能固定有直接百度就可以？这个应该没必要深究 call print_hex call print_nl inf_loop: jmp inf_loop print_hex: mov cx,#4 ！16位二进制数以4位16进制表示，因为十六进制和ASCII有很好的对应 mov dx,ax ！将0x900x位置的数放入数据寄存器 print_digit: rol dx,#4 ！从高位到低位显示4位16进制数 mov ax,#0xe0f ！ah = 请求的功能值，al = 半字节(4 bit)掩码 and al,dl ！取dl的低4 bit add al,#0x30 cmp al,#0x3a ！数字的十六进制范围为0x30~0x39，小于0x3a jl outp ！al小于0x3a（为数字）跳转， add al,#0x07 ！否则就是字母，根据十六进制转ascii码的字母，字母要加上0x07，a~f的范围为0x41~0x46 outp: int 0x10 loop print_digit ！每次loop，cx-1，判断cx是否等于0，不为0就继续循环，为0就顺序执行，共循环4次 ret print_nl: mov ax,#0xe0d int 0x10 mov al,#0xa int 0x10 ret msg2: .byte 13,10 .ascii \u0026#34;OK we are in SETUP now\u0026#34; .byte 13,10,13,10 msg_cursor: .ascii \u0026#34;Cursor Pos:\u0026#34; msg_memory: .ascii \u0026#34;Memory Size:\u0026#34; msg_cyles: .ascii \u0026#34;KB\u0026#34; .byte 13,10,13,10 .ascii \u0026#34;HD Info\u0026#34; .byte 13,10 .ascii \u0026#34;Cylinders:\u0026#34; msg_heads: .ascii \u0026#34;Headers:\u0026#34; msg_sectors: .ascii \u0026#34;Sectors:\u0026#34; .org 510 boot_flag: .word 0xAA55   我们可以得到结果（我第一次试的时候不会弹两个窗口，但是第一次运行得到的数据出错）\n第一次运行：\n第二次运行\n对第二次分析\nmemory size = 3c00KB+1MB=16MB\ncylinders=00cc（H）=204（D）\n一些问题：\n首要问题 还是对汇编各种寄存器操作比较陌生，但还好慢慢啃，也能明白10%，知道基本的用法，需要抽时间好好学汇编。目前问题就是为什么有些寄存器能直接获得某些值，而不用赋值。不明白各种寄存器的用法和它本身会自己进行的操作有哪些。（提的问题也比较模糊，因为确实对汇编了解过少）例如为什么要把cs的值赋给es？之前也没有处理cs，他是代码寄存器，会默认存储代码段的地址吗？大概就是这类的问题。\n之前提到一个问题就是 为什么在bootsect.s中 mov ds，0x0000 是控制磁盘，而在setup.s中mov ax，0x0000却是中断向量表的位置。 答案：前者的是在int 0x13 即BIOS中断上操作的0x0000是对某个寄存器设置相应的值来获得某种功能进而控制磁盘，不是内存地址的0x0000。而setup.s的0x0000是内存的地址。\n","permalink":"http://Mrsdwang.github.io/oslab1/","tags":["操作系统"],"title":"操作系统的引导"},{"categories":null,"contents":"INT80, 电子科技大学信通学院本科生\n​\t正努力自学成为一位白帽子\n","permalink":"http://Mrsdwang.github.io/aboutme/","tags":null,"title":"About Me"},{"categories":null,"contents":"","permalink":"http://Mrsdwang.github.io/search/","tags":null,"title":"Search"}]