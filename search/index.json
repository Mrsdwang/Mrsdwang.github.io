[{"categories":["逆向"],"contents":"网上和论坛全是32位 老版本的010 editor破解的教程，没有64位版本，自己也需要用，可是软件太贵了，于是自己尝试了一下暴力和算法逆向写注册机两种方法进行破解。使用的版本是v12.0.1 64bit，在该博客发表时还是官网最新版。\n该博客仅用作个人技术学习交流，勿用于其余用途，请在自己经济条件允许的条件下支持正版。\n0x00 爆破法 把010 editor放入x64dbg运行起来，然后在tool-\u0026gt;register处随意输入序列号，此时会弹出对话框，再到x64dbg中搜索该字符串，于是可以跳转到认证序列号的代码处。\n如下图所示，当我们在使用该字符串的地址处打上断点，再次check license后就会在断点处停止\n在图中指令 mov edx,90 的上一条指令为jmp指令，如果程序从该指令以上执行下来的话便不会再执行图中的指令，那么我们可以推测程序存在某处跳转，让程序从mov edx,90指令 开始执行，如是查看 mov edx,90的交叉引用，如下图所示\n在地址7FF7F967574F处存在jne 7FF7F9675819，即跳转到mov edx,90处的指令\n那么继续往上看，地址7FF7F967574F处的jne是判断那两个数据不相同时才跳转\n如上图所示，若ebx不等于93那么就会跳转至弹出序列号不正确的代码处，如果相等则会判断edi是否等于73，如果等于则会弹出提示“密码正确，试用期延长”的窗口。我们在地址7FF7F967574F处打上断点，查看各使用的寄存器的值，以此判断是在哪些地方发生了跳转\n可以发现，edi = 117 != ED != 20C因此会直接运行到cmp ebx,93处，而此时ebx=E7 !=93，因此发生了跳转，而且edi = 117 !=71，但cmp edi,71处的跳转到的代码并不是我们所期望的，因此我们进追踪ebx有关的代码\n同时在地址7FF7F9675731处的上一条指令为jmp ，且跳转到我们并不需要的代码段处，因此可以判断该jmp在此次运行中并不会执行，那么就存在某处的jxx指令跳转到了地址7FF7F9675731，同样的查找交叉引用，发现地址7FF7F967559B处存在指令jne 7FF7F9675731，如下图所示\n可见在地址7FF7F967559B处 会判断edi是否等于EB,等于则会表明序列号正确，否则就会跳转至提示序列号错误的代码处。\n其实在这里我们就可以破解了，只需要在此处将edi改为DB即可，但这样我们每次都需要点击check license才行。\n再看地址7FF7F967558C处的 mov edi,eax 可以推测为前面的call 的函数的返回值给了edi用来判断是否等于DB，那么进入该函数分析一下，在函数开头打上断点，再次在010 editor 点击checklicense，发现程序并没有在该函数处停下来，那么我们的推测是错误的，那么就在地址7FF7F967558E与7FF7F9675595打上断点，并再次运行，会发现程序停在了7FF7F9675595处，那么肯定是存在跳转指令让程序跳转至此，直接查找交叉引用，我们可以溯源到如下图所示的代码处\n这里有两条跳转的指令，打上断点运行，判断是在从哪里跳转的\n我们需要让其在cmp edi,DB 处edi等于DB，使其不发生跳转，从而执行序列号判断正确的部分的代码，我们是从cmp edi,DB追踪edi到此，而在上图我们可以看到 在7FF7F967544A call的函数后 mov edi,eax 将返回值给了edi，那么这个edi是否就是后面cmp edi,DB会用的edi？我们打上断点，看看是否会运行这句，如果运行，该edi就会被用到cmp edi,DB，因为我们是从这里一路追踪，也只有该处更改了edi的值。\n经过测试，程序确实停在mov edi,eax处，如下图\n那么进入 7FF7F967544A处 call的函数进行分析即可\n此时RAX=E7，那么程序会跳转至7FF7F97CAE2C，那么我们查看该处代码\n可以发现这里的 eax = 177，与之前我们获取的edi = 177相同，那么此处也会存在 mov eax,DB的指令\n显然就是若该函数跳转至此那么就能使edi = DB，而跳转到该处的代码为下图\n那么我们只需要把7FF7F97CAD9D处的指令由je改为 jmp即可\n验证结果如下\n接着打补丁即可。\n0x01 逆向算法 从爆破法的破解过程我们可以发现关键函数，并且要求关键函数返回0xDB，进入关键函数查看，函数内部如图\n只有当地址7FF5EF9AD95处call的函数返回值为0x2D才能让该关键函数返回值为0xDB，那么推测序列号加密算法以及判断序列号是否正确的代码就在该7FF75EC118函数里。进入函数进行查看。\n在后面的调试可以发现在如下指令下进行了判断Name字符串以及Password字符串是否为空，寄存器rax+4分别保存着Name和Password两个字符串的长度数据，可以看到分别为0x3，0x18，转为十进制后大小与实际字符串长度相同\n并且进入地址7FFC6C84CA341处call的函数调试可知，其两个两个的取出了Password中的字符串进行运算，运算结果保存在了rdx的地址中，在之后会使用。\n可以判断该处代码正在进行Password的编码，那么该处大概率进行序列号正确的判断，进入函数7FF6C8185650进行调试，发现由两部分代码都是在重复的做某件事，\n第一部分\n进入图中 call的9QByteRef函数进行查看，可以发现这部分代码就是在判断Password每间隔4个字母是否为“-”，还可以发现这部分代码只有mov dword ptr ss:[rbp-18],X,不同，并且每次都是以大小5的幅度增加，由0x4增加到0x13，刚好判断了4个“-”\n继续往下调试会发现在做着重复的事情的第二部分代码\n进入函数BQBytreRef，跟踪调试，会发现其读取Password的数据存储在eax中，那么该函数的功能就是读取Password的单个字母\n再进入7FF6C818A1DC函数进行查看调试，会发现该函数根据al和dl寄存器的值（最初的值就是取出的Password的字母）进行判断，然后执行一些加减运算再存入eax中\n接着处理后的字母数据存入ebx，再执行shl bl,4，即把bl左移4位，接着再次调用BQByteRef的函数取出下一个Password的字母，然后对该字母再次通过函数7FF6C818A1DC对该字母进行处理，然后与上一次处理的字母以十六进制方式相加，并保存在rdi寄存器的地址中。\n该两部分代码都是在对Password进行编码处理，处理结果保存在rdi寄存器所保存的地址里。回到调用处理Password函数的代码处，即地址7FFC6C84CA341。\n我们将经算法处理后的Password数据定义为key[10]\n后面的汇编代码过于复杂，打开ida查看该处反编译得到的C代码会更容易分析。\nida查找到该处也是先找到关键字符串所在位置，即序列号识别成功后弹框的字符串，该部分代码如下图\n那么跳转至该处的关键为v17是否等于219，也就是0xDB，而v17变量值的来源如下图的函数\n进入sub_140084F4函数，会发现只有当v6 = 0x2D时才会返回219，因此可以判断该函数就为在x64dbg中我们所发现的关键函数，该函数在ida如下\n再进入sub_140006118函数查看，前面说到判断Name和Password的长度对应在C代码为\na1+8 为Name字符串数据的保存地址，a1+8+4就为Name的长度的数据，a1+16为Password字符串数据的保存地址，al+16+4就为Password的长度\n在x64dbg中地址为7FFC6C84CA341的call的函数对应到ida的函数为\n观察后面的do-while循环，我看不出这里做了什么，但是这里用到了对Password处理后的数据，似乎是在检验处理后的Password数据是否符合规定。因为这部分用到的变量并不影响后面的核心算法，因此不再分析。\n再看后面的赋值代码，由前面处理Password后的数据存放在\u0026amp;v41这个信息，以及根据ida创建变量时给的注释（v41 = [rbp-20h],v43 = [rbp-1eh]），我们可以判断Password处理后得到的数据以数组形式保存，数组起始地址为\u0026amp;v41，\u0026amp;v41-\u0026amp;v50为连续的地址，且都保存着相应地址上的处理后的数据，这也就是为什么之前我们定义为key[10]数组的原因。因此v13-v18就直接保存了经Password编码算法处理后得到的数据。\n为了验证，我们在x64dbg中查看程序运行到该处时的rbp-20h的数据，从dump中可以看到此处的数据与我们所推测的相同\n将Password通过编码算法处理后得的数据定义为key[10]数组，那么上述赋值就为v13 = key[7], v14 = key[5],v15 = key[2], v16 = key[1],v17 = key[0],v18 = key[3]\n再看switch(v44) 语句，可以判断只有当key[3]为0x9c，0xfc和0xac时才能进入第二段算法，因为该函数需要返回0x2D才能让关键函数返回0xBD，因此我们只关注能返回0x2D的分支。\n若要返回0x2D，那么该分支会跳转至LABEL_33处，那么0xfc的分支可以直接排除掉；0x9c分支并未使用key[8]与key[9]的数据，因此可以推断该分支只生成8Byte的Password；而0xac的分支使用了key[8]与key[9]，因此是可以生成10Byte的Password，我们只需分析其中一个分支就可以，这里我们分析key[3]=0xac的情况。\n这部分流程就是通过一些对key的一些数据进行计算后获取v23和v29两个主要变量，其中v23-1\u0026lt;=0x3E7，因此v23取值范围必须为[0x1,0x3E7]\n接着跳转到LABEL_26继续分析\nLOBYTE(v4)我们可以通过查看对应的汇编代码来理解其作用，这里0x0Fc是-4，那么就是使用rdx的低八位与-4相比较，如果不相等就将rsi的低八位置0。\n然后对Name进行一些格式的处理后保存在v24上，在函数sub_140004B88中传入了v24，推测是对Name字符串进行一些算法处理，进入该函数调试发现，该函数确实将Name的每个字符都进行了一些处理，并且还有一个很大的数组dword_140B34AD0保存着用来编码处理Name的数据。\n回到调用编码Name字符串函数的代码处继续分析，\n对于第一个if，我们对照汇编代码来理解，可以发现BYTE1、BYTE2、HIBYTE都是对v25进行右移后再判断\n第二个if，v18 == -100 ( 0x9c)，而我们执行的分支为v18 = 0xac因此不进入该if，同样对于if( v18 == -4 (0xfc))也跳过，因此该分支将会直接执行else if(v29)的代码，又因为我们必须渠道LABEL_33才能返回0x2D，因此v29必须大于v35\n我们追溯v35的值，发现其为加密算法函数的第三个传入参数，一直追溯到该函数调用时的汇编代码，我们可以发现，该函数的第三个参数大小为常数0x49C7\n因此v29需要大于0x49C7。\n那么以上就分析完了010 editor的算法流程\n0x02 注册机代码 在上述算法流程的分析过程我们可以发现两部分算法，第一部分是先对Password进行第一步处理获得key，然后判断key的第四个元素是不是0xac，是才能进入下一部分算法，第二部分算法先通过两个对key数据处理后得到两个变量，这两个变量再传入对Name编码的函数，这样Name和Password就产生了关系。\n我们需要反过来求key值，首先总结一下第二部分算法使用到的key值\n第一个算法为\n1 2  a1 = ((v23*0xb ^ 0x3421) - 19760)^0x7892 a1 = ((key[5]^key[2])+((key[7]^key[1])\u0026lt;\u0026lt;8))   第二个算法为\n1 2  a1 = (((((v29*0x11) ^ 0xffe53167) + 180597) ^ 0x22c078) ^ 0x5B8C27) \u0026amp; 0xffffff a1 = (key[6]^key[0])+((key[5]^key[9])\u0026lt;\u0026lt;16)+((key[8]^key[4])\u0026lt;\u0026lt;8)   再看对Name进行编码的算法函数使用的参数为v24(转换格式后的Name字符串)、v4 = 1(因v18!=-4)、v22 = v29、(a1+48)=v23，并且编码后的数据赋予v25，然后在判断v25的低8位、低16位、高32位、高64位是否分别等于key[4]、key[5]、key[6]、key[7]，\n而我们所执行的分支要求必须相等，因此我们也就可以对Name编码后求出key[4 - 7]的数据。\n当我们获得key[4 - 7]的数据后，就可以再通过逆向求解对key数据编码的两个算法就能获得其余key的数据，但是这里有一个问题，就是我们缺少v29 以及 v23两个关键数据进行算法逆向计算。\n在之前的流程分析，我们可以发现v23的取值在[0x1,0x3E7]之间，v29必须大于0x49C7，那么我们只需要在两个变量的取值范围随机取值即可，可以给两个变量赋符合条件的常数，也可以通过rand() % 0x3E7获得v23，rand() + 0x49C8获得v29。在这里我们直接给常数即可。\n到后面我发现v23 变量是一对Name和Password可以使用的用户数量，v29是和使用期限有关的数据。\n综上，注册机的思路理清，那么就可以开始写代码了。\n在此之前我们需要获取Name编码时所需要的大数组数据，我们通过x64dbg调试到编码Name的函数里(因为我们填的Name以及Password不能让程序执行到这，因此需要手动更改程序跳转条件，让程序能够执行到编码Name的函数)。我们在ida查看该数组会发现后面还接了0x34大小的0数据，因此我们在复制的时候还需要考虑这个细节。\n首先是对Name编码的算法，我们直接参照ida反编译的代码进行编写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  DWORD LockName[] = { 0x39CB44B8, 0x23754F67, 0x5F017211, 0x3EBB24DA, 0x351707C6, 0x63F9774B, 0x17827288, 0x0FE74821, 0x5B5F670F, 0x48315AE8, 0x785B7769, 0x2B7A1547, 0x38D11292, 0x42A11B32, 0x35332244, 0x77437B60, 0x1EAB3B10, 0x53810000, 0x1D0212AE, 0x6F0377A8, 0x43C03092, 0x2D3C0A8E, 0x62950CBF, 0x30F06FFA, 0x34F710E0, 0x28F417FB, 0x350D2F95, 0x5A361D5A, 0x15CC060B, 0x0AFD13CC, 0x28603BCF, 0x3371066B, 0x30CD14E4, 0x175D3A67, 0x6DD66A13, 0x2D3409F9, 0x581E7B82, 0x76526B99, 0x5C8D5188, 0x2C857971, 0x15F51FC0, 0x68CC0D11, 0x49F55E5C, 0x275E4364, 0x2D1E0DBC, 0x4CEE7CE3, 0x32555840, 0x112E2E08, 0x6978065A, 0x72921406, 0x314578E7, 0x175621B7, 0x40771DBF, 0x3FC238D6, 0x4A31128A, 0x2DAD036E, 0x41A069D6, 0x25400192, 0x00DD4667, 0x6AFC1F4F, 0x571040CE, 0x62FE66DF, 0x41DB4B3E, 0x3582231F, 0x55F6079A, 0x1CA70644, 0x1B1643D2, 0x3F7228C9, 0x5F141070, 0x3E1474AB, 0x444B256E, 0x537050D9, 0x0F42094B, 0x2FD820E6, 0x778B2E5E, 0x71176D02, 0x7FEA7A69, 0x5BB54628, 0x19BA6C71, 0x39763A99, 0x178D54CD, 0x01246E88, 0x3313537E, 0x2B8E2D17, 0x2A3D10BE, 0x59D10582, 0x37A163DB, 0x30D6489A, 0x6A215C46, 0x0E1C7A76, 0x1FC760E7, 0x79B80C65, 0x27F459B4, 0x799A7326, 0x50BA1782, 0x2A116D5C, 0x63866E1B, 0x3F920E3C, 0x55023490, 0x55B56089, 0x2C391FD1, 0x2F8035C2, 0x64FD2B7A, 0x4CE8759A, 0x518504F0, 0x799501A8, 0x3F5B2CAD, 0x38E60160, 0x637641D8, 0x33352A42, 0x51A22C19, 0x085C5851, 0x032917AB, 0x2B770AC7, 0x30AC77B3, 0x2BEC1907, 0x035202D0, 0x0FA933D3, 0x61255DF3, 0x22AD06BF, 0x58B86971, 0x5FCA0DE5, 0x700D6456, 0x56A973DB, 0x5AB759FD, 0x330E0BE2, 0x5B3C0DDD, 0x495D3C60, 0x53BD59A6, 0x4C5E6D91, 0x49D9318D, 0x103D5079, 0x61CE42E3, 0x7ED5121D, 0x14E160ED, 0x212D4EF2, 0x270133F0, 0x62435A96, 0x1FA75E8B, 0x6F092FBE, 0x4A000D49, 0x57AE1C70, 0x004E2477, 0x561E7E72, 0x468C0033, 0x5DCC2402, 0x78507AC6, 0x58AF24C7, 0x0DF62D34, 0x358A4708, 0x3CFB1E11, 0x2B71451C, 0x77A75295, 0x56890721, 0x0FEF75F3, 0x120F24F1, 0x01990AE7, 0x339C4452, 0x27A15B8E, 0x0BA7276D, 0x60DC1B7B, 0x4F4B7F82, 0x67DB7007, 0x4F4A57D9, 0x621252E8, 0x20532CFC, 0x6A390306, 0x18800423, 0x19F3778A, 0x462316F0, 0x56AE0937, 0x43C2675C, 0x65CA45FD, 0x0D604FF2, 0x0BFD22CB, 0x3AFE643B, 0x3BF67FA6, 0x44623579, 0x184031F8, 0x32174F97, 0x4C6A092A, 0x5FB50261, 0x01650174, 0x33634AF1, 0x712D18F4, 0x6E997169, 0x5DAB7AFE, 0x7C2B2EE8, 0x6EDB75B4, 0x5F836FB6, 0x3C2A6DD6, 0x292D05C2, 0x052244DB, 0x149A5F4F, 0x5D486540, 0x331D15EA, 0x4F456920, 0x483A699F, 0x3B450F05, 0x3B207C6C, 0x749D70FE, 0x417461F6, 0x62B031F1, 0x2750577B, 0x29131533, 0x588C3808, 0x1AEF3456, 0x0F3C00EC, 0x7DA74742, 0x4B797A6C, 0x5EBB3287, 0x786558B8, 0x00ED4FF2, 0x6269691E, 0x24A2255F, 0x62C11F7E, 0x2F8A7DCD, 0x643B17FE, 0x778318B8, 0x253B60FE, 0x34BB63A3, 0x5B03214F, 0x5F1571F4, 0x1A316E9F, 0x7ACF2704, 0x28896838, 0x18614677, 0x1BF569EB, 0x0BA85EC9, 0x6ACA6B46, 0x1E43422A, 0x514D5F0E, 0x413E018C, 0x307626E9, 0x01ED1DFA, 0x49F46F5A, 0x461B642B, 0x7D7007F2, 0x13652657, 0x6B160BC5, 0x65E04849, 0x1F526E1C, 0x5A0251B6, 0x2BD73F69, 0x2DBF7ACD, 0x51E63E80, 0x5CF2670F, 0x21CD0A03, 0x5CFF0261, 0x33AE061E, 0x3BB6345F, 0x5D814A75, 0x257B5DF4, 0x0A5C2C5B, 0x16A45527, 0x16F23945, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 }; int __fastcall EncodeName(const char * a1,char a3,char a4) { int v5; // ebp  int v6; // rax  int v7; // r13  int v8; // rbx  unsigned __int8 v9; // r14  unsigned __int8 v10; // si  unsigned __int8 v11; // r15  unsigned __int8 v12; // di  int v13; // eax  int v14; // r9  int v15; // er11  int v16; // r10  int v17; // ebp  int v18; // rcx  int v19; // rax  v5 = 0; v6 = -1; int lenOfname = 0; // 计算Name字符串长度  for (; a1[lenOfname]; lenOfname++); v7 = lenOfname; v9 = 0; v10 = (15 * a4)\u0026amp;0xff; //v10为8位整型，因此通过\u0026amp;0xff可取出低八位的数据  v11 = 0; v12 = (17 * a3)\u0026amp;0xff; for (int i = 0; i \u0026lt; v7; i++) { v13 = toupper(a1[i]); v14 = LockName[v12]; v15 = v5 + LockName[v13]; v16 = LockName[v10]; //这里只写了a2==1的分支，是因为我们所执行的分支中a2只会等于1  // ida反编译得到的代码转化成了unsigned __int8，因此这里也要\u0026amp;0xff取低八位  v17 = LockName[(v13 + 13) \u0026amp; 0xff]; v18 = (v13 + 47) \u0026amp; 0xff; v19 = v9; v12 += 9; v10 += 13; v9 += 19; v11 += 7; v5 = v16 + v14 + LockName[v19 ] + LockName[v18 ] * (v15 ^ v17); } return v5; }   当我们把Name编码并将数据返回给v25后，就可以通过key[4 - 7]与v25的关系求出key[4 - 7]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  char key[10]; key[3] = 0xac; //int v23 = rand() % 0x3E8; //al_48 = v23,而v23需要在[0x1，0x3E7]之间,我觉得给个常数就够了，并不需要rand int v23 = 0x89; //可使用该账号的人员数量 //int v29 = rand() + 0x49c8; //v29要大于v35 即49C7，也可以用一个满足要求的条件代替 int v29 = 0xffff; //一对Name和Password可使用的期限 char Name[100] = { 0 }; printf(\u0026#34;Name: \u0026#34;); scanf_s(\u0026#34;%s\u0026#34;, Name, 100); int v25 = EncodeName(Name,v29,v23); //通过 (v45 == (_BYTE)v25 \u0026amp;\u0026amp; (_BYTE)v14 == BYTE1(v25) \u0026amp;\u0026amp; v47 == BYTE2(v25) \u0026amp;\u0026amp; v48 == HIBYTE(v25)) = 1 关系求解key[4 - 7] for (int i = 0; i \u0026lt; 4; i++) { key[4 + i] = (v25 \u0026gt;\u0026gt; (i * 8)) \u0026amp; 0xff; }   求出key[4 - 7]后就可以把其余的key算出来了，我们先看第一个对key编码的算法，\n1 2  a1 = ((v23*0xb ^ 0x3421) - 19760)^0x7892 a1 = ((key[5]^key[2])+((key[7]^key[1])\u0026lt;\u0026lt;8))   通过第一个等式我们可以直接求出a1\n1  int fircall_var = (((v23 * 0xb) ^ 0x3421) - 19760) ^ 0x7892;   观察第二个等式我们可以发现，key[5] ^ key[2] 为a1的低八位，且key[5]是已知的，而key[7] ^ key[1]则左移8位到了高八位，且key[7]已知，可通过如下方法求出key[2]与key[1]\n1 2  key[2] = (fircall_var \u0026amp; 0xff) ^ key[5]; key[1] = ((fircall_var \u0026gt;\u0026gt; 8) \u0026amp; 0xff) ^ key[7];   对待第二个对key编码的算法同理，这就不再赘述，直接放代码\n1 2 3 4  int seccall_var = ((((v29 * 0x11) ^ 0xffe53167 )+ 180597) ^ 0x22c078 ^ 0x5b8c27) \u0026amp; 0xffffff; key[0] = (seccall_var \u0026amp; 0xff) ^ key[6]; key[8] = ((seccall_var \u0026gt;\u0026gt; 8) \u0026amp; 0xff) ^ key[4]; key[9] = ((seccall_var \u0026gt;\u0026gt; 16) \u0026amp; 0xff) ^ key[5];   那么注册机代码编写就完成了，结果如下\n0x03 忽略网络验证 我们会发现通过逆向得到的正确的Password 会失效，会弹出如下提示，\n并且我们再次进入x64dbg中发现的关键函数会发现程序的执行分支改变了\n程序在地址7FF79246AD83处并未发生跳转，并且eax = 113，退出该函数继续跟踪，我们会发现这样一个程序执行到了这样一个函数\n我们进入该函数，并且ida也跳转至该函数进行查看\nida查找该函数也是先搜索程序提示的字符串，然后发现进入该分支需要v19 = 0，因此给v19赋值的函数就为我们在x64dbg发现的函数，进入该函数分析，找到返回值为0以及返回值大于0的分支\n在该函数中关键的代码为下面几个if，\n第一个if条件为a2，但是我们发现a2传入的时候为0，且在函数内一直没被更改，因此第一个if并不执行，而return 0xffffffff 又是小于0的数，那么我们只需确保不会进入第二个if，并把0xffffffff 改为 0x1即可\n那么进入sub_14000AEED函数中，直接把返回值改为1，并把return 0xffffff改为0x1即可。\n更改完成后继续跟踪会发现程序将运行到一个分支跳转处，若该分支不跳转则会出现网络验证失败的警告。我们单步调试发现此处跳转了，如果我们之前并不更改网络验证的返回值为大于0的数，那么此处不会发生跳转。\n我们往下看，在地址7FF792315587处call了7FF7921284F4函数，这个函数就是前面需要返回0xDB的关键函数，此时发生跳转后将会再次执行该函数。\n调试进入关键函数，会发现他仍然执行了mov eax,113的指令，如果继续运行程序，那么程序将会弹出Password是无效错误的警告。解决该问题的办法就是在这个地方直接返回0xDB，因此我们直接将mov eax,113 改为 mov eax,0xDB即可.\n打上补丁再次运行即可忽略网络验证，并继续使用了。\n","permalink":"http://int80.top/010editorcracker/","tags":["逆向","破解"],"title":"010editor 最新V12版本逆向算法以及暴力破解"},{"categories":["逆向"],"contents":"PE文件基本概述 PE文件可分为PE头与PE体。DOS头到节区头都是PE头部份，其下节区合称为PE体，并且PE节区紧跟在NT头后。\n对于PE文件结构的分析，我们需要明确如下几个概念\n虚拟地址：内存中使用Virtual Address来表示位置，VA指的是进程虚拟内存的绝对地址。\n相对虚拟地址：要与虚拟地址区别开来，相对虚拟地址(Relative Virtual Address)指的是从某个基准位置(ImageBase)开始的相对地址。VA与RVA存在一个换算关系\n​ RVA + ImageBase = VA\n为什么要这样做？这样做有个好处，当PE文件的内部数据都以相对虚拟地址存在的时候，当文件从硬盘加载到内存，若加载出存在了文件，那么该文件就应该进行重定位，如果使用RVA，文件进行重定位后并不影响该文件数据的定位，因为此时只需要根据重定位的定制变更ImageBase就可以正常定位到所有原来的地址。如果是使用VA，当重定位后，每个地址都需要一起改变，否则就会定位失败，读取不到正确的信息。\n映像(Image)：PE文件加载到内存时，文件不会全部加载，而是根据节区头起始地址、节区大小等属性值来加载。因此内存和磁盘中的PE具有不同的形态。把加载到内存的形态称为映像加以区别。\n节：节是PE文件中代码或数据的基本单位。可分为三个大类，代码(.text)、数据(.data)、资源(.src)节。\n最小基本单位：我们知道内存中的数据存放时是按照最小基本单位的倍数进行放入，也就是段、页的概念，如果数据被按照这样存入内存，当数据的大小不能刚好填充满最小基本单位的倍数时，就会用NULL填充，因此在PE头与各节区的尾部都存在一个区域，称为NULL填充。最小基本单位是为了提高处理文件、内存、网络包的效率。具体可以自行去了解。\n各节区头定义了各节区在文件或内存中的大小、位置、属性等。\n需特别说明，在Intel的CPU以小端序保存数据，即高位字节保存在高位地址\nDOS头 DOS头存在的目的是为了让PE文件兼容DOS文件。\nDOS头为一个名为IMAGE_DOS_HEADER的结构体，用来扩展已有的DOS EXE头\n该结构体总共64字节，成员有19个，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  （最左边是文件头的偏移量。） IMAGE_DOS_HEADER STRUCT { +0h WORD e_magic // MZ(4Dh 5Ah) DOS可执行文件标记 +2h WORD e_cblp +4h WORD e_cp +6h WORD e_crlc +8h WORD e_cparhdr +0ah WORD e_minalloc +0ch WORD e_maxalloc +0eh WORD e_ss +10h WORD e_sp +12h WORD e_csum +14h WORD e_ip +16h WORD e_cs +18h WORD e_lfarlc +1ah WORD e_ovno +1ch WORD e_res[4] +24h WORD e_oemid +26h WORD e_oeminfo +29h WORD e_res2[10] +3ch DWORD e_lfanew ``// RVA 指向PE文件头 } IMAGE_DOS_HEADER ENDS   但我们只需要了解两个成员即可。\n分别是\ne_magic：DOS签名(DOS signature：4D5A=\u0026gt;ASCII值\u0026quot;MZ\u0026quot;)，固定为MZ，MZ为MS-DOS的设计者Mark Zbikowski的缩写\ne_lfanew：指示NT头的偏移，不同文件值可能不同。\n其余的参数都是在MS-DOS下运行改成需要用的到。\ne_lfanew的偏移为0x3C，第60个字节，我们可以看到其保存了一个地址E0，而这个地址就是PE文件的开始的位置，并且这个地址的数据默认为\u0026quot;PE00\u0026quot;，我们后面会进行更详细讲解。\nDOS存根 在DOS头后面紧接着就是MS-DOS程序。被称为DOS存根，是可选项，即有没有DOS存根程序都可以运行，并且其大小不固定。\n40-4D区域为16位的汇编指令，一个可执行文件在Windows中由于被识别为PE文件，所以DOS存根的代码不被执行；在DOS环境下运行即可执行该代码。该段汇编代码就是输出\u0026quot;This program cannot be run in DOS mode（此程序不能在DOS模式下运行）”这条消息，然后终止程序。\n我们可以通过对DOS存根的修改，在EXE文件中创造出另一个文件，使它能在DOS和Windows都能运行，但分别运行的是16位DOS代码，32或64位window代码\n若希望程序尽可能小，可以把DOS存根删除。\nNT头 DOS存根后紧接着NT头\nNT头为一个IMAGE_NT_HEADERS结构体，大小为F8\n1 2 3 4 5 6  IMAGE_NT_HEADERS STRUCT { DWORD Signature IMAGE_FILE_HEADER FileHeader //偏移0x04  IMAGE_OPTIONAL_HEADER32 OptionalHeader //偏移0x18 } IMAGE_NT_HEADERS ENDS   Signature成员被设置为4550=\u0026gt;ASCII码为\u0026quot;PE00\u0026quot;，Signature的地址也即NT头开始的地址，在DOS头的e_lfanew中表明了。\n另外两个成员分别是文件头与可选头\nNT头：文件头 1 2 3 4 5 6 7 8 9 10  struct IMAGE_FILE_HEADER { WORD Machine; //运行平台  WORD NumberOfSections; //区块表的个数  DWORD TimeDataStamp;//文件创建时间，是从1970年至今的秒数  DWORD PointerToSymbolicTable;//指向符号表的指针  DWORD NumberOfSymbols;//符号表的数目  WORD SizeOfOptionalHeader;//IMAGE_NT_HEADERS结构中OptionHeader成员的大小，对于win32平台这个值通常是0x00e0  WORD Characteristics;//文件的属性值 偏移为0x12 }     Mechine 成员是根据每个CPU拥有的唯一的Machine码进行填写，在winnt.h文件中定义了每个CPU对应的Machine码\n  NumberOfSection 为节区的数量，该值一定要大于0，并且如果与实际的节区数量不同会产生错误，Windows加载器限制的节的数量最大为96\n  TimeDateStamp 用于说明该文件被创建的时间\n  PointerToSymbolicTable 已经被废除\n  SizeOfOptionalHeader 值用来指出为可选头IMAGE_OPTIONAL_HEADER32结构体的长度，但结构体设置的时候大小已经固定，这样做的原因是Windows的PE装载器需要查看该成员的值，从而识别出IMAGE_OPTIONAL_HEADER32结构体的大小，并且PE32+使用的IMAGE_OPTIONAL_HEADER64大小与PE32的IMAGE_OPTIONAL_HEADER32不同，需要用该成员变量的值进行指示说明。对于32位来说其值是224字节，对于64位来说是240字节。\n  Characteristics 用来标识文件的属性，即文件是否是可运行状态，是否为DLL文件等信息，通过BIT OR进行组合。需要特别记住0002h和2000h两个值，分别代表文件是可执行的，文件是DLL类型\n  前四个字节为Signature，文件头从E5开始F8结束。我们一对一的进行分析\n  Machine码的值为0x014C，查看宏定义，其代表的是Intel386或后继CPU及其兼容的CPU\n  NumberOfSection为0x0003，节区数量为3，我们用PE编辑器查看，节区数量确实为3\n   TimeDataTemp为0x48025287\n  后面全为0的8个字节分别是PointerToSymbolTable**，**NumberOfSymbols\n  SizeOfOptionalHeader的值为0x00E0，十进制为224。\n  Characteristics为0x010F，该值为IMAGE_FILE_RELOCS_STRIPPED | IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_LINE_NUMS_STRIPPED | IMAGE_FILE_LOCAL_SYMS_STRIPPED | IMAGE_FILE_32BIT_MACHINE宏定义的值相或得到的结果\n  NT头：可选头 1 2 3 4 5 6  typedef struct _IMAGE_DATA_DIRECTORY{ DWORD VirtualAddress; DWORD Size; } IMAGE_DATA_DIRECTIORY, *PIMAGE_DATA_DIRECTORY; #define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  typedef struct _IMAGE_OPTIONAL_HEADER { //  // Standard fields.  //  WORD Magic; // 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）  BYTE MajorLinkerVersion; // 链接程序的主版本号  BYTE MinorLinkerVersion; // 链接程序的次版本号  DWORD SizeOfCode; // 所有含代码的节的总大小  DWORD SizeOfInitializedData; // 所有含已初始化数据的节的总大小  DWORD SizeOfUninitializedData; // 所有含未初始化数据的节的大小  DWORD AddressOfEntryPoint; // 程序执行入口RVA  DWORD BaseOfCode; // 代码的区块的起始RVA  DWORD BaseOfData; // 数据的区块的起始RVA  //NT additional fields. 以下是属于NT结构增加的领域。  DWORD ImageBase; // 程序的首选装载地址  DWORD SectionAlignment; // 内存中的区块的对齐大小  DWORD FileAlignment; // 文件中的区块的对齐大小  WORD MajorOperatingSystemVersion; // 要求操作系统最低版本号的主版本号  WORD MinorOperatingSystemVersion; // 要求操作系统最低版本号的副版本号  WORD MajorImageVersion; // 可运行于操作系统的主版本号  WORD MinorImageVersion; // 可运行于操作系统的次版本号  WORD MajorSubsystemVersion; // 要求最低子系统版本的主版本号  WORD MinorSubsystemVersion; // 要求最低子系统版本的次版本号  DWORD Win32VersionValue; // 莫须有字段，不被病毒利用的话一般为0  DWORD SizeOfImage; // 映像装入内存后的总尺寸  DWORD SizeOfHeaders; // 所有头 + 区块表的尺寸大小  DWORD CheckSum; // 映像的校检和  WORD Subsystem; // 可执行文件期望的子系统  WORD DllCharacteristics; // DllMain()函数何时被调用，默认为 0  DWORD SizeOfStackReserve; // 初始化时的栈大小  DWORD SizeOfStackCommit; // 初始化时实际提交的栈大小  DWORD SizeOfHeapReserve; // 初始化时保留的堆大小  DWORD SizeOfHeapCommit; // 初始化时实际提交的堆大小  DWORD LoaderFlags; // 与调试有关，默认为 0  DWORD NumberOfRvaAndSizes; // 下边数据目录的项数，这个字段自Windows NT 发布以来一直是16，到这个成员共偏移0x5c  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; // 数据目录表 } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;   在IMAGE_OPTIONAL_HEADER32结构体中，需要特别注意下面的成员\n  Magic 可执行文件得可选头结构体为IMAGE_OPTIONAL_HEADER32结构体的时候是10B，为IMAGE_OPIONAL_HEADER64结构体的时候为20B。ROM镜像就把B改为7.\n  AddressOfEntryPoint 持有程序入口点(EntryPoint)的RVA值，用来指出程序最先执行的代码的起始地址。为0的时候就从ImageBase地址执行。对于DLL文件来说是可选的\n  ImageBase 用来指出文件优先装入的地址，即程序装入内存后的第一个字节的首选地址，必须为64K的倍数。DLL默认为10000000H，EXE默认为00400000H。当文件载入内存后，EIP寄存器会设置为ImageBase+AddressOfEntryPoint\n  SectionAlignment，FileAlignment 其中的FileAlignment指定了节区在磁盘文件中的最小单位，值应该为200h到10000h之间的2的幂；而SectionAlignment指定了节区在内存中的最小单位，其必须大于等于FileAlignment的值。一个文件中SectionAlignment和FileAlignment的值可能相同也可能不相同。这两个量的值与之前说过的内存中最小基本单元的概念相同，节区在文件和内存所占的空间必须为FileAlignment和SectionAlignment的整数倍\n  SizeOfImage 当PE文件被加载到内存中的时候，加载的文件大小与整个文件的大小不同，该值就指定了Image在虚拟内存所占的大小，必须为SectionAlignment的倍数。\n  SizeOfHeaders 用来指出整个PE头的大小，该值必须是FileAlignment大小的整数倍。第一个节区相对该文件开始的地址的偏移量就是这个值的大小。向上舍入为FileAlignment的整数倍。PE头大小的计算方式为\n1  SizeOfHeaders = [e_lfanew /*DOS头部*/ + 4 /*PE签名*/ + sizeof(IMAGE_FILE_HEADER) + SizeOfOptionalHeader /*NT头*/ + sizeof(IMAGE_SECTION_HEADER) * NumberOfSections /*节区头的大小*/]/ FileAlignment * FileAlignment + FileAlignment;     Subsystem 该值用来区分系统驱动文件(*.sys)和普通可执行文件(*.exe)。值为1代表系统驱动(Drive)文件，2代表窗口应用程序GUI文件，3代表控制台应用程序CUI文件\n  NumberOfRvaAndSizes 用来指定DataDirectory数组的长度，翻看前面的结构体定义我们会发现DataDirectory的长度是用了一个宏IMAGE_NUMBER_DIRECTORY_ENTRIES来定义的，长度为16。但这个值同样也用来指定DataDirectory的长度，不会冲突吗？PE装载器是通过该值来识别数组的大小，因此DataDirectory的长度可以不是16\n  DataDirectory 是IMAGE_DATA_DIRECTORY结构体组成的数组，也就是结构体数组，其结构体的定义也在该节开始处给出了。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  DataDirectory[0] = EXPORT Directory //导出表的地址和大小 DataDirectory[1] = IMPORT Directory //导入表的地址和大小 DataDirectory[2] = RESOURCE Directory //资源表的地址和大小 DataDirectory[3] = EXCEPTION Directory\t//异常表的地址和大小 DataDirectory[4] = SECURITY Directory //证书表的地址和大小 DataDirectory[5] = BASERELOC Directory //基址重定位表的地址和大小 DataDirectory[6] = DEBUG Directory //调试信息的起始地址和大小 DataDirectory[7] = COPYRIGHT Directory //特定于体系结构数据的地址和大小 DataDirectory[8] = GLOBALPTR Directory //全局指针寄存器相对虚拟地址 DataDirectory[9] = TLS Directory //(线程本地存储)TLS表的地址和大小 DataDirectory[A] = LOAD_CONFIG Directory //加载配置表地址和大小 DataDirectory[B] = BOUND_IMPORT Directory //绑定导入表的地址和大小 DataDirectory[C] = IAT Directory //导入地址表的地址和大小 DataDirectory[D] = DELAY_IMPORT Directory //延迟导入表的地址和大小 DataDirectory[E] = COM_DESCRIPTOR Directory //CLR运行时头部数据地址和大小 DataDirectory[F] = Reserved Directory //保留   其中最重要的是EXPORT和IMPORT Directory，前者是存放了EDT 导出目录表的虚拟地址和大小，从该文件导出的函数；后者是存放IDT导入目录表的虚拟地址和大小，从其余文件导入的函数。\n上图是可选头的数据，总共0xE0的大小，我们对上面提到的几个较为重要的值进行分析\n最开始的两个字节0x010B就是Magic的值，\n  AddressOfEntryPoint从108h处开始到10Bh总共4个字节，为0x739D，即该程序的入口地址的虚拟地址为0x0000739D\n  ImageBase从114h开始到117h，值为0x01000000。\n  SectionAlignment从118h到11Bh，值为0x00001000，所以节区在内存存放时要按照1000的倍数进行对齐存储\n  FileAlignment从11Ch到11Fh，值为0x000002000，所以节区在磁盘存放时要按照200的倍数进行对齐\n  SizeOfImage从130h到133h，值为0x00014000，当文件加载到内存后的总体大小，14000h也为1000h(SectionAlignment)的整数倍\n  SizeOfHeaders 从134h到137h，值为0x00000400，即PE头的大小\n  NumberOfDirectories 从154h到157h，值为0x00000010，是十六进制，换成十进制就为16\n  后面每八个字节就是DataDirectory数组的一个元素，前四个字节为相应的Directory的虚拟地址，后四个为该Directory的大小。在这里EXPORT Directory的虚拟地址从158h到15Bh，全为0；其size从15Ch到15Fh，为0。IMPORT Directory的虚拟地址从160h到163h，为0x00007604，size从164h到167h，为0x000000C8.\n节区头 定义节区头的结构体为IMAGE_SECTION_HEADER，包括了对应节的具体位置、长度、属性信息。总共0x24大小\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #define IMAGE_SIZEOF_SHORT_NAME 8 typedef struct _IMAGE_SECTION_HEADER { BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; // 节表名称,如“.text”  //IMAGE_SIZEOF_SHORT_NAME=8  union { DWORD PhysicalAddress; // 物理地址  DWORD VirtualSize; // 真实长度，这两个值是一个联合结构，可以使用其中的任何一个，一般是取后一个  } Misc; //偏移0x08  DWORD VirtualAddress; // 节区的 RVA 地址  DWORD SizeOfRawData; // 在文件中对齐后的尺寸  DWORD PointerToRawData; // 在文件中的偏移量  DWORD PointerToRelocations; // 在OBJ文件中使用，重定位的偏移  DWORD PointerToLinenumbers; // 行号表的偏移（供调试使用地)  WORD NumberOfRelocations; // 在OBJ文件中使用，重定位项数目  WORD NumberOfLinenumbers; // 行号表中行号的数目  DWORD Characteristics; // 节属性如可读，可写，可执行等 偏移0x24 } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;    Name 是一个8字节的ASCII字符串，但并没有\u0026quot;必须用ASCII值\u0026quot;的限制，并且没有规范明确的节区name，因此Name成员不能保证其百分百就用作某种信息，.code名的也可能是数据节区。如果字符串不足8字节用0x00填充，且并不遵守必须以\u0026quot;\\0\u0026quot;进行结尾，如果不是\u0026quot;\\0\u0026quot;结尾，则会截取8个字节的长度进行处理。可执行文件不支持长度超过8字节的节名。对于支持超过字节长度的文件来说，此成员会包含斜杠\u0026quot;/\u0026quot;，并在后面跟随一个用ASCII表示的十进制数，该数字是字符串表的偏移量。 Misc.VirtualSize 这个成员指定了该节区装入内存后的总大小，如果该值大于SizeOfRawData的值，那么大出的部分用0x00进行填充。这个成员只对可执行文件有效，如果是OBJ文件，此成员为0. VirtualAddress 指定了该节区装入内存虚拟空间后的节区起始地址，这个地址是一个相对虚拟地址，一般为SectionAlignment的整数倍。他加上ImageBase才是真正的虚拟地址 SizeOfRawData 指定了该节区在硬盘上初始化数据的大小，必须是FileAlignment的整数倍，如果该部分仅包含未初始化的数据，那么这个值为0 PointerToRawData 指出该节区在硬盘文件中的地址，这个数值从文件开始算起的偏移量，也就是这个地址是一个文件偏移地址，磁盘文件中节区的起始位置，必须是FileAlignment的整数倍，如果包含未初始化的数据，该成员为0 Characteristics 指出该节区的属性特征，不同的数据位代表不同属性，多个属性通过bit OR进行组合  节区头紧跟在NT头后，可以理解为就是一个IMAGE_SECTION_HEADER的结构体数组，成员个数就被定义在IMAGE_FILE_HEADER中的NumberOfSection成员上，需要注意的是在最后一个节区头后最好应该有一个与节表同样大小的用0x00填充的空白数据。\n拿一个节区进行说明，\n  0x2E74657874000000=\u0026gt;ASCII=\u0026quot;.text\u0026quot;，为什么这里不是小端序的表示方式。因为数组在内存中是连续的，无论大端序还是小端序，存储顺序都相同\n  0x00007748为VirtualSize为内存中节区的大小，0x00001000为该节区在内存的起始相对虚拟地址\n  0x00007800 为SizeOfRawData，为节区在磁盘的大小，0x00000400为节区在磁盘的起始地址，是相对文件起始地址的偏移地址\n  在1FCh，0x60000020为Characteristics成员的值，是由IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ bitOR得到的\n  RVA to RAW 我们看到，当PE文件从磁盘加载到内存中会发生的变换。\n因此我们需要学习节区是如何完成内存地址与文件偏移间的映射换算，根据公式：\n​ RAW - PointerToRawData = RVA - VirtualAddress\n​\tRAW = RVA - VirtualAddress + PointerToRawData\n其中PointerToRawData 与 VirtualAddress 为节区头结构体中的成员\n举个例子：当RVA=ABA8时，File Offset = ？\n1 2  1. 首先查找RVA ABA8位于的节区，这里位于节区.data 2. 根据公式换算 RAW = ABA8(RVA) - 9000(VA) + 7C00(PointerToRawData) = 97A8   观察发现，ABA8在第二个节区，而97A8在第三个节区。这种就属于\u0026quot;无法定义与RVA相对应的RAW值\u0026quot;。这种情况是因为.data节区的VirtualSize值要比SizeOfRawData值大。\nIAT IAT(Import Address Table) 导入地址表，此部分是PE头非常困难也是非常重要的知识点\nDLL DLL(Dynamic Link Library)动态链接库，其是为了解决不同程序使用相同库而需要重复加载库的冗余操作，可以避免严重的内存和磁盘浪费。\nDLL的概念描述：\n 不要把库包含到程序中，单独组成DLL文件，需要时调用 内存映射技术使加载后的DLL代码、资源在多个进程中实现共享 更新库时只要替换相关的DLL文件即可，简单易行  加载DLL的方式有两种：第一种是\u0026quot;显式链接\u0026quot;，程序使用DLL时加载，使用完毕后释放内存。第二种时\u0026quot;隐式链接\u0026quot;，程序开始时即一同加载DLL，程序终止时再释放占用内存。\nIMAGE_IMPORT_DESCRIPTOR IMAGE_IMPORT_DESCRIPTOR导入表的结构体定义如下：\n1 2 3 4 5 6 7 8 9 10 11  typedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; DWORD OriginalFirstThunk; //导入名称表(INT)的RVA地址  } DUMMYUNIONNAME; DWORD TimeDateStamp; //时间戳多数情况可忽略 如果是0xFFFFFFFF表示IAT表被绑定为函数地址  DWORD ForwarderChain; DWORD Name; //导入DLL文件名的RVA地址  DWORD FirstThunk; //导入地址表(IAT)的RVA地址 } IMAGE_IMPORT_DESCRIPTOR; typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;   1 2 3 4 5 6 7 8 9 10  typedef struct _IMAGE_THUNK_DATA32 { union { DWORD ForwarderString; //PBYTE  DWORD Function; //PDWORD  DWORD Ordinal; DWORD AddressOfData; //PIMAGE_IMPORT_BY_NAME  } u1; } IMAGE_THUNK_DATA32; typedef IMAGE_THUNK_DATA32 *PIMAGE_THUNK_DATA32; //注：这个结构体是联合类型的，每一个成员都是4字节，所以为了编程方便，完全可以用一个4字节的数组取代它。   1 2 3 4 5 6  typedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; CHAR Name[1]; } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; //注：这个结构体由两个成员组成，大致一看它的大小是3个字节，其实它的大小是不固定的， //因为无法判断函数名的长度，所以最后一个成员是一个以0结尾的字符串。   PE文件使用来自其他DLL的代码或者数据，称为导入。当PE文件装入时，PE装载器的工作之一就是定位所有被导入的函数和数据，并且让正在被装载的文件可以使用这些地址。这个过程就是通过PE文件的导入表来完成。\n导入表保存的是函数名和其驻留的DLL名等动态链接所需的信息\n  OriginalFirstThunk 是一个4字节的RVA地址，指向导入名称表(INT)，INT是一个IMAGE_THUNK_DATA结构体数组，这个结构体最后一个成员内容为NULL时数组结束。数组的每一个结构体成员又指向了一个IMAGE_IMPORT_BY_NAME结构体，这个结构体包含两个成员函数序号和函数名，这个序号一般没什么用，有的编译器会把其置0，函数名可以当作一个以0结尾的字符串。(INT表地址不在DataDirectory中)\n  Name DLL名字的指针，是一个RVA地址，因为是DLL文件名字这个字符串的地址，因此这个地址指向了一个以0结尾的ASCII字符串\n  FirstThunk 是4字节RVA地址，指向了导入地址表(IAT)，这个IAT和INT也是一个IMAGE_THUNK_dATA结构体数组，不过它在程序载入前和载入后有两种状态，在程序载入前它的结构和内容和INT表一样，但却是两个不同的表，指向了IMAGE_IMPORT_BY_NAME结构体。在程序载入后，它的结构和INT表一样，但内容不同了，里面存放的都是导入函数的地址 。(IAT表地址在DataDirectory中)\n  IAT提供的机制与隐式链接有关\nGetModuleHandle函数位于KERNEL32.dll中，我们可以看到010073AC地址的这一指令MOV EDI,DWORD PTD DS:[\u0026lt;\u0026amp;KERNEL32.GetModuleHandleA\u0026gt;]，后面接着CALL EDI里的数据，也就是函数地址。\n这两句指令就是获取GetModuleHandleA函数的地址，然后调用它。可以看到EDI保存的是75740A60这个地址，这个地址保存在010010CC处，这里获取函数地址是通过读取该函数的地址所存放的地址，也就是读取IAT表中，存放的该函数的地址。为什么要这么绕一圈，而不是直接读取呢？\n这是因为不同系统上、不同版本的KERNERL32.dll，其里面的函数的地址都可能会发生变化，因此每次加载DLL时通过将函数地址写入固定的地址，就可以避免函数地址不同导致的错误。\nDLL重定位也是造成这一问题的原因，如果两个DLL的ImageBase都相同，当一个DLL先把该地址占用了，第二个DLL加载的时候就需要移动到其他的空闲内存空间。因此如果直接读取DLL函数地址，当DLL发生重定位后，函数地址就会改变。\n还有一个原因就是PE头中表示地址的时候使用的时RVA而不是VA\n综上三个原因，最大的问题就是硬编码无法保证能读取到正确的不断变化的函数地址，因此需要额外的不会变化的内存空间来保存函数地址。\n从上面我们操作可以看出，被调用的函数的地址所存放的地址就位于IAT数组的地址上，因此加载后的IAT数组存放的是函数的地址。\nEXE文件载入后对应的导入表结构图\n书上提到\u0026quot;INT中个元素的值为IMAGE_IMPORT_BY_NAME结构体指针(有时IAT也拥有相同值)\u0026quot;，网上资料和书上给的EXE文件载入前对应的导入表结构图如下图\n但我实际上用十六进制编辑器查看一个IMAGE_IMPORT_DESCRIPTOR的IAT和INT数组内容时，两者其实是不一样的。这部分我比较迷惑，IAT在加载前是不一定和INT一样都指向IMAGE_IMPORT_BY_NAME结构体数组吗，如果有错误还望得到指正\n首先通过DataDirectory找到Import Directory的地址，在前面对可选头学习的时候已经提到了，此处为00007604，这个为RVA地址，但是我们查看的是PE文件载入前的数据，因此需要从RVA换算成为RAW地址，7604 - 1000 + 400 = 6A04，6A04便是IMAGE_IMPORT_DESCRIPTOR结构体数组在磁盘中的起始位置，根据DataDirectory结构体中的Import Directory的Size数据可知，导入表的大小为C8，因此导入表的数据如下\n其中6A04h - 6417h为IMAGE_IMPORT_DESCRIPTOR结构体数组的第一个元素的数据，各个成员的值如下\n   文件偏移 成员 RVA RAW     6A04 OriginalFirstThunk(INT) 00007990 00006D90   6A10 Name 00007AAC 00006EAC   6A14 FirstThunk(IAT) 000012C4 000006C4    通过十六进制编辑器查看6D90和6C4的内容如下\nINT(RAW = 6D90)\nIAT(RAW = 6C4)\n两者的值并不相同。\n我们再通过Ollydbg，直接查看IAT数据，以如下图的函数为例\n我们在十六进制编辑器查看RAW = (010010CC - 01000000 - 1000 +400) = 4CCh的数据\n可以发现4CCh处的数据为7C80B731，与ollydbg的不同。\n我考虑到是不是这个用来练习的EXE文件有问题，于是换了一个EXE文件进行查看\n与之前同样的步骤，先从DataDirectory的获取IMPORT Directory的地址，在获得一个IMAGE_IMPORT_DESCRIPTOR结构体信息，这里就直接略过。\n其中INT的RVA为2074，转化为RAW为874。IAT的RVA为200C，转化为RAW为80C\nINT(RAW = 874)\nIAT(RAW = 80C)\n从这个EXE文件可以看到INT与IAT数据和长度相同，都指向了IMAGE_IMPORT_BY_NAME结构数组。\nEAT EAT是一种核心机制，可以使不同的应用程序可以调用库文件中提供的函数。也就是说，只有通过EAT才能准确求得相应库中导出函数的起始地址。\nPE文件中有且仅有一个用来说明EAT的IMAGE_EXPORT_DIRECTORY结构体。用来说明IAT的IMAGE_IMPORT_DESCRIPTOR结构体以数组形式存在，且拥有多个成员。是因为PE文件可以导入多个库\nIMAGE_EXPORT_DIRECTORY 1 2 3 4 5 6 7 8 9 10 11 12 13  typedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; // 未使用，总为0  DWORD TimeDateStamp; // 文件创建时间戳  WORD MajorVersion; //未使用，总为0  WORD MinorVersion; // 未使用，总为0  DWORD Name; //重要 指向一个代表此 DLL名字的 ASCII字符串的 RVA  DWORD Base; // 重要 函数的起始序号  DWORD NumberOfFunctions; // 重要 导出函数地址表的个数  DWORD NumberOfNames; // 重要 以函数名字导出的函数个数  DWORD AddressOfFunctions; // 重要 导出函数地址表RVA  DWORD AddressOfNames; //重要 导出函数名称表RVA  DWORD AddressOfNameOrdinals; //重要 导出函数序号表RVA } IMAGE_EXPORT_DIRECTORY, //PIMAGE_EXPORT_DIRECTORY;   前四个成员基本没有用，我们需要特别关注后面的成员。\n导出函数就是将功能提供给外部使用的函数，如果一个PE文件导出了函数，那么这个函数的信息就会记录在PE文件的导出表中，方便外部程序加载该文件进行动态调用。\n有时函数在导出表中只有一个序号而没有名字，也就造成了导出表中有了三个字表的存在，分别是导出地址表、导出函数名称表、导出函数序号表，这样外部就可以通过函数名称和函数序号两种方式获取该函数的地址\n AddressOfFunctions 4字节的RVA地址，可以用来定位导出表所有函数的地址表，这个地址表可以当作一个成员宽度为4的数组进行处理，长度由NumberOfFunctions进行限定，地址表中的成员也是一个RVA地址 AddressOfNames 4字节RVA地址，可以用来定位导出表中所有函数的名称表，可以用来当作成员宽度为4的数组进行处理，长度由NumberOfFunctions进行限定，在FileBuffer状态下需要进行RVA到RAW的转换才能真正找到函数名称 AddressOfNameOrdinals 这个值是一个4字节的RVA地址，他可以用来定位导出表中所有函数的序号表，这个序号表可以当作一个成员宽度为2的数组进行处理，它的长度由NumberOfNames进行限定，名称序号表的成员是一个函数序号，该序号用于通过名称获取函数地址。 NumberOfFunctions 这个值并不是真的函数数量，而是通过函数序号表中最大的序号减去最小的序号再加上1得到的，例如，一共导出3个函数，序号分别是：0、2、4，NumberOfFuctions = 4 - 0 + 1 = 5  通过导出表查找函数地址的两种方法：\n  通过函数名查找函数地址：\n 首先定位函数名表，然后通过函数名表中的RVA地址定位函数名，通过比对函数名获取目标函数名在函数名表中的索引 通过获取函数名表的索引获取函数序号表中对应索引中的数组元素，也就是函数序号 通过把该序号当作函数地址表的下标，就可以获得下表中的函数地址。  详细过程如下图\n   通过函数序号查找函数地址\n 首先计算函数地址表的索引：idx = 目标函数的函数序号 - 导出表的Base(结构体的一个成员) 通过计算出的索引就可以在函数地址表中获取到目标序号的函数地址。  此方法不需要使用函数名称表和函数序号表就可以直接获取函数地址。\n过程如下图\n  我们通过例子来熟悉导出表查找函数的过程\n 查找函数名称表  首先需要查到EXPORT Directory的RVA，然后转化成RAW。这一步就查看DataDirectory即可。跳过，得到的IMAGE_EXPORT_DIRECTORY的结构体数据如下\n查找函数名称并获得其在函数名称表的索引  NumberOfNames为 3B9，AddressOfNames 成员值为 RVA = 3538，RAW = 2938，查看该地址\n选择RVA = 4BBC =\u0026gt; RAW = 3FBD的数据进行查看，\n即为AddConsoleAliasA这个库函数的名称，其在函数名称表里索引为2.\n查看函数名称序号表  再将索引作为函数名称序号表的索引，并获取这个索引下数组的内容，这里AddressOfNameOrdinals 的 RVA 为441C =\u0026gt; RAW 为381C，查看函数名称索引表内容如下\n因为索引为2，因此在函数名称序号表读取数组第三个元素的值，为02\n通过函数地址表查找计算实际虚拟地址  AddressOfFunctions成员的值为RVA = 2654 =\u0026gt; RAW = 1A54，查看该地址数据如下\n获取的函数序号为02，查找函数地址表的第三个数组内容，RVA = 000326D9\n我们通过查看Kernel32.dll的ImageBase = 7C800000 (ImageBase的值存在可选头的结构体中)，然后计算AddConsoleAliasA函数的实际虚拟地址，(7C800000 + 326D9 = 7C8326D9)，使用Ollydbg查看0x7C8326D9地址的指令得到如图\n则该处就为AddConsoleAliasA函数的实际虚拟地址。\n结束 到此，PE文件结构就学习结束了，自己学习一段时间后再回过头来通过博客的方式复习和加强PE文件结构的知识点，为逆向进阶打好基础，但又因为时间缘故，还有其他较为重要的事情需要做，不能完成做一个自己的控制台PE查看器的任务。对于PE文件来说还有重定位表，绑定导入表，资源表等，我还没学！！！我学了我加上来！！！！写不动了！！！！学不动了！！！\n","permalink":"http://int80.top/pe_structure_analysis/","tags":["逆向"],"title":"PE文件结构解析"},{"categories":["逆向"],"contents":"第五题：\n**任务：**找到FLAG，也就是APP正确的账号密码\n步骤：\n先打开APP看看运行出现的东西，\n将apk用jadx打开，并查看com.example.test.MainActivity的代码\n其中可以发现关键的函数，即Encrypt.b ，Encrypt.a，getBytes\n后面的if中调用equals函数可知，该代码的作用就是对输入的账号密码通过Encrypt类的a和b函数进行加密，然后与正确的加密后的账号密码比对是否相等。\n那么只需要将bArr以及第一个equals中new byte[]的字节数组进行解码即可。\n首先查看Encrypt类\n加密的方法很简单，先将输入的账号密码和 i 进行异或，在调用Base64的库函数进行Base64编码。\n那么获得正确的账号密码的方法就很明显了，直接将程序中列出来的两个字节数组先进行Base64的解码，在和 相同的 i 进行异或即可。\n这里通过java来进行解密，还需了解一下 Base64库的decode函数的使用，就是喂一个字节数字数组，通过Base64加密返回一个 字节字符数组。\nJAVA解密代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package com.example.helloworld; import java.util.Base64; public class HelloWorld { public static void main(String[] args) { Base64.Decoder decoder = Base64.getDecoder(); byte[] data = {78, 106, 73, 49, 79, 122, 65, 51, 89, 71, 65, 117, 78, 106, 78, 109, 78, 122, 99, 55, 89, 109, 85, 61}; byte[] data1 = {89, 87, 66, 108, 79, 109, 90, 110, 78, 106, 65, 117, 79, 109, 74, 109, 78, 122, 65, 120, 79, 50, 89, 61}; byte[]bArr = decoder.decode(data); byte[]bArr1 = decoder.decode(data1); System.out.println(); int length = bArr.length; for (int i2 = 0; i2 \u0026lt; length; i2++) { bArr[i2] = (byte) (bArr[i2] ^ 3); bArr1[i2] = (byte) (bArr1[i2] ^ 3); } String res = new String(bArr); String res1 = new String(bArr1); System.out.println(res); System.out.println(res1); } }   程序输出得到：\n1 2  516834cc-50e448af bcf9ed53-9ae4328e   提交FLAG时需合并成：\n1  516834cc-50e448af-bcf9ed53-9ae4328e   第六题：\n一开始看到第六题的网址和第五题一样，还以为是网址放错了，但是几天后还没有更新，于是就考虑到是不是第六题的flag也在第五题给的APP中，于是反编译该app，得到的lib文件中存在libMylib.so文件，于是推测第六题flag在so文件里。\n我一开始打算用IDA动态调试so文件，但是一attach进程，APP就会直接关闭，我怀疑APP用了什么反调试方法，于是直接IDA打开so文件，查看是否有相关的反调试代码，结果并没有发现，反而发现了关键的产生flag的代码。\n用IDA打开libMylib.so文件，并查看EXPORTS窗口，导出的函数如下：\n双击JNI_Onload，并且翻到最顶，查看如下注释：\n查看标黑的，可以看到该so文件依赖了以上几个so库，并且这个so文件的名字为libMylib.so。我们需要注意libc.so这个依赖库，因为关键的函数从这个库里调用的。\n再次回到JNI_OnLoad函数处，将汇编转为C语言，如下：\n可以看到，该函数注册了MainActivity，并且在下面调用了一个all的函数，双击进去，会发现还有一个all函数被调用，再次进入，我们就能得到如下代码(只截图关键部分)\n第一个if，判断条件虽是数字，但其实是ASCII码，其意思就是判断abi是否是’x86‘，release-version是否为’9‘，接着打开了/data/2233文件，并且后面需要a+的权限，结合后面的fput，应该是要把一些数据写入该文件，那么还需要再/data处创建2233文件，此处需要root才能访问，也需要APP获得root权限才能写入。\n那么关键的就是如何绕过第一个if了，v16，v17的值为__system_property_get函数的返回值，因此我们需要对该函数进行hook，更改其返回值即可。\n因为hook需要知道该函数所在so文件，我们查看IMPORT窗口\n可以看到__system_property_get是从libc.so导入的。\n那么接下来用frida进行hook注入，注入代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  function main() { Java.perform(function(){ var str; var arg; //findExportByName是获得__system_property_get函数再libc.so中的地址  Interceptor.attach(Module.findExportByName(\u0026#34;libc.so\u0026#34;, \u0026#34;__system_property_get\u0026#34;), { onEnter: function (args) { //此处的args为函数调用时传入的参数  str = Memory.readCString(args[0]); //获得abi或version  arg = args[1]; //保存返回值的变量  if(str.indexOf(\u0026#39;ro.product.cpu.abi\u0026#39;)!=-1||str.indexOf(\u0026#39;ro.build.version.release\u0026#39;)!=-1){ //如果有这两个字符串  console.log(\u0026#34;now hook \u0026#34;+str) } }, onLeave: function (retval) { if(str.indexOf(\u0026#39;ro.product.cpu.abi\u0026#39;)!=-1){ var old_abi = Memory.readCString(arg); Memory.writeUtf8String(arg, \u0026#34;x86\u0026#34;); //直接向内存地址写入x86  var new_abi = Memory.readCString(arg); console.log(\u0026#39;old_abi is:\u0026#39;,old_abi,\u0026#39;new_abi is:\u0026#39;,new_abi); }else if(str.indexOf(\u0026#39;ro.build.version.release\u0026#39;)!=-1){ var old_ver = Memory.readCString(arg); Memory.writeUtf8String(arg, \u0026#34;9\u0026#34;); //直接向内存地址写入9  var new_ver = Memory.readCString(arg); console.log(\u0026#39;old_ver is:\u0026#39;,old_ver,\u0026#39;new_ver is:\u0026#39;,new_ver); } } }); }); } setImmediate(main);   打开APP，然后在命令行执行\n1  frida -U --no-pause -f com.example.test -l hook.js   frida运行后得到如下结果：\n检验是否hook成功，打开2233文件查看，结果如下：\n总共16行，那么根据第五题的结果，可以推测出flag为4行一组，’-‘隔开，结果为：\n1  b13981f4-5ae996d4-bc04be5b-34662a78   ","permalink":"http://int80.top/bili1024_21/","tags":["逆向"],"title":"B站1024逆向题"},{"categories":["Fuzz"],"contents":"任务：给AFL添加socket发包功能，使其支持测试DNS协议\n参考代码：\n因为不太方便直接贴出源码，所以就说明一下思路，记录一些实现 时遇到的错误。\n主要的问题有：\n 写了发包的函数，需要在哪里调用？ 如何解决超时的问题？如何及时杀死子进程？ 如何配置dnsmasq？？？？？？？？？（弄这玩意给我重装系统了）  需要了解的知识点：\n AFL大概的执行流程 AFL的从哪里获得输入文件 AFLmain函数的死循环在执行什么 target如何获取输入文件 fuzz dns的结果afl是通过什么 途径获取的 管道的概念  afl的main函数大概执行流程：\n通过read_testcases从输入文件夹读取所有文件，然后进行排队进行测试，然后调用add_to_queue函数创建queue_entry结构体作为输入文件队列，通过perform_dry_run函数第一次运行测试样例。进入死循环就循环将输入队列当前的输入文件丢入fuzz_one函数处理，该处理就是将种子变异并添加到输入队列里去。\nrun_target函数就是fork出一个子进程(fuzz的目标程序)进行fuzz。那么socket发包函数的调用就需要在这个位置。run_target函数被调用的地方存在于main函数死循环中的多个函数中，有calibrate_case函数等。\nsocket发包函数就在定时器设定好后面加即可。原因会在后面信号处理相关解释。\n既然要通过socket发送输入文件，那么从哪里获取输入文件呢？\nwrite_to_testcases函数就是用来写入到输入文件中的，该函数的参数为void *mem 和 u32 len，那么就定义两个个全局变量用来获取mem和len来给socket发送即可。\nsocket发包函数就是普通的socket client的代码，要注意的就是发送了输入文件后，就应该终止该子进程了，那么如何关闭呢？\n下面是对信号及信号量处理的解释（这是避免超时的解决办法）\nSIGTERM：\n程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和处理，通常用来要求程序自己正常退出。\n下面这段程序是在socket发包程序当中的。是在关闭了socket后，才运行来结束子进程的。\n第一个if用来判断子进程是否还存在，存在则通过kill函数传递SIGTERM信号告诉进程运行完了就快结束。\nwhile（1）作用是用来检验子进程是否还在运行，kill函数的第二个参数为0时，说明没有任何信号发送出去，但是系统会执行错误检查，通常利用第二个参数为0来检验某个进程是否在执行.当kill错误执行就会返回-1，并且errno会被赋值为ESRCH，即目标进程或进程组不存在。\n所以当发包，关闭socket后，执行该终止子进程的语句才能避免超时，才能在第一次perform_dry_run顺利通过。\n问题：但是如果没能杀死子程序不久进入死循环了吗？\n答：这就是后面设置定时器的原因，SIGTERM不一定能杀死程序，所以设置定时器来SIGKILL 子进程\n为什么send_over_network 要放在runtarget 设置好定时器后。\n因为AFL中定义了进程接收到信号SIGALRM后会执行的函数为\n即超时后会给子进程发送SIGKILL信号进行终止运行。而send_over_network 发包目标是子进程(target)，因此需要先设置好定时器，在子进程创建和运行超时时能及时kill掉避免过长时间的运行影响整体FUZZ的速度\n在run_target中还添加了第二个if，获取子进程终止的信号，因为我们在send_over_network中添加了kill 子进程的信号为SIGTERM 所以加入了这一句 FAULT_NONE，否则他将会直接返回FAULT_CRASH会产生错误的结果\n该次任务 只是实现了TCP的socket发包，那如果添加TCP和UDP的两种选项呢。\n有一种思路就是通过getopt添加命令行选项，并在case中添加相应的执行语句即可。例如输入参数为TCP:127.0.0.1，那么添加命令行选项-N ，那么命令行输入-N TCP:127.0.0.1 在case执行自己的拆解字符串的函数即可。socket发包的代码段添加if进行分支执行即可。\n最后结果：\n","permalink":"http://int80.top/afl_add_socket/","tags":["Fuzz"],"title":"AFL添加socket发包功能"},{"categories":["操作系统"],"contents":"lab3 一、任务内容  基于模板process.c编写多进程的样本程序，实现以下功能：  所有子进程都并行运行，每个子进程实际的运行时间不超过30秒 父进程向标准输出打印所有子进程的id，并且在所有子进程退出后才退出   实现进程运行轨迹的跟踪。在内核中维护一个日志文件process.log，把从操作系统启动到系统关机过程中所有进程的运行轨迹都记录在这一log文件中 统计log文件记录该程序建立的所有进程的等待时间，完成时间(轮转时间)和运行时间，计算平均等待时间，平均完成时间，和吞吐量。 修改进程调度的时间片，运行同样的样本程序统计同样的时间数据，和原有的情况对比，体会时间片带来的差异  二、明确进程的概念以及其生命周期内运行过程 那么何为进程呢？\n操作系统为正在运行的程序提供的抽象，就是进程，是操作系统提供的基本抽象\n非正式定义可以定义为，正在运行的程序。但程序本身是没有生命周期的，他只是存在磁盘上的一些指令或者静态数据，是操作系统让这些字节运行起来，让程序发挥作用。\n我们通过清点一个运行的程序在执行过程中访问或影响的系统的不同部分，从而概括一个进程。\n这里引入一个新的概念，进程的机器状态(machine state)：程序运行时可以读取或更新的内容。\n因此我们要关注，任何时刻下，机器哪些部分对执行该程序很重要。\n我们知道存放在内存的程序才能被运行，因此组成机器状态的重要的部分就是内存。指令存放在内存中，正在运行的程序读取和写入的数据也存在内存中，因此进程能访问的内存就是该进程的一部分。\n进程的机器状态另一部分就是寄存器。因为很多指令都是明确的读取或更新寄存器，所以寄存器对程序的执行很重要。\n进程创建的一些细节：\n操作系统运行程序第一件事就是讲代码和所有静态数据加载到内存中，加载到进程的地址空间中。\n早期操作系统中，加载这个过程需要尽早完成，即在运行程序之前全部完成。\n但随着现在程序越来越大，内存根本不可能一次性存放如此大的程序。你看现在的游戏都是10G以上，而我们的内存可能是8G,16G等，所以大多时候内存的大小无法载入整个程序。\n因此，现代操作系统惰性地(lazily)执行该过程，也就是仅在程序执行期间需要加载的代码或数据片段，才会加载到内存当中。换句话说我用谁我让谁进入内存，当内存满了之后我根据我的调度策略，将该换出去片段换出去，再把要用的片段加载进来。(这部分需要了解分页和交换的机制)\n当我们把程序载入到内存后，操作系统还会自动为程序分配运行时栈(run-time stack or stack)\n操作系统也可能会为程序的堆分配内存，这需要用户主动的显式的申请，例如malloc()这样的调用来申请空间，再通过free()释放内存。\n在UNIX系统中，每个程序都会有三个文件描述符，分别是标准输入stdin，标准输出stdout，标准错误stderr。所以操作系统还会初始化一些其他的任务，例如I/O相关的任务。\n完成上述任务后，PC指针就指向程序main函数入口地址，开始执行程序。\n总结就是：操作系统要执行一个程序，首先将代码和静态数据载入内存，通过创建和初始化栈及执行与I/O设置相关的其他工作，最后OS开始执行程序入口函数。\n我们这里简单提一下 堆和栈的区别：\n我接触到栈和堆的时候，是学习数据结构的时候，当时对堆的说明只是能够自动排序的一种数据结构。与数据结构不同，这里的堆分配方式类似于链表，因此获得的地址空间可以不连续\n在内存当中，\n栈是由系统自动分配自动释放(出栈时)，且地址空间连续。用于存放函数的参数值，局部变量的值。因为是机器自动执行，且是系统提供的数据结构，机器语言层有专门的执行指令，所以栈的执行效率更高于栈。其地址增长方向是，高地址向低地址增长\n堆一般由程序员分配释放，因此我们能申请任意多少的内存(受限于计算机系统中的虚拟内存)，动态内存的生存期也是由程序员自己决定的。如果在堆上分配的了内存地址就必须释放它，否则会导致运行的程序出现内存泄漏的情况。其地址增长的方向从下往上，即低地址向高地址增长。\n我们知道进程是不断切换着运行的，但是我们的内存和寄存器只能留给需要执行的程序，当我们切换进程的时候自然就会需要保存\u0026quot;现场\u0026quot;，那么当我们再次切换回来的时候才能让程序继续以切换之前的状态运行。所以操作系统充满了各种数据结构用来处理各种情况，在我们讨论的这个情况，操作系统就有一个称为进程控制块PCB(Process Control Block)的数据结构，用来存储关于进程的信息的个体结构。\n对于停止的进程，寄存器上下文(寄存器取值所基于的语境)将保存其寄存器的内容。所以当进程停止时，寄存器将被保存到这个内存位置。这句话可能说的不是特别清楚。\n当程序挂起的时候，我们观察的寄存器都是存放在内存中的寄存器的值，而不是物理寄存器当前的值，当我们修改寄存器的时候也是修改内存中的寄存器值。\n当线程切换时，系统会将要挂起线程的寄存器值保存到内存中，这个记录就被称为线程上下文，寄存器上下文即线程上下文的一部分。将现成的寄存器存放在内存中，称为上下文记录\n根据PCB记录\u0026quot;现场\u0026quot;，我们就能还原\u0026quot;现场\u0026quot;，实现进程的切换。\n至此，进程的一些基本内容就概述完成，那么我们该来想想如何才能创建多进程呢？\n我们需要调用fork()系统调用来创建子进程。这里对fork()进行一些概述\nfork()创建一个进程，该进程称为子进程，原进程称为父进程。当我们执行该调用，系统会分配出新的内存空间，并将父进程的所有值都复制给子进程，只有少量的值于原来的进程的值不同，以区分两个为不同的进程。我们可以理解是一个克隆。（这里提一点，如果我们不更改子进程的优先级，那他将和父进程的相同，我们也是通过父进程的优先级的值来赋值给子进程的时间片。）\n我们写的process.c代码，计划在里面创建4个进程，那你可能会想，哎？我创建了4个子进程，他们会执行什么程序？和父进程相同，所以他们也在执行父进程的程序吗？\n对的，子进程会从调用fork()的位置开始继续往下执行。也就相当于fork()只会拷贝下一段要执行的代码到子进程中。\n这里需要说一下fork()的特别的机制。\nfork()调用一次，并成功创建新进程，它能返回两个值，失败则返回一个负值(-1吧，不过这个暂时不重要)\n那么这两个值分别是什么呢？在父进程中，fork返回新创建子进程的进程ID，在子进程中，fork返回0.你可以这么理解，父子进程是一棵多叉树(只有一个子进程可理解成一串链表），父进程指向子进程的id，而子进程指没有指向则为0.\n所以我们会看到这样的判断\n1 2 3 4 5 6 7 8  pid_t pid; pid = fork(); if(pid!=0){ printf(\u0026#34;I am parent %d\u0026#34;,getppid()); } else if(pid==0){ printf(\u0026#34;I am child %d of parent %d\u0026#34;,getpid(),getppid()); }   然后屏幕两个输出都出现了，这里不用疑惑，我们还在执行另一个进程来跑相同的程序呢，父进程得到的是0，所以进入了第二个if，子进程得到的是他的进程id进入了第一个if，所以我们能看到两个输出都出现了。\n那么多进程创建就解决了，我们再来想想如何让父进程等待子进程全部结束后再结束呢？\n在这之前，我们需要知道为什么父进程会需要等待子进程结束再结束(当然，在这我们是想要他这么做，但也有值得这么做的理由)\n我们使用wait()系统调用，让父进程立即进入阻塞状态，然后wait()自动分析当前进程的某个子进程是否已经运行完成，当wait找到这样的僵尸子进程后，wait就会收集子进程的信息(例如退出原因)和回收子进程残留资源，并将该子进程彻底销毁后返回该进程的进程id。当wait一旦被调用，就会一直阻塞，直到有一个子进程退出为止\n何为僵尸子进程？\n当一个进程运行结束后，会关闭所有文件描述符，释放在用户空间分配的内存，但进程留在PCB的信息没有被同步删除。而执行完却没从PCB中删去进程信息的子进程称为僵尸子进程.\n那么为什么要删除僵尸进程呢？僵尸进程明明不做任何事，不会使用任何资源也不会影响其他进程了啊，为什么还要去管他呢。但PCB内的信息也都是存放在内存中的，如果存在太多僵尸进程也会导致一些问题。你可以想象一个工厂里面，有一些人啥也不做，你也不用支付工资，但人数多了后，仍让会导致你的工厂变得拥挤从而导致其他的人难以正常工作。\n所以回到原来的问题，我们通过wait()让父进程阻塞，等待全部子程序结束后再结束父进程。\n以上，我们创建多进程的程序就已经有了整体的框架和思路了。\n我们现在要考虑，如何创建一个日志呢？如何让他从操作系统启动后就跟着启动并开始记录进程的活动轨迹呢？\n容易想到，那我们在操作系统开机的时候就打开日志文件不就行了吗？对，确实是这样做，但问题在于要如何处理？\nLinux中，一切都能抽象为文件，那么对于一个打开的文件，我程序应该如何找到呢？完成这功能的便是通过文件描述符，所以我们要打开日志文件就需要关联文件描述符。我们知道，在Linux中文件描述符0、1、2分别关联了标准输入stdin、标准输出stdout和标准错误stderr，因此我们将文件描述符3关联到process.log日志文件即可。有一点需要注意，因为我们要今早打开日志文件记录所有进程的运行轨迹，我们需要将关联的代码提前到进程0运行还没创建进程1的时候就完成，这部分会在实践部分详细展开说。\n那么接下来就是我们要在什么地方加入写入日志文件的代码了。\n我们要清楚，进程，它能处于几种状态？可以认为其有三种状态\n运行：进程正在处理器上运行，进程在执行指令\n就绪：进程已经准备好运行，但操作系统因为一些原因并不打算在此时运行\n阻塞：一个进程执行了某种操作，知道发生其他事件时才会准备运行。例如一个进程需要操作IO设备时候，该进程就会进入阻塞状态，因为I/O设备反应时间远慢于CPU运行的速度，所以此时进程阻塞放出CPU的操作权，从而提高CPU的利用率\n但我们在这里再加上两个状态：创建和退出\n我们用如下字母进行替代：新建(N),就绪(J),运行(R),阻塞(W),退出(E)\n最后我们就要考虑，再哪些位置进行进程的监测，并把检测信息输入到日志文件中。\n因为fork()系统调用后，进入内核，所以进程的轨迹的监测，我们需要在内核中完成，那么write()这个系统调用我们就没办法使用了，所以写数据进文件的函数，我们需要解决。因为这部分编程较为困难，就直接使用现成的代码。\n我们将重点放在在哪里进行进程轨迹监测。\n对于创建(N)，我们需要找到创建进程的函数copy_process()，其位于fork.c内核文件中，并在创建的时候将信息写入日志文件\n对于运行(R)，就绪(J)，阻塞(W)，我们需要考虑在涉及到调度策略的代码中进行，即内核文件中的sched.c\n退出(E)就考虑再内核文件中的exit.c文件中这种状态才会出现。\n三、实践部分 (代码是自己再打一遍的，可能会有一些人为错误，有的话还希望指出)\n首先先编写能生成多进程的程序process.c\n该程序包含两个部分，第一个部分是多进程创建的代码，第二部分是获取该进程使用CPU的时间以及模拟I/O操作的代码\n下面这段是第二部分代码：\n先放出第二部分代码是因为，第一部分的代码需要用到第二部分的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  /* * 此函数按照参数占用CPU和I/O时间 * last: 函数实际占用CPU和I/O的总时间，不含在就绪队列中的时间，\u0026gt;=0是必须的 * cpu_time: 一次连续占用CPU的时间，\u0026gt;=0是必须的 * io_time: 一次I/O消耗的时间，\u0026gt;=0是必须的 * 如果last \u0026gt; cpu_time + io_time，则往复多次占用CPU和I/O * 所有时间的单位为秒 */ void cpuio_bound(int last, int cpu_time, int io_time) { struct tms start_time, current_time; clock_t utime, stime; int sleep_time; while (last \u0026gt; 0) { /* CPU Burst ，指CPU执行指令的那一段时间区间*/ times(\u0026amp;start_time); /* 其实只有t.tms_utime才是真正的CPU时间。但我们是在模拟一个 * 只在用户状态运行的CPU大户，就像“for(;;);”。所以把t.tms_stime * 加上很合理。*/ /*用来模拟cpu_time时间内使用CPU */ do { times(\u0026amp;current_time); utime = current_time.tms_utime - start_time.tms_utime; stime = current_time.tms_stime - start_time.tms_stime; } while ( ( (utime + stime) / HZ ) \u0026lt; cpu_time ); last -= cpu_time; if (last \u0026lt;= 0 ) break; /* IO Burst ，指I/O设备被请求执行开始到执行结束的时间区间*/ /* 用sleep(1)模拟1秒钟的I/O操作 */ sleep_time=0; while (sleep_time \u0026lt; io_time) { sleep(1); sleep_time++; } last -= sleep_time; } }   cpuio_bound(10,1,1)意思为该进程，轮转一次使用CPU时间为1s，I/O设备占用时间1s，占用CPU和I/O时间总共为10秒\n下面是第一部分代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;time.h\u0026gt;#include \u0026lt;sys/times.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt; #define HZ\t100 #define CHILD_PROCESS_NUM 4 #define CHILD_RUN_TIME 30  void cpuio_bound(int last, int cpu_time, int io_time); /* 1. 所有子进程都并行运行,每个子进程的实际运行时间一般不超过30秒; 2. 父进程向标准输出打印所有子进程的id,并在所有子进程都退出后才退出; */ int main(int argc, char * argv[]) { pid_t pid; /*子进程 PID*/ int i=0; while(i\u0026lt;CHILD_PROCESS_NUM) { /*子进程*/ if((pid=fork())\u0026lt;0) /*fork 失败*/ { fprintf(stderr,\u0026#34;error in fork()\\n\u0026#34;); return -1; } /*成功创建子程序，子程序将执行下面的代码*/ else if(pid==0) { fprintf(stdout,\u0026#34;create new process [%lu]\\n\u0026#34;,(long)(pid)); cpuio_bound(CHILD_RUN_TIME,1,i);/*用i是为了不断改变I/O使用时间*/ exit(0); /*退出子程序*/ } /*父进程执行下面代码*/ else { fprintf(stdout,\u0026#34;child pid is [%d] and parent pid is [%d]\\n\u0026#34;,getpid(),getppid()); i++; } /*父进程继续循环fork*/ } /*等待所有子进程完成*/ /*因为当一个子进程结束后就会返回他的id，如果没有子进程就会返回-1，所以当要等待多个进程结束，就需要while((pid=wait(NULL))！=-1)，这样当所有子进程结束后，父进程才会结束运行 */ while((pid=wait(NULL)) != -1) { fprintf(stdout,\u0026#34;process [%lu] terminated\\n\u0026#34;,(long)(pid)); } return 0; }   那么我们创建多进程的程序完成，现在要考虑创建日志文件process.log。\n首先我们日志放在/var/process.log，作用使在每个进程发生状态切换的时候向log文件内写入一条记录，但因为在内核态写入，这个过程和用户态应用程序在一些细节上差别就很大。\n首先是打开log文件，我们是要让操作系统第一次调用fork()建立进程1的时候就开始记录了，那么我们log要在这之前打开才能记录进程1的信息。\n我们先查看操作系统第一次fork()的代码，内核入口为init/main.c 中的main()，里面有一段代码\n1 2 3 4 5 6  //... move_to_user_mode(); /*切换到用户模式*/ if(!fork()){ /* we count on this going ok */ init(); } //...   这段代码是在进程0运行的，首先要切换到用户模式，才全系统第一次调用fork()建立进程1，进程1调用init()函数，我们进入init()中查看\n1 2 3 4 5 6 7 8 9  //... /*加载文件系统 */ setup((void *) \u0026amp;drive_info); /*打开/dev/tty0，建立文件描述符0并和/dev/tty0相关联 */ (void) open(\u0026#34;/dev/tty0\u0026#34;,O_RDWR,0); /*让文件描述符1也和/dev/tty0关联*/ (void) dup(0); /*让文件描述符2也和/dev/tty0关联*/ (void) dup(0);   dup(oldfd)用来复制参数oldfd所指的文件描述符。当复制成功时，返回最小的尚未使用的文件描述符，若有错误就返回-1，错误代码存入errno中。返回的新文件描述符和参数oldfd指向同一个文件，这两个描述符共享同一个数据结构，共享所有的锁定，读写指针和各标志位。\n我们前面说过文件描述符分别代表了什么，这就不赘述。那么就应该紧接着建立文件描述符3和process.log日志文件相关联\n建立方式同tty0文件\n1 2  /*O_CREAT如果文件不存在就创建，并使用参数3设置权限；O_TRUNC若文件存在则清除文件内容并设置文件大小为0;O_WRONLY以只写方式打开文件；0666就是文件操作的权限值，和第二个参数有关*/ (void) open(\u0026#34;/var/process.log\u0026#34;,O_CREAT|O_TRUNC|O_WRONLY,0666);   我们知道init()函数是在fork()后才进行，为了能记录进程1，我们需要将文件描述符关联文件的这步放到fork()前面，但必须在move_to_user_mode();后，因为必须先移动到用户模式，才能加载文件系统，因此需要在这之后添加代码，不能再在前面添加了。因此更改后如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //... move_to_user_mode(); /*切换到用户模式*/ //... /*加载文件系统 */ setup((void *) \u0026amp;drive_info); /*打开/dev/tty0，建立文件描述符0并和/dev/tty0相关联 */ (void) open(\u0026#34;/dev/tty0\u0026#34;,O_RDWR,0); /*让文件描述符1也和/dev/tty0关联*/ (void) dup(0); /*让文件描述符2也和/dev/tty0关联*/ (void) dup(0); (void) open(\u0026#34;/var/process.log\u0026#34;,O_CREAT|O_TRUNC|O_WRONLY,0666) if(!fork()){ /* we count on this going ok */ init(); } //...   还要记得把init的这部分给注释掉，因为进程1继承了进程0这个父进程的绝大部分东西，所以进程1也会继承这些文件描述符.\n那么日志文件就能在全系统第一次调用fork()之前创建了，因此能监测各进程的各种状态变化了\n日志文件建立了，那是不是该考虑如何写入log文件了呢？之前说过我们在内核中切换进程，导致进程状态改变，也就是说所有的状态转移是在内核进行的，那么我们也得在内核向日志文件写入这些改变信息，但是我们在内核没有办法使用write()这个系统调用，所以我们要考虑自己写一个写入函数，就像printf()在内核中有个printk()来替代它的功能，我们就要写一个在内核使用的write()。\n因为内核函数的编写涉及到C内嵌汇编，编写难度较大，因此我们直接套用现成的代码，主要是参考printk()和sys_write()写出来的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  #include \u0026#34;linux/sched.h\u0026#34;#include \u0026#34;sys/stat.h\u0026#34; static char logbuf[1024]; int fprintk(int fd, const char *fmt, ...) { va_list args; int count; struct file * file; struct m_inode * inode; va_start(args, fmt); count=vsprintf(logbuf, fmt, args); va_end(args); /* 如果输出到stdout或stderr，直接调用sys_write即可 */ if (fd \u0026lt; 3) { __asm__(\u0026#34;push %%fs\\n\\t\u0026#34; \u0026#34;push %%ds\\n\\t\u0026#34; \u0026#34;pop %%fs\\n\\t\u0026#34; \u0026#34;pushl %0\\n\\t\u0026#34; /* 注意对于Windows环境来说，是_logbuf,下同 */ \u0026#34;pushl $logbuf\\n\\t\u0026#34; \u0026#34;pushl %1\\n\\t\u0026#34; /* 注意对于Windows环境来说，是_sys_write,下同 */ \u0026#34;call sys_write\\n\\t\u0026#34; \u0026#34;addl $8,%%esp\\n\\t\u0026#34; \u0026#34;popl %0\\n\\t\u0026#34; \u0026#34;pop %%fs\u0026#34; ::\u0026#34;r\u0026#34; (count),\u0026#34;r\u0026#34; (fd):\u0026#34;ax\u0026#34;,\u0026#34;cx\u0026#34;,\u0026#34;dx\u0026#34;); } else /* 假定\u0026gt;=3的描述符都与文件关联。事实上，还存在很多其它情况，这里并没有考虑。*/ { /* 从进程0的文件描述符表中得到文件句柄 */ if (!(file=task[0]-\u0026gt;filp[fd])) return 0; inode=file-\u0026gt;f_inode; __asm__(\u0026#34;push %%fs\\n\\t\u0026#34; \u0026#34;push %%ds\\n\\t\u0026#34; \u0026#34;pop %%fs\\n\\t\u0026#34; \u0026#34;pushl %0\\n\\t\u0026#34; \u0026#34;pushl $logbuf\\n\\t\u0026#34; \u0026#34;pushl %1\\n\\t\u0026#34; \u0026#34;pushl %2\\n\\t\u0026#34; \u0026#34;call file_write\\n\\t\u0026#34; \u0026#34;addl $12,%%esp\\n\\t\u0026#34; \u0026#34;popl %0\\n\\t\u0026#34; \u0026#34;pop %%fs\u0026#34; ::\u0026#34;r\u0026#34; (count),\u0026#34;r\u0026#34; (file),\u0026#34;r\u0026#34; (inode):\u0026#34;ax\u0026#34;,\u0026#34;cx\u0026#34;,\u0026#34;dx\u0026#34;); } return count; }   我们将改代码放入kernel/printk.c文件中即可。\nfprintk使用的格式有如下\n1 2 3 4 5  // 向stdout打印正在运行的进程的ID fprintk(1, \u0026#34;The ID of running process is %ld\u0026#34;, current-\u0026gt;pid); // 向log文件输出跟踪进程运行轨迹 fprintk(3, \u0026#34;%ld\\t%c\\t%ld\\n\u0026#34;, current-\u0026gt;pid, \u0026#39;R\u0026#39;, jiffies);   第一个参数为文件描述符，第二个参数作为字符串输出，就和printf使用是一样的，但是前面第一个参数用来指定文件描述符。\n我们还记录了进程切换，状态保持的一些时间，但是时间并不是我们常识的时间，而是以CPU时钟中断发生的次数，称为“滴答数”——jiffies\njiffies是定义在kernel/sched.c文件中定义为一个全局变量,记录了开机到当前时间的时钟中断次数\n1  long volatile jiffies=0;   在sched.c中sched_init()函数中，时钟中断函数被设置为\n1 2 3 4 5 6 7  set_intr_gate(0x20,\u0026amp;timer_interrupt); /*在kernel.system_call.s中timer_interrupt定义有如下和jiffies相关的指令 */ timer_interrupt: ! …… ! 增加jiffies计数值 incl jiffies ! ……   这也是jiffies能表示开机到现在发生的时钟中断次数的原因\n在kernel/sched.c中定义一个宏 LATCH时用来设置每次时钟中断间隔的\n1 2 3 4 5  // 在 kernel/sched.c 中 #define LATCH (1193180/HZ)  // 在 include/linux/sched.h 中 #define HZ 100   这个和计算机的定时芯片时钟频率有关。\n最重要的部分来了，我们如何寻找状态切换点呢？\n我们从每个状态转化的过程入手：\n首先先列出我们需要改动的文件：\nkernel/rork.c中的copy_process函数\nkernel/sched.c的schedule()，wake_up()，sleep_on()，interrupt_sleep_on()，sys_pause()，sys_waitpid()函数\nkernel/exit.c 的 do_exit()函数\n 无-\u0026gt;创建：  既然涉及到创建，那么我们就进入fork()去看，之前做的第二个实验我们知道系统调用里面才调用真正的内核函数，所以fork()里面会有一个sys_fork()来执行真正的系统调用，所以我们在sys_fork()寻找创建进程的函数\n1 2 3 4 5 6 7 8 9 10 11 12  sys_fork: call find_empty_process ! …… ! 传递一些参数 push %gs pushl %esi pushl %edi pushl %ebp pushl %eax ! 调用 copy_process 实现进程创建 call copy_process addl $20,%esp   那么copy_process便是真正创建子进程的函数了\n我们可以找到在这个函数中，创建了一个task_struct结构空间，然后将父进程各种信息赋值给新的结构空间，我们注意几个点就可以\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  int copy_process(int nr,……) { struct task_struct *p; // …… // 获得一个 task_struct 结构体空间  p = (struct task_struct *) get_free_page(); // ……  p-\u0026gt;pid = last_pid; // …… // 设置 start_time 为 jiffies  p-\u0026gt;start_time = jiffies; // …… /* 设置进程状态为就绪。所有就绪进程的状态都是 TASK_RUNNING(0），被全局变量 current 指向的 是正在运行的进程。*/ p-\u0026gt;state = TASK_RUNNING; return last_pid; }   我们添加在如下地方\n那么我们就能记录新子进程建立的id，状态为’N'，和CPU中断次数的信息了\n 新建-\u0026gt;就绪：  当子进程建立完成后，他就进入就绪状态，同一个文件下，那么我们在return last_pid；前一句加入写入log文件的语句即可。按道理来说新建子进程不会直接运行啊，应该还要等待schedule函数的调度才能到运行状态，我就不太明白为什么这段代码会把新建子进程的状态p-\u0026gt;state = TASK_RUNNING;（答案：Linux中统一ready(就绪态）和running(运行态）为TASK_RUNNING状态）\n 就绪-\u0026gt;运行 | 运行-\u0026gt;就绪：  就绪到运行，那么就需要执行schedule()函数，那么我们进入kernel/sched.c里面找到schedule()函数。但这个时候我们需要判断current这个当前这个进程是属于什么状态，如果是TASK_RUNNING状态就需要现将转为就绪态，然后通过switch_to(next)将任务队列的第一个进程变为TASK_RUNNING。因此我们再次这样添加语句\n 阻塞-\u0026gt;就绪：  同样是在schedule()函数里，在第三点代码段前面。有将阻塞态进程转为就绪态的函数(可能此时有操作I/O设备的进程完成了任务)，那么我们直接在他改为就绪态后添加语句即可\n同样我们还有一个wake_up()函数也能将阻塞态转为就绪态，因此我们还需要在该函数中添加，该函数用到了 p-\u0026gt;state！=0，0代表的是TASK_RUNNNING。\n 运行-\u0026gt;阻塞：  阻塞有两种情况，第一种为可被中断打断阻塞，第二种为不可被中断打断阻塞\n不可被中断打断阻塞。只能由wake_up显示唤醒，再由schedule()语句后的if(tmp) tmp-\u0026gt;state=0依次唤醒。不可中断的睡眠进程一定是严格从\u0026quot;队列\u0026quot;(一个依靠放在进程内核栈中的指针变量tmp维护的队列)的头部唤醒。\n可被中断打断阻塞，他除了被wake_up唤醒，也可以被发一个信号唤醒，实际上就是进程PCB中维护的一个向量的某一位置的位，当进程需要再合适的时候处理这一位来唤醒，在schedule()中\n1 2 3 4  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p) if (((*p)-\u0026gt;signal \u0026amp; ~(_BLOCKABLE \u0026amp; (*p)-\u0026gt;blocked)) \u0026amp;\u0026amp; (*p)-\u0026gt;state==TASK_INTERRUPTIBLE) (*p)-\u0026gt;state=TASK_RUNNING;//唤醒   就是当进程是可中断睡眠时，遇到一些信号就会被唤醒，这样会导致，唤醒等待队列中间的某个进程，那这个队列就会需要进行适当的调整，会继续让该进程睡眠，并唤醒排在前面的进程然后再将该进程唤醒。\n这就是两者的区别\n不可被中断打断阻塞的状态转换位于sleep_on()函数，也在sched.c文件中\ntmp指向当前进程的上一个被睡眠的进程，* p指向当前的进程，如果* p没有指向当前进程a，也就是说当前进程a前面又加入了一些进程bcd等，此时d的tmp-\u0026gt;c，c的tmp-\u0026gt;b，b的tmp-\u0026gt;a，tmp是每个进程私有的，而* p是全局变量，此时*p指向 d.\n所以schedule()要回到进程a的程序，需要等d的if(tmp执行)，c的if(tmp)，b的if(tmp)执行并被唤醒后，a的schedule()才会回来并执行a的if(tmp)并唤醒a进程。\n该函数本意是失眠用的，那么我们就在current转换成阻塞态前加上该语句，此时睡眠队列头指针指向当前任务，当我们调用schedule后回到该程序继续执行if(tmp)的代码，将该进程变为就绪态。\n我们添加if就是为了避免一些情况导致某些进程重复被记录防止出错\n在interruptible_sleep_on()函数中\n我们是在其状态更改前写入日志文件，代码如下\n将当前任务放入等待队列中，同样该任务被唤醒后才能继续执行，如果* p指向的不是当前任务，说明其他任务加入进了等待队列，我们需要先唤醒前面的，等待后续进入队列的任务都被唤醒执行后再来唤醒本任务，因为该任务是可被中断唤醒的，所以先唤醒后面新加的等待任务，所以才会判断 if(* p\u0026amp;\u0026amp;* p！=current)如果p存在但不等于当前进程a，他就会让* p指向的进程d唤醒，然后然被某个信号唤醒的进程a继续睡眠（就是repeat回去的那条代码做的事）此时* p=NULL，所以后面都不会在进入 if(* p\u0026amp;\u0026amp;* p！=current)里面，而是通过tmp不断唤醒他连接的在他之前睡眠的进程，一直这样唤醒到tmp指向的是被某个信号唤醒的进程的程序a，然后执行schedule()后面的代码，此时if(tmp)的代码就是将本进程从阻塞态转换成就绪态。\n所以我们调用该睡眠函数 就在一开始添加写入阻塞的信息，在后面添加写入就绪的信息\nsys_pause()，sys_waitpid()函数也是可用于阻塞的，所以我们也需要再次加入写入阻塞信息的语句\n改动分别如下图\n 运行-\u0026gt;退出  在kernel/exit.c文件中的do_exit()函数中，改动如下：\n至此记录进程运行轨迹的任务完成。\n四、进程运行轨迹的跟踪与统计结果 我们尽量在Linux0.11外写好process.c文件(因为Linux0.11装载的vi书写效率很低)，然后在bochs虚拟机装载的Linux根目录文件系统的镜像文件所在目录，通过这个方式我们能进行文件交通信，通过\n1  sudo ./mount-hdc   打开访问权限，然后将process.c文件放入hdc/usr/root/ 文件夹里。\n然后输入(目录不要变，不是在hdc里面，而是hdc外一层目录，就是输入第一个指令的目录)\n1  sudo umount hdc   卸载该文件系统。\n在然后在上述目录下运行Linux0.11，并编译运行process.c\n1 2 3 4  ./run //运行Linux0.11 ls //可以查看/usr/root有没有加入process.c文件 gcc process -o process.c //编译 ./process //运行   我们会看到如下运行结果\n此时process.log文件已经记录好了各进程的运行轨迹，因此我们退出Linux0.11\nprocess.log文件如下：\n我们通过上面说过的 打开我们bochs虚拟机装载的Linux的文件系统，从/hdc/var中找到process.log文件，拿到我们系统的文件夹中。\n因为我们重点不在书写统计结果的代码，所以我们现在利用现有的统计结果的代码直接统计，改代码的逻辑思路就是通过 ID号进行结果分类，再通过jiffies 和状态的关系进行简单的加减运算即可。\n统计代码是python写的，名称为stat_log.py，将该文件和process.log日志文件放在一起，从命令行进入该文件夹输入指令\n1  chmod +x stat_log.py   给该文件加上执行权限，在输入如下指令直接执行数据统计\n1  ./stat_log.py process.log   得到如下结果Turnaround 为进程的轮转时间，即进程执行的总时(任务完成时间减去任务开始时间)\nwaiting 就是进程睡眠时间\nCPU Burst为该进程执行指令的用时，I/O Burst为该进程使用I/O设备的用时。\n如果遇到\n1  Error at line xxx:It is a clone of previous line.   大概率是某个记录进程状态的添加的语句出现了错误或者少了if判断语句导致重复记录一个进程的状态或状态冲突了。\n上述的结果是在时间片设置为15的结果，接下来我们要更改为30，然后再来观察进程运行的时间有何变化。\n进程的调度算法是采用的“时间片轮转调度”，每个进程都有一个时间片的时间来执行，也就是时分复用。\n在sched.c文件中，调度函数schdule()定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  while (1) { c = -1; next = 0; i = NR_TASKS; p = \u0026amp;task[NR_TASKS]; // 找到 counter 值最大的就绪态进程  while (--i) { if (!*--p) continue; if ((*p)-\u0026gt;state == TASK_RUNNING \u0026amp;\u0026amp; (*p)-\u0026gt;counter \u0026gt; c) c = (*p)-\u0026gt;counter, next = i; } // 如果有 counter 值大于 0 的就绪态进程，则退出  if (c) break; // 如果没有： // 所有进程的 counter 值除以 2 衰减后再和 priority 值相加， // 产生新的时间片  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p) if (*p) (*p)-\u0026gt;counter = ((*p)-\u0026gt;counter \u0026gt;\u0026gt; 1) + (*p)-\u0026gt;priority; } // 切换到 next 进程 switch_to(next);   我们寻找counter最大的就绪进程进行调度，每个进程的counter会在时钟中断时减1，因此如果我没找不到大于0的就绪态进程，就会执行下列指令\n1 2 3 4 5 6  // 如果没有： // 所有进程的 counter 值除以 2 衰减后再和 priority 值相加， // 产生新的时间片  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p) if (*p) (*p)-\u0026gt;counter = ((*p)-\u0026gt;counter \u0026gt;\u0026gt; 1) + (*p)-\u0026gt;priority; }   通过将counter从负值缩小两倍，然后加上其优先级，直到获得一个大于0的counter的进程。不过要注意，这里是对所有的进程都执行这样的操作，包括阻塞态，因此阻塞的越久的进程，counter越大，且优先级越高，counter越大。\n你可能会想，既然是通过counter来判断调度哪一个处于就绪态的进程，那新建的子进程的counter如何设置呢？\n我们查看fork.c文件中的copy_process()函数\n1 2 3 4 5 6 7  // 用来复制父进程的PCB数据信息，包括 priority 和 counter *p = *current; // 初始化 counter p-\u0026gt;counter = p-\u0026gt;priority; // 因为父进程的counter数值已发生变化，而 priority 不会，所以上面的第二句代码将p-\u0026gt;counter 设置成 p-\u0026gt;priority。 // 每个进程的 priority 都是继承自父亲进程的，除非它自己改变优先级。   该实验并不涉及更改子进程的priority，因此创建的进程的初始counter都被设置为进程0的priority.\n那么我们找到进程0的priority设置的文件，其在include/linux/sched.h中INIT_TASK宏中定义为：\n1 2 3  #define INIT_TASK \\ { 0,15,15, // 上述三个值分别对应 state、counter 和 priority;   我们更改如下：将15-\u0026gt;30\n最后再次执行process.c，再次通过stat_log.py文件统计process.log文件，得到如下结果\n平均的轮转时间和等待时间比15时间片和优先级更短了一些。\n先把结论说了：\n时间片变小，导致产生进程调度次数变多，从而导致进程等待时间越长\n时间片变大，导致进程因中断或睡眠进入的进程调度次数也增加，等待时间也越长\n那为什么上面时间片变大了，执行和等待时间变小了呢？\n因为在最大和最小之间有个平衡，会是最优的选择，30可能碰巧在这了。说白了就是我的测试用例少了(主要是懒了)。\n所以要合理设置时间片的大小，太小太大都会影响CPU效率。\n那么单进程和多进程编程最大区别是什么呢？\n单进程程序我们写的多了，顺序执行，逻辑单线，在没有其他程序干扰下，数据是同步的。\n而多进程程序却在宏观时间看是同时执行的，正因为共享文件，而进程之间的执行顺序没法控制，因此要考虑进程之间的关系和互相影响的情况，要做好数据的异步处理，避免数据污染，进程之间同步，通信，互斥等关系也要在编程时有个清晰的框架。\n结束~~！\n","permalink":"http://int80.top/oslab3/","tags":["操作系统"],"title":"进程运行轨迹的跟踪与统计"},{"categories":["操作系统"],"contents":"LAB2 一、 任务内容：\n在原有的linux0.11上添加两个系统调用，及其相应的响应函数，并通过API调用系统调用。\n两个系统调用的原型和应该完成的功能如下\n（1）iam()\n1  int iam(const char *name);   功能：将name的内容拷贝到内核中保存下来\n要求：name长不能超过24个字符，包括最后的'\\0'\n返回值：拷贝的字符串name的长度。若name长超过24，则返回 -1，并置errno为EINVAL（errno是个头文件，即return -EINVAL,EINVAL是errno.h里的一个宏定义）\n（2）whoami()\n1  int whoami(char *name,unsigned int size);   功能：将iam()保存到内核空间的字符串拷贝到name字符串指向的用户地址空间中，为了确保name不会越界访问，用size说明其大小\n返回值：拷贝字符串name的长度。若size小于name所占空间，返回 -1，并置errno为EINVAL\n二、明确何为系统调用。做什么的？如何做？\n要谈系统调用，那我们还是先了解一下何为内核。(只是让我自己再复习一下概念，能否说清楚)\n操作系统其实就是一个监控程序，对的，也是一个程序。它相当于单片机我们写的while(1)，而内核就是操作系统最核心的部分，也即这个程序里面最核心的代码。我们可以从linux源码看出其内核负责处理各种核心任务，比如I/O,进程管理，内存管理等。\n所以内核即操作系统这个程序里面最关键的代码。也就是他是计算机资源的管理者，包括硬件，软件资源。软件资源就是各种形式的数据，比如各种文件，软件程序。硬件资源就是总线、CPU、内存、磁盘、网卡、显卡及各种IO。\n那么系统调用是如何出现的呢？\n我们假设如果没有操作系统来管理各种进程，举个栗子，每个进程需要放进内存才能执行，那么就会在占用内存空间，如果两个任务同时申请同一个内存空间会造成冲突。更为严重，如果一个任务占用了必须一直运行的程序或者非常重要的程序的内存空间，那么计算机就崩溃了。\n同时，如果有操作系统，并且不对进程加以限制及控制，会发生什么情况？\n在举几个栗子，对于单任务，他可能把他的空间占用到了原本分配给操作系统的空间，那么两者就混合了，没办法区分，并且用户程序可以访问大部分硬件设备，甚至改变操作系统，如果一个病毒(恶意进程)也连接到了操作系统的程序里面，那它就成了操作系统的一部分了，因为没办法区分嘛。\n多任务呢？如果多个进程同时操控同一个硬件设备，数据传输就会错误，数据被污染，可以理解为一个程序的数据发送到了另一个程序。同时操作系统必须自己响应硬件中断，通过硬件中断来切换任务上下文，让合适的任务在合适时机运行。如果中断响应程序被更改了呢？操作系统又会如何运行呢？\n综上，操作系统必须要清楚哪些程序占用那些资源，合理控制分配，才能有序运行下去。为了避免一个普普通通的进程将自己干掉取代，操作系统必然需要采取强硬措施保证自己的地位。核心问题在于保护关键寄存器和重要的物理内存。\n既然操作系统是个监控程序，它要控制其下的进程，那么各种进程就必须要有分级制度，并且操作系统拥有最高控制权才能让其余的进程服从它的安排。这就引出了用户态和内核态。因此，只有有操作系统的前提，用户态和内核态这种概念才会存在。因为对于CPU来说不过是状态标志位的改变，即寄存器几个有特殊意义的位改变后，CPU有不同的工作方式。为了用户使用的方便，操作系统才衍生这用户态和内核态的概念\n这个控制权由硬件来控制，当CPU引导进入保护模式后，会有一张全局描述符表，记录了各代码段的特权级别，在linux中特权级别为0-3，0级等级最高。CS寄存器中有两位(CPL，当前特权级)用来指明CPU当前的特权级，0最高，3最低，分别称为内核态和用户态。同时还存在请求特权级RPL，其存在请求者的程序代码里，代码里要提供一个选择子selector，RPL保存选择子的最低两位。访问时的特权检查根据：有效特权级EPL=max(RPL,CPL)\u0026lt;=CPL是否成立，所以用户程序最多访问CPL级别的代码段。\n当用户态进入内核态，特权级升高，内核态回到用户态，特权级降低。这个进程切换的同时还会切换相应的栈，ESP从用户栈切换到内核栈，再从内核栈切换到用户栈。以上措施皆为限制程序的访问能力来保证操作系统的安全。\n由上面我们也可以知道，用户态不能随随便便切换到内核态，要是随意切换，那操作系统不就也还是危险的了嘛。但是用户态必须要使用硬件设备，让操作系统来和硬件交互执行程序的各种功能，所以我们需要进入内核态啊，那么我们要如何做呢？这时候需要一个机制：用户态程序切换到内核态，但不能控制内核态中执行的指令。\n这个机制就是系统调用(嘿嘿，说了那么多终于讲到它了)，而执行机制的方法就是中断（异常的一种，且不仅这一个方法，所以称为”异常“会更为准确，例如缺页也会进入内核态进行取页换页的操作），可以理解为中断是能够陷入内核态的有效手段。用户程序通过系统调用的这个方法，告诉内核他要去操控哪些计算机资源。所以系统调用是内核态与用户态的分界\n例如我们使用printf函数，他就告诉了内核要控制显示器输出这样的字符串，所以我们可以在屏幕上看到字符串的输出，说明我们的程序已经进入过内核态并将数据传递给了显示器这个硬件。\n系统调用即调用系统函数，通过系统函数来实现控制硬件。系统函数是调用系统库中为该系统调用编写的一个接口函数(API)，但API并不会自己完成系统调用，而是真正的系统调用被封装在API中，换句话说，API调用真正的系统调用。例如write()这个系统函数就是一个API，这个函数中还有指令真正用来实现在显示器上显示字符。\n那么系统函数也是函数和我们用户态写的用户程序的函数有什么区别呢？调用用户程序的自定义函数，在汇编层面是通过call指令跳转到该函数地址，然后执行。\n而调用API到API调用真正的系统调用的过程如下：\n 将系统调用函数的编号存入EAX; 把函数参数存入其他通用寄存器; 触发int 0x80，请求处理系统调用的system_call来处理;  该次任务，我们在用户程序直接执行我们所写的系统调用函数。\n这个过程如下：\n 应用程序调用库函数(API) API将系统调用号存入EAX，通过中断调用使系统进入内核态 内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用） 系统调用完成相应功能，将返回值存入EAX，返回到中断处理函数 中断处理函数返回到API API将EAX的值返回给应用程序  三、分析及实现\n我们会从一些系统函数进行分析来充分理解用户程序是如何进行系统调用的。\n我们查看Linux0.11源码里的lib/close.c中close()的API\n1 2 3 4  #define __LIBRARY__ #include \u0026lt;unistd.h\u0026gt; _syscall1(int, close, int, fd)   _syscall 是一个宏，其在include/unistd.h中定义\n1 2 3 4 5 6 7 8 9 10 11 12  #define _syscall1(type,name,atype,a) \\ type name(atype a) \\ { \\ long __res; \\ __asm__ volatile (\u0026#34;int $0x80\u0026#34; \\ : \u0026#34;=a\u0026#34; (__res) \\ : \u0026#34;0\u0026#34; (__NR_##name),\u0026#34;b\u0026#34; ((long)(a))); \\ if (__res \u0026gt;= 0) \\ return (type) __res; \\ errno = -__res; \\ return -1; \\ }   将_syscall1(int，close，int，fd)进行宏展开有\n1 2 3 4 5 6 7 8 9 10 11  int close(int fd) { long __res; __asm__ volatile (\u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (__res) : \u0026#34;0\u0026#34; (__NR_close),\u0026#34;b\u0026#34; ((long)(fd))); if (__res \u0026gt;= 0) return (int) __res; errno = -__res; return -1; }   这个就是API的定义，里面包含了调用真正的系统调用。将宏__ NR_close存入EAX ( 你是不是会疑惑__ NR_close怎么出来的？咱先按下不表)，然后将fd存入EBS，然后进行0x80中断调用。从EAX取出返回值存入__res中，判断后再决定传什么值给API调用者。对比API进行真正系统调用的过程，那么可知这个就是进行了API到真正系统调用的实例。\n那么__NR_close是什么呢？它其实就是系统调用的编号，我们有一步要将系统调用号写入EAX让内核知道要调用哪一个内核函数嘛。所有系统调用的编号都在include/unistd.h里面定义。我们要自己写系统调用函数，也需要给我们的函数一个编号。\n1 2 3 4 5  #define __NR_close 6 /* 所以添加系统调用时需要修改include/unistd.h文件， 使其包含__NR_whoami和__NR_iam。 */   因此对于我们写的用户程序调用系统调用需要有如下内容\n1 2 3 4 5 6 7 8 9 10 11  /* 有它，_syscall1 等才有效。详见unistd.h */ #define __LIBRARY__  /* 有它，编译器才能获知自定义的系统调用的编号 */ #include \u0026#34;unistd.h\u0026#34; /* iam()在用户空间的接口函数，调用系统调用，是系统调用iam()的API，在这个宏里面完成真正系统调用 */ _syscall1(int, iam, const char*, name); /* whoami()在用户空间的接口函数 */ _syscall2(int, whoami,char*,name,unsigned int,size);   所以我们在unistd.h文件中添加如下的内容\n如此我们就将我们自己写的系统调用函数设置好了\n我们调用close()API时调用了int 0x80，所以我们要从此进入内核。\n首先来了解0x80中断执行的过程\n首先我们看内核初始化的时候，主函数main()中调用了sched_init()初始化函数（现在是系统调用初始化的分析）\n1 2 3 4 5 6 7 8  void main(void) { // ……  time_init(); sched_init(); buffer_init(buffer_memory_end); // …… }   sched_init() 在kernel/sched.c中定义\n1 2 3 4 5  void sched_init(void) { // ……  set_system_gate(0x80,\u0026amp;system_call); }   set_system_gate()是个宏，在include/asm/system.h中定义。我们可以看到他传入0x80这个参数和system_call这个中断程序的地址。\n1 2  #define set_system_gate(n,addr) \\ _set_gate(\u0026amp;idt[n],15,3,addr)   而_set_gate定义为\n1 2 3 4 5 6 7 8 9 10  #define _set_gate(gate_addr,type,dpl,addr) \\ __asm__ (\u0026#34;movw %%dx,%%ax\\n\\t\u0026#34; \\ \u0026#34;movw %0,%%dx\\n\\t\u0026#34; \\ \u0026#34;movl %%eax,%1\\n\\t\u0026#34; \\ \u0026#34;movl %%edx,%2\u0026#34; \\ : \\ : \u0026#34;i\u0026#34; ((short) (0x8000+(dpl\u0026lt;\u0026lt;13)+(type\u0026lt;\u0026lt;8))), \\ \u0026#34;o\u0026#34; (*((char *) (gate_addr))), \\ \u0026#34;o\u0026#34; (*(4+(char *) (gate_addr))), \\ \u0026#34;d\u0026#34; ((char *) (addr)),\u0026#34;a\u0026#34; (0x00080000))   这里展示的是将system_call函数地址写到0x80对应的中断描述符中，相当于执行int 0x80指令，会产生一个异常陷入内核空间并执行系统调用处理函数system_call，那么明白了0x80号中断如何和system_call产生联系后，我们简单看下system_call的代码，是纯汇编语言编写的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  !…… ! # 这是系统调用总数。如果增删了系统调用，必须做相应修改，所以我们增加两个系统调用函数，这里数值+2 nr_system_calls = 72 !…… .globl system_call .align 2 system_call: ! # 检查系统调用编号是否在合法范围内 cmpl \\$nr_system_calls-1,%eax ja bad_sys_call push %ds push %es push %fs pushl %edx pushl %ecx ! # push %ebx,%ecx,%edx，是传递给系统调用的参数 pushl %ebx # to the system call ! # 让ds, es指向GDT，内核地址空间（修改段选择子为内核段） movl $0x10,%edx mov %dx,%ds mov %dx,%es movl $0x17,%edx ! # 让fs指向LDT，用户地址空间 mov %dx,%fs call sys_call_table(,%eax,4) pushl %eax movl current,%eax cmpl $0,state(%eax) jne reschedule cmpl $0,counter(%eax) je reschedule   并不需要完全理解每一句话，知道他整个程序是干什么的即可。当我们调用system_call这个函数后，可以看到他保存了“现场”，各种push将用户态的各种参数入栈，并让fs指向用户空间，都是为了从内核态回到用户态后，还能还原进入内核态前的状态。(这是操作系统完成的部分保存，硬件完成的还有一部分，比如ss、esp、cs等寄存器)\n并且该函数让我们从用户态陷入到了内核态。其余的简单了解一下即可。\n我们关注\n1  call sys_call_table(,%eax,4)   我们知道EAX存放的是系统调用号，即__NR_xxxx。根据汇编寻址方法为\n1  call sys_call_table + 4 * %eax   那么sys_call_table又是什么呢？我们可以在include/linux/sys.h中找到\n那么可知它是一个函数指针数组的起始地址。\n因此我们根据系统调用号算出系统调用相应的响应函数在表里的位置，并调用该函数。\n所以我们要在sys.h中加上 sys_iam() ,sys_whoami()两个响应函数引用\n更改如下图所示\n这里函数表添加的位置要和__NR_xxxx的值对应上，因为我们是根据这个值来计算函数在表里的位置的。\n那么因此可以知道我们执行 int 0x80 中断指令后就能保存现场-\u0026gt;陷入内核-\u0026gt;调用系统响应相应的响应函数。\n所以，那么我们就该写系统函数sys_iam()和sys_whoami(),我们将这两个函数写成一个who.c文件，这样就只需要一次编译。在完成这两个函数完整功能前，我们先写个测试代码。\n1 2 3 4 5 6  int sys_iam(const char* name){ printk(\u0026#34;Hello from sys_iam\u0026#34;); } int sys_whoami(char* name,unsigned int size){ printk(\u0026#34;Hello from sys_whoami\u0026#34;); }   可能会有小伙伴疑问了？欸，为什么是printk而不是printf呢？ 首先明确我们现在是系统函数，调用这个函数的时候我们处于内核态，而内核态是不能使用用户态的函数printf的，所以有printk函数给内核函数使用。这两个函数本质调用的都是tty_write这个函数，但printk是在内核态，对fs寄存器操作不同于printf，因为fs寄存器指向用户态，所以他要将fs寄存器的内容入栈，保存现场，然后指向内核段，出内核态后再pop出\u0026amp;fs恢复现场\n然后我们运行 Linux0.11，并在上面编写test.c文件来调用系统函数。\n1 2 3 4 5 6 7 8 9 10 11 12  #define __LIBRARY__ #include \u0026lt;unistd.h\u0026gt;//iam()和whoami()两个系统调用的入口参数 _syscall1(int, iam, const char *, name); _syscall2(int, whoami, char*, name,unsigned int,size); int main(void){ char buf[24]; iam(\u0026#34;test\u0026#34;); //这句和下句都只是满足需要传入参数，才能运行。  whoami(buf,24); return 0; }   那么这样我们就能调用iam()和whoami()两个系统调用的响应函数sys_iam和sys_whoami了。我们得到输出\n因此我们可以确定我们增加系统调用和响应函数成功了，那么我们现在将响应函数更改为我们想要的功能。\n我们知道指针传递的参数是程序所在地址空间的逻辑地址，如果在内核就直接访问这个地址，得到的是内核空间的数据，而不会是用户态的数据，所以要把name这个字符串被内核读取存入，还需要其他的方法。\n我们从open(char *filename，…..)来分析open（）这个系统调用是如何处理内核态从用户态读取数据的。\n1 2 3 4 5 6 7 8 9  int open(const char * filename, int flag, ...) { // ……  __asm__(\u0026#34;int $0x80\u0026#34; :\u0026#34;=a\u0026#34; (res) :\u0026#34;0\u0026#34; (__NR_open),\u0026#34;b\u0026#34; (filename),\u0026#34;c\u0026#34; (flag), \u0026#34;d\u0026#34; (va_arg(arg,int))); // …… }   这段我们分析过了，就是把各种参数存在寄存器中。但这里open的文件名是通过EBX传递，就是进入内核后，通过EBX取出文件名字符串。但EBX指向的数据在用户空间，执行的却是内核代码。\n1 2 3 4 5 6 7 8 9 10 11  system_call: //所有的系统调用都从system_call开始 ! …… pushl %edx pushl %ecx pushl %ebx # push %ebx,%ecx,%edx，这是传递给系统调用的参数 movl $0x10,%edx # 让ds,es指向GDT，指向核心地址空间 mov %dx,%ds mov %dx,%es movl $0x17,%edx # 让fs指向的是LDT，指向用户地址空间 mov %dx,%fs call sys_call_table(,%eax,4) # 即call sys_open   这段代码也分析过了，就是各种参数入栈来保存，然后通过fs获得用户数据段的数据。然后call sys_call_table，我们会得到sys_open响应函数\n1 2 3 4 5 6 7 8  int sys_open(const char * filename,int flag,int mode) //filename这些参数从哪里来？ { …… if ((i=open_namei(filename,flag,mode,\u0026amp;inode))\u0026lt;0) { …… } …… }   你可能会问我们不是查表找到的响应函数吗？那这些参数哪里获得呢？看看上面的汇编代码，我们pushl 了各种寄存器的值入栈，这些就是函数的参数。我们C语言函数调用另一个函数，就是要将传递的参数压栈，从右到左顺序压，然后call调用。如果要用汇编程序调用C函数就需要自己手动编写这些压栈代码。\n最后我们看到这些参数传给了open_namei（），我们继续深究会发现他里面还传给了dir_namei(),get_dir()，我们从get_dir函数看到\n1 2 3 4 5 6 7 8  static struct m_inode * get_dir(const char * pathname) { …… if ((c=get_fs_byte(pathname))==\u0026#39;/\u0026#39;) { …… } …… }   那么我们就可以知道可以通过 get_fs_byte()这个函数获得用户空间的一个字节的数据。\n那么如何从内核态拷贝数据到用户态呢？\n我们在include/asm/segment.h中查看：\n1 2 3 4 5 6 7 8 9 10 11  extern inline unsigned char get_fs_byte(const char * addr) { unsigned register char _v; __asm__ (\u0026#34;movb %%fs:%1,%0\u0026#34;:\u0026#34;=r\u0026#34; (_v):\u0026#34;m\u0026#34; (*addr)); return _v; } extern inline void put_fs_byte(char val,char *addr) { __asm__ (\u0026#34;movb %0,%%fs:%1\u0026#34;::\u0026#34;r\u0026#34; (val),\u0026#34;m\u0026#34; (*addr)); }   即put_fs_byte和其配套，可将内核态数据写入用户态。\n我们是否可以获得一个规律put_fs_xxx() and put_fs_xxx()是用来连接内核态和用户态的呢？\n那我们开始写sys_iam 和 sys_whoami函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #include \u0026lt;string.h\u0026gt;#include \u0026lt;errno.h\u0026gt;#include \u0026lt;asm/segment.h\u0026gt; #define maxsize 24 char msg[maxsize]; int msglen; int sys_iam(const char* name){ int len=0; while(get_fs_byte(\u0026amp;name[len])!=\u0026#39;0\u0026#39;) len++; if(len\u0026gt;23) return -EINVAL; int i=0; for(;i\u0026lt;len;++i) msg[i] = get_fs_byte(\u0026amp;name[i]); msg[i] = \u0026#39;\\0\u0026#39;; msglen = len; return msglen; } int sys_whoami(char *name, unsigned size){ if(size \u0026lt; msglen) return -EINVAL; int i=0; for(;i\u0026lt;msglen;++i) name[i] = put_fs_byte(msg[i]); return msglen; }   当我们who.c完成后要在makefile里面增加对who.o的依赖\n如下图：\n然后在添加对who.c and who.o 的依赖的产生条件,如下图：\n完成上述步骤后，执行下面指令\n1  make all   进行整体编译\n然后我们运行 Linux0.11，我们还需要在这里面添加iam和whoami两个系统调用号的宏定义。\n1 2  cd /usr/include/ vi unistd.h   然后加上系统调用号\n然后\n1 2 3  cd /usr/root/ vi iam.c vi whoami.c   进行我们用户程序iam.c代码的编写（将传入字符串写入内核空间）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #define __LIBRARY__ // #include \u0026lt;unistd.h\u0026gt;\t// 要想调用系统调用需要这些两个#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; _syscall1(int,iam,const cahr*,name);//iam()系统调用的用户接口  int main(int argc, char **argv){ int i; if(argc!=2){ printf(\u0026#34;Usage: %s \u0026lt;message\u0026gt;\\n\u0026#34;,argv[0],argv[1]); return 0; } i = iam(argv[1]); //这句系统调用就将我们传入的name写入了内核空间  if(i != strlen(argv[1])){ printf(\u0026#34;set message error\\n\u0026#34;); return 0 } return 0; }   在进行whoami.c的编写\n1 2 3 4 5 6 7 8 9 10 11 12  #define __LIBRARY__ #include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt; _syscall2(int,whoami,char *,name, unsigned int,size); int mai(){ char message[24]; whoami(message,24); printf(\u0026#34;%s\\n\u0026#34;,message); return 0; }   我们采用如下命令编译iam.c和whoami.c两个文件\n1 2  gcc -o iam iam.c gcc -o whoami whoami.c   只要没有其他语句出现那么就算程序写对了\n然后我们运行代码得到如下结果\n至此我们的任务完成！！！\n我们总结一下，\n系统调用的步骤-\u0026gt;明白系统调用需要添加哪些信息代码-\u0026gt;编写系统调用的响应函数（就是系统调用iam()后他会执行的功能的函数）-\u0026gt;用户程序调用执行。\n了解系统调用过程要明白0x80号中断是如何陷入内核态的\n这里我们__NR_xxxx是系统调用号，一个宏定义。在响应函数表里添加响应函数sys_xxx。编写响应函数（也称内核函数）。\n用户程序需要#define __ LIBRARY __ ; #include \u0026lt;unistd.h\u0026gt; ; _ syscall1(type,name,type,parameter….)。分别是 使能 _syscallx函数，引入系统调用号的宏，创建系统调用的用户程序接口（系统调用的API）。\n我们这里是直接调用系统调用，所以直接使用_syscallx，平时例如我们使用的printf作为系统调用的API\n附：\nerrno是传统的错误代码返回机制。通常我们会返回0或1代表正确或错误，但不能说明哪错了，错了什么。所以全局变量errno就能保存错误值，调用者可以通过判断errno来决定如何应对错误。错误值的含义都有标准定义。\n","permalink":"http://int80.top/oslab2/","tags":["操作系统"],"title":"操作系统的系统调用"},{"categories":["操作系统"],"contents":"lab 1 环境：通过bochs虚拟机运行的linux0.11\n0x7C00是BIOS将主引导扇区（第一个扇区）内容载入进内存的一个地址。操作系统或者引导程序必须假设他们的汇编代码从内存的0x7C00地址开始\ntask 1 更改系统启动的提示文字。\n文件在boot/bootsect.s中。\n直接用源码的这个文件在里面改也是可以的，也可以自己写一个如下内容的bootsect.s来进行实验，也是能正常运行。（记得备份）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  entry _start _start: ！获得光标位置 mov ah,#0x03 xor bh,bh int 0x10 ！0x10中断的0x03功能是读取光标位置（百度该中断的功能） ！对输出信息的操作 mov cx,#33 !要显示字符串的长度 mov bx,#0x000c !显示字符串的颜色（这为红色 mov bp,#msg1\t!向该寄存器读入msg1，向屏幕写入该字符串 ！这里需要额外处理es寄存器，源码在这段代码前就处理过了，所以源码看不到这段。 mov ax,#0x07c0 mov es,ax ！es:bp是显示字符串的地址 mov ax,#0x1301 !向屏幕写字符串并移动光标到末尾。如果写0x1300，你会发现光标返回到了起始位置 int 0x10 ！和上一条指令相关，!0x1301是调用0x10中断的13号功能中的1号子功能 inf_loop: jmp inf_loop ！死循环让界面保持 msg1: .byte 13,10 ！回车换行 .ascii \u0026#34;Hey Doors system loading...\u0026#34; .byte 13,10,13,10 ！回车换行回车换行 .org 510 ！之后的语句从510地址开始 boot_flag: .word 0xAA55 ！磁盘引导标志0xAA55。引导扇区的最后两个字节，用来识别引导扇区   1 2 3 4 5 6  编译bootsect.s 1. cd 进入 bootsect.s文件所在文件夹 2. 通过如下命令分别编译和链接bootsect.s $ as86 -0 -a -o bootsect.o bootsect.s $ ld86 -0 -s -o bootsect bootsect.o 3. 通过 ls -s 命令查看 文件信息，会发现bootsect 为544字节，但一个扇区的大小为512字节   因为ld86产生的是Minix可执行文件，该类型额外包括MInix可执行文件头部，结构如下\n1 2 3 4 5 6 7 8 9 10 11 12  struct exec { unsigned char a_magic[2]; //执行文件魔数  unsigned char a_flags; unsigned char a_cpu; //CPU标识号  unsigned char a_hdrlen; //头部长度，32字节或48字节  unsigned char a_unused; unsigned short a_version; long a_text; long a_data; long a_bss; //代码段长度、数据段长度、堆长度  long a_entry; //执行入口地址  long a_total; //分配的内存总量  long a_syms; //符号表大小 };   通过计算 char6(6 byte)+short1(2 byte)+long*6(24 byte)=32 byte，512+32=544.所以我们应该跳过bootsect的前32字节，再把他放入引导扇区中。\n根据如下命令\n1  $ dd bs=1 if=bootsect of=Image skip=32   将编译产生的Image文件复制到Linux-0.11目录下\n1 2 3 4 5  当前工作路径仍然为Linux-0.11/boot/ $ cp ./Image ../Image # 执行 oslab 目录中的 run 脚本（bochs的运行脚本） $ ../../run   综上，得到如下界面\nbootsect.s是操作系统最开始的部分，共512个字节，再0磁道0扇区位置，读入内存0x7c00。\n现在系统还在实模式下运行，物理地址=代码段cs*16+偏移，所以代码里写BOOTSEG=0x07c0才能得到0x7c00（这里的代码没用到）\nbootsect.s和setup.s是为了完成将内核加载到内存，并跳转到内核执行而写的。bootsect.s是由BIOS加载到内存中，无法完成跳转到内核执行的任务。而setup.s就能完成进入32位模式并跳转到内核执行的任务，还可通过BIOS中断获取硬件信息的任务。\n所以接着我们应该编写setup.s文件，让其输出提示该文件开始运行的字符串，再让其输出光标位置，内存大小和磁参数等硬件信息\ntask 2 首先输出字符串\n我们直接将bootsect.s的代码复制过来，因为现在两者功能都是输出字符串。\n但我们需要进行一些更改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  entry _start _start: ！获得光标位置 mov ah,#0x03 xor bh,bh int 0x10 ！0x10中断的0x03功能是读取光标位置（百度该中断的功能） ！对输出信息的操作 mov cx,#28 #要显示字符串的长度 mov bx,#0x000c #显示字符串的颜色（这为红色 mov bp,#msg2 !(更改为msg2)\t#向该寄存器读入msg2，向屏幕写入该字符串 ！这个时候要修改es的值，用了cs的值。 mov ax,cs mov es,ax ！es：bp是显示字符串的地址 mov ax,#0x1301 ！向屏幕写字符串并移动光标到末尾。如果写0x1300，你会发现光标返回到了起始位置 int 0x10 ！和上一条指令相关，#0x1301是调用0x10中断的13号功能中的1号子功能 inf_loop: jmp inf_loop ！死循环让界面保持 msg1: .byte 13,10 ！回车换行 .ascii \u0026#34;OK we are in SETUP now\u0026#34; .byte 13,10,13,10 ！回车换行回车换行 .org 510 ！之后的语句从510地址开始 boot_flag: .word 0xAA55 ！磁盘引导标志0xAA55。引导扇区的最后两个字节，用来识别引导扇区   上面是setup.s文件的内容，\n此时我们还需要更改bootsect.s的内容让其能载入setup.s文件\n我们需要确定setup所占用的扇区，bootsect.s只占用一个扇区，setup.s从下一个扇区开始，我们定义其占用两个（Linux0.11占用4个）。源码会将bootsect移动到0x9000处，此处我们不移动，所以bootsect.s在内存的0x7c00的位置，占512个字节，那么setup就载入0x7e00处，因为是实模式，所以逻辑地址应该为0x07e0.\nbootsect.s代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  SETUPLEN=2 SETUPSEG=0x07e0 ！setup载入地址 entry _start _start: mov ah,#0x03 xor bh,bh int 0x10 mov cx,#33 mov bx,#0x0007 mov bp,#msg1 mov ax,#0x07c0 mov es,ax ！把es指向0x07c0有什么用？ mov ax,#0x1301 int 0x10 ！以上和之前的bootsect一样 load_setup: mov dx,#0x0000 ！设置驱动器和磁头：软盘0，磁头0，是因为调用了13号中断才能控制磁盘，不是0x0000地址的意思 mov cx,#0x0002\t！设置扇区号和磁道：磁头0 磁道0 扇区2 mov bx,#0x0200\t！设置读入的内存地址：es:bx bx是偏移地址，BOOTSEG=0X0000+adress=512=0x0200，偏移512字节 mov ax,#0x0200+SETUPLEN ！设置读入的扇区数 int 0x13 ！调用0x13中断，功能是读入2个setup.s扇区 jnc ok_load_setup ！读入成功就跳转到该函数 mov dx,#0x0000 ！否则进入下段 mov ax,#0x0000 ！复位软盘 int 0x13 jmp load_setup！重新循环再次尝试读取 ok_load_setup: jmpi 0,SETUPSEG ！跳到setup载入的地址执行该文件 msg1: .byte 13,10 .ascii \u0026#34;Hey Doors System loading...\u0026#34; .byte 13,10,13,10 .org 510 boot_flag: .word 0xAA55   以上 bootsect.s和setup.s就完成，接着是通过makefile共同编译\n指令如下\n1  $ make BootImage   然后会得到报错\n1 2  Unable to open \u0026#39;system\u0026#39; make: *** [BootImage] Error 1   因为makefile会执行build.c，他要求命令行参数得到bootsect、setup和system内核的文件名。但我们只做了前两者，所以会报错，那我们直接将build.c第三个参数的部分代码注释掉即可。\n如图所示。\n接着再使用如下指令\n1 2 3  $ cd ~/oslab/linux-0.11 $ make BootImage $ ../run   将得到如下结果\ntask 3 接着在完善setup.s文件让其还能再输出光标位置，内存大小和磁盘参数的信息\n我们将这些信息载入内存0x9000的位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172  INITSEG = 0x9000 entry _start _start: ! print string mov ah,#0x03 ! cursor pos get xor bh,bh int 0x10 mov cx,#28 mov bx,#0x000c ！字符颜色 mov bp,#msg2\tmov ax,cs mov es,ax ！修改es的值为cs mov ax,#0x1301 int 0x10 mov ax,cs mov es,ax !init ss:sp 初始化栈 mov ax,#INITSEG mov ss,ax ！栈指向0x9000 mov sp,#0xFF00 ！设置512B偏移地址，arbitrary value\u0026gt;\u0026gt;512，因为刚开始后面的内存空间都没被使用（这啥解释嘛） !cursor info mov ax,#INITSEG mov ds,ax ！ds寄存器指向0x9000，下面开始让各数据载入0x9000位置 mov ah,#0x03 xor bh,bh int 0x10 ！获取光标位置信息 mov [0],dx ！[0]从0x9000开始，将获取的数据放入这个内存地址 !memory info mov ah,#0x88 int 0x15 ！通过0x15中断得到memory大小信息 mov [2],ax ！存入0x9002位置 ! disk parameter 磁盘参数表 mov ax,#0x0000 mov ds,ax ！将数据段移动到0x0000，也是ram开始的位置，这个地方（0-1024）的位置存放中断向量表。在41号中断处读取第一个磁盘的参数。（不懂，不知道对不对。0x0000之前不是磁盘的地址吗）！！该问题已解决，在后面会独立说明。 ！乘4是因为中断向量表每个表项占4B，那么41号中断的入口地址自然为4*0x41 ！乘4就是将0x41左移两位，lds有两步操作：si\u0026lt;-4*0x41,ds\u0026lt;-[4*0x41+2]，中断向量表存储的只是相应中断号中断服务程序的入口地址。 ！其构造是4个字节单元，第2字节位偏移量ip，高两字节为服务程序段地址，所以ds是中断服务程序段地址，si为中断服务程序偏移。因此可以执行0x41中断的服务程序，把第一个磁盘的参数表取出来。 ！相当于运行 mov si,[4*0x41] mov ds,[4*0x41+2] lds si,[4*0x41] mov ax,#INITSEG mov es,ax mov di,#0x0004 mov cx,#0x10 #拷贝16字节的数据。一个磁盘参数表大小为16字节，第一个磁盘的参数表地址为0x9080，第二个为0x9090 rep movsb !ready to print mov ax,cs mov es,ax ！es:bp是输出字符串存放的地址 mov ax,#INITSEG\t！让ds寄存器指向0x9000 mov ds,ax !cursor position mov ah,#0x03 xor bh,bh int 0x10 mov cx,#11 mov bx,#0x0007 mov bp,#msg_cursor mov ax,#0x1301 int 0x10 mov ax,[0] ！将0x9000地址内容放入ax寄存器，print_hex函数用 call print_hex ！输出msg_cursor内容 call print_nl ！输出个回车 ！下面的都是相同的，不再注释 !memory size mov ah,#0x03 xor bh,bh int 0x10 mov cx,#12 mov bx,#0x0007 mov bp,#msg_memory mov ax,#0x1301 int 0x10 mov ax,[2] call print_hex call print_nl !cyles mov ah,#0x03 xor bh,bh int 0x10 mov cx,#25 mov bx,#0x0007 mov bp,#msg_cyles mov ax,#0x1301 int 0x10 mov ax,[4] call print_hex !heads mov ah,#0x03 xor bh,bh int 0x10 mov cx,#8 mov bx,#0x0007 mov bp,#msg_heads mov ax,#0x1301 int 0x10 mov ax,[6] call print_hex call print_nl !sectors mov ah,#0x03 xor bh,bh int 0x10 mov cx,#8 mov bx,#0x0007 mov bp,#msg_sectors mov ax,#0x1301 int 0x10 mov ax,[12] ！18？不太明白这个怎么每个数据长度怎么算的，可能固定有直接百度就可以？这个应该没必要深究 call print_hex call print_nl inf_loop: jmp inf_loop print_hex: mov cx,#4 ！16位二进制数以4位16进制表示，因为十六进制和ASCII有很好的对应 mov dx,ax ！将0x900x位置的数放入数据寄存器 print_digit: rol dx,#4 ！从高位到低位显示4位16进制数 mov ax,#0xe0f ！ah = 请求的功能值，al = 半字节(4 bit)掩码 and al,dl ！取dl的低4 bit add al,#0x30 cmp al,#0x3a ！数字的十六进制范围为0x30~0x39，小于0x3a jl outp ！al小于0x3a（为数字）跳转， add al,#0x07 ！否则就是字母，根据十六进制转ascii码的字母，字母要加上0x07，a~f的范围为0x41~0x46 outp: int 0x10 loop print_digit ！每次loop，cx-1，判断cx是否等于0，不为0就继续循环，为0就顺序执行，共循环4次 ret print_nl: mov ax,#0xe0d int 0x10 mov al,#0xa int 0x10 ret msg2: .byte 13,10 .ascii \u0026#34;OK we are in SETUP now\u0026#34; .byte 13,10,13,10 msg_cursor: .ascii \u0026#34;Cursor Pos:\u0026#34; msg_memory: .ascii \u0026#34;Memory Size:\u0026#34; msg_cyles: .ascii \u0026#34;KB\u0026#34; .byte 13,10,13,10 .ascii \u0026#34;HD Info\u0026#34; .byte 13,10 .ascii \u0026#34;Cylinders:\u0026#34; msg_heads: .ascii \u0026#34;Headers:\u0026#34; msg_sectors: .ascii \u0026#34;Sectors:\u0026#34; .org 510 boot_flag: .word 0xAA55   我们可以得到结果（我第一次试的时候不会弹两个窗口，但是第一次运行得到的数据出错）\n第一次运行：\n第二次运行\n对第二次分析\nmemory size = 3c00KB+1MB=16MB\ncylinders=00cc（H）=204（D）\n一些问题：\n首要问题 还是对汇编各种寄存器操作比较陌生，但还好慢慢啃，也能明白10%，知道基本的用法，需要抽时间好好学汇编。目前问题就是为什么有些寄存器能直接获得某些值，而不用赋值。不明白各种寄存器的用法和它本身会自己进行的操作有哪些。（提的问题也比较模糊，因为确实对汇编了解过少）例如为什么要把cs的值赋给es？之前也没有处理cs，他是代码寄存器，会默认存储代码段的地址吗？大概就是这类的问题。\n之前提到一个问题就是 为什么在bootsect.s中 mov ds，0x0000 是控制磁盘，而在setup.s中mov ax，0x0000却是中断向量表的位置。 答案：前者的是在int 0x13 即BIOS中断上操作的0x0000是对某个寄存器设置相应的值来获得某种功能进而控制磁盘，不是内存地址的0x0000。而setup.s的0x0000是内存的地址。\n","permalink":"http://int80.top/oslab1/","tags":["操作系统"],"title":"操作系统的引导"},{"categories":null,"contents":"INT80, 电子科技大学信通学院本科生\n​\t正努力自学成为一位白帽子\n","permalink":"http://int80.top/aboutme/","tags":null,"title":"About Me"},{"categories":null,"contents":"","permalink":"http://int80.top/search/","tags":null,"title":"Search"}]